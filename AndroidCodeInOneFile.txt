

--- START OF FILE app/build.gradle.kts ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

plugins {
  alias(libs.plugins.android.application)
  // Note: set apply to true to enable google-services (requires google-services.json).
  alias(libs.plugins.google.services) apply false
  alias(libs.plugins.kotlin.android)
  alias(libs.plugins.kotlin.compose)
  alias(libs.plugins.kotlin.serialization)
  alias(libs.plugins.protobuf)
  // BOURDON'S FIX: Suppression du plugin Hilt.
  // alias(libs.plugins.hilt.application)
  alias(libs.plugins.oss.licenses)
  kotlin("kapt") // KAPT est toujours n√©cessaire pour Parcelize, mais plus pour Hilt.
  id("kotlin-parcelize")
}

android {
  namespace = "be.heyman.android.ai.kikko"
  compileSdk = 35

  defaultConfig {
    applicationId = "be.heyman.android.ai.kikko"
    minSdk = 26
    targetSdk = 35
    versionCode = 1
    versionName = "1.0.4"

    // Needed for HuggingFace auth workflows.
    manifestPlaceholders["appAuthRedirectScheme"] = "be.heyman.android.ai.kikko.oauth"

    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
  }

  buildTypes {
    release {
      isMinifyEnabled = false
      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
      signingConfig = signingConfigs.getByName("debug")
    }
  }
  compileOptions {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
  }
  kotlinOptions {
    jvmTarget = "11"
    freeCompilerArgs += "-Xcontext-receivers"
  }
  buildFeatures {
    compose = true
    buildConfig = true
    // BOURDON'S FIX: Activation explicite du View Binding
    viewBinding = true
  }
  aaptOptions {
    noCompress("tflite")
  }
}

dependencies {
  // BOURDON'S FIX: Suppression des d√©pendances Hilt pour WorkManager et Hilt en g√©n√©ral.
  // implementation("androidx.hilt:hilt-work:1.2.0")
  // kapt("androidx.hilt:hilt-compiler:1.2.0")

  implementation("androidx.work:work-runtime-ktx:2.9.0")
  implementation(libs.androidx.core.ktx)
  implementation(libs.androidx.lifecycle.runtime.ktx)
  implementation(libs.androidx.activity.compose)
  implementation(platform(libs.androidx.compose.bom))
  implementation(libs.androidx.ui)
  implementation(libs.androidx.ui.graphics)
  implementation(libs.androidx.ui.tooling.preview)
  implementation(libs.androidx.material3)

  implementation(libs.androidx.compose.navigation)
  implementation(libs.kotlinx.serialization.json)
  implementation(libs.material.icon.extended)
  implementation(libs.androidx.work.runtime)
  implementation(libs.androidx.datastore)
  implementation(libs.com.google.code.gson)
  implementation(libs.androidx.lifecycle.process)
  implementation(libs.mediapipe.tasks.text)
  implementation(libs.mediapipe.tasks.genai)
  implementation(libs.mediapipe.tasks.imagegen)
  implementation(libs.commonmark)
  implementation(libs.richtext)
  implementation(libs.tflite)
  implementation(libs.tflite.gpu)
  implementation(libs.tflite.support)
  implementation(libs.camerax.core)
  implementation(libs.camerax.camera2)
  implementation(libs.camerax.lifecycle)
  implementation(libs.camerax.view)
  implementation(libs.openid.appauth)
  implementation(libs.androidx.splashscreen)
  implementation(libs.protobuf.javalite)
  // BOURDON'S FIX: Suppression des d√©pendances Hilt en g√©n√©ral.
  // implementation(libs.hilt.android)
  // implementation(libs.hilt.navigation.compose)
  implementation(libs.play.services.oss.licenses)
  implementation(platform(libs.firebase.bom))
  implementation(libs.firebase.analytics)
  // BOURDON'S FIX: Suppression du kapt Hilt.
  // kapt(libs.hilt.android.compiler)
  testImplementation(libs.junit)
  androidTestImplementation(libs.androidx.junit)
  androidTestImplementation(libs.androidx.espresso.core)
  androidTestImplementation(platform(libs.androidx.compose.bom))
  androidTestImplementation(libs.androidx.ui.test.junit4)
  // BOURDON'S FIX: Suppression de la d√©pendance Hilt pour les tests.
  // androidTestImplementation(libs.hilt.android.testing)
  debugImplementation(libs.androidx.ui.tooling)
  debugImplementation(libs.androidx.ui.test.manifest)

  // Vosk & JNA
  implementation("com.alphacephei:vosk-android:0.3.47@aar")
  implementation("net.java.dev.jna:jna:5.13.0@aar")
  implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.2")

  // ML Kit
  implementation("com.google.mlkit:barcode-scanning:17.2.0")
  implementation("com.google.mlkit:text-recognition:16.0.1")
  implementation("com.google.mlkit:text-recognition-japanese:16.0.1")
  implementation("com.google.mlkit:language-id:17.0.6")
  implementation("com.google.mlkit:translate:17.0.3")
  implementation("com.google.mlkit:object-detection:17.0.1")
  implementation("com.google.mlkit:object-detection-custom:17.0.2")
  implementation("com.google.mlkit:image-labeling:17.0.9")
  implementation("com.google.mlkit:image-labeling-custom:17.0.3")

  // BOURDON'S ADDITION: D√©pendances requises pour Google Nearby et Location
  implementation("com.google.android.gms:play-services-nearby:19.3.0")
  implementation("com.google.android.gms:play-services-location:21.3.0")

  // BOURDON'S ADDITION: D√©pendances pour AndroidX Media3 (ExoPlayer)
  val media3Version = "1.4.0"
  implementation("androidx.media3:media3-exoplayer:$media3Version")
  implementation("androidx.media3:media3-ui:$media3Version")

  // D√©pendances pour les layouts XML et AppCompat
  implementation("androidx.appcompat:appcompat:1.7.1")
  implementation("com.google.android.material:material:1.12.0")
  implementation("androidx.constraintlayout:constraintlayout:2.1.4")
  implementation("androidx.recyclerview:recyclerview:1.3.2")
  implementation("com.google.android.flexbox:flexbox:3.0.0")

  implementation("androidx.fragment:fragment-ktx:1.8.1")

  // BOURDON'S ADDITION: D√©pendance pour Glide (chargement d'images)
  implementation("com.github.bumptech.glide:glide:4.16.0")

}

protobuf {
  protoc { artifact = "com.google.protobuf:protoc:4.26.1" }
  generateProtoTasks { all().forEach { it.plugins { create("java") { option("lite") } } } }
}

--- END OF FILE app/build.gradle.kts ---


--- START OF FILE app/proguard-rules.pro ---

# R√®gles pour prot√©ger la librairie JNA (utilis√©e par Vosk)
-keep class com.sun.jna.** { *; }
-keepclassmembers class * extends com.sun.jna.** { public *; }

# Tu peux ajouter d'autres r√®gles ProGuard sp√©cifiques √† ton projet ici.

--- END OF FILE app/proguard-rules.pro ---


--- START OF FILE app/src/main/AndroidManifest.xml ---

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-sdk
        android:minSdkVersion="26"
        android:targetSdkVersion="35" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC"/>

    <uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />

    <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES"
        android:usesPermissionFlags="neverForLocation"
        tools:targetApi="tiramisu" />
    <uses-feature
        android:name="android.hardware.camera"
        android:required="false" />

    <application
        android:name=".KikkoApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="KiKKo's Saga Forge"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.KikkoSagaForge"
        tools:targetApi="31">

        <activity
            android:name=".StartActivity"
            android:exported="true"
            android:theme="@style/Theme.KikkoSagaForge">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".deck.DeckViewerActivity" android:exported="false" android:label="Mon Gardien Kikk≈ç" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".quiz.QuizActivity" android:exported="false" android:label="Kikko Quiz" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".clash.ui.ClashActivity" android:exported="false" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".pollen.ForgeLiveActivity" android:exported="false" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".forge.ForgeWorkshopActivity" android:exported="false" android:label="Atelier de la Forge Royale" android:theme="@style/Theme.KikkoSagaForge" />

        <!-- BOURDON'S ADDITION: D√©claration de la nouvelle PromptEditorActivity -->
        <activity android:name=".prompt.PromptEditorActivity" android:exported="false" android:theme="@style/Theme.KikkoSagaForge" />

        <!-- BOURDON'S FIX: Ajout de windowSoftInputMode pour corriger le comportement du clavier. -->
        <activity
            android:name=".royal_audience.RoyalAudienceActivity"
            android:exported="false"
            android:theme="@style/Theme.KikkoSagaForge"
            android:windowSoftInputMode="adjustResize" />


        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

        <service
            android:name="androidx.work.impl.foreground.SystemForegroundService"
            android:foregroundServiceType="dataSync"
            android:exported="false"
            tools:node="merge" />

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="${applicationId}.androidx-startup"
            android:exported="false"
            tools:node="merge">
            <meta-data
                android:name="androidx.work.WorkManagerInitializer"
                tools:node="remove" />
        </provider>

    </application>

</manifest>

--- END OF FILE app/src/main/AndroidManifest.xml ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/GalleryTheme.kt ---

package be.heyman.android.ai.kikko

class GalleryTheme(function: () -> Unit) {

}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/GalleryTheme.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/GameConstants.kt ---

package be.heyman.android.ai.kikko

/**
 * BOURDON'S NOTE:
 * Un objet singleton pour contenir les constantes de notre jeu.
 * C'est ici que nous d√©finissons les r√®gles qui ne changent pas, comme la liste
 * officielle des decks, pour assurer la coh√©rence √† travers toute l'application.
 */
object GameConstants {

    /**
     * La liste ma√Ætresse, fixe et ordonn√©e, de TOUS les decks possibles dans le jeu.
     * L'ordre est important pour la s√©rialisation/d√©s√©rialisation des catalogues de joueurs.
     */
    val MASTER_DECK_LIST = listOf(
        "Food",
        "Plant",
        "Insect",
        "Bird"
    )

    /**
     * Table de correspondance pour associer un emoji √† chaque deck, pour l'affichage.
     */
    val DECK_EMOJIS = mapOf(
        "Food" to "üçî",
        "Plant" to "üåø",
        "Insect" to "üêû",
        "Bird" to "üê¶"
    )
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/GameConstants.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoApplication.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko

import android.app.Application
import android.util.Log
import androidx.work.Configuration
import be.heyman.android.ai.kikko.clash.helpers.ClashLlmHelper
import be.heyman.android.ai.kikko.clash.services.ClashArenaService
import be.heyman.android.ai.kikko.common.writeLaunchInfo
import be.heyman.android.ai.kikko.forge.ForgeLlmHelper
import be.heyman.android.ai.kikko.forge.ForgeRepository
import be.heyman.android.ai.kikko.persistence.AnalysisResultDao
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import be.heyman.android.ai.kikko.prompt.PromptManager

class KikkoApplication : Application(), Configuration.Provider {

  val cardDao: CardDao by lazy { CardDao(this) }
  val pollenGrainDao: PollenGrainDao by lazy { PollenGrainDao(this) }
  val analysisResultDao: AnalysisResultDao by lazy { AnalysisResultDao(this) }
  val forgeRepository: ForgeRepository by lazy { ForgeRepository(pollenGrainDao, cardDao, analysisResultDao) }
  val clashLlmHelper: ClashLlmHelper by lazy { ClashLlmHelper(this) }
  val forgeLlmHelper: ForgeLlmHelper by lazy { ForgeLlmHelper(this) }
  val clashArenaService: ClashArenaService by lazy { ClashArenaService(this) }


  override fun onCreate() {
    super.onCreate()

    writeLaunchInfo(context = this)

    // BOURDON'S CRITICAL FIX: This line is mandatory and was missing.
    // It loads all prompts into memory when the app starts.
    PromptManager.initialize(this)

    cardDao.hashCode()
    pollenGrainDao.hashCode()
    analysisResultDao.hashCode()
    forgeRepository.hashCode()
    clashLlmHelper.hashCode()
    forgeLlmHelper.hashCode()
    clashArenaService.hashCode()
  }

  override val workManagerConfiguration: Configuration
    get() =
      Configuration.Builder()
        .setMinimumLoggingLevel(Log.DEBUG)
        .build()
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoApplication.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoMainActivity.kt ---

package be.heyman.android.ai.kikko

import android.annotation.SuppressLint
import android.graphics.Rect
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.MotionEvent
import android.widget.LinearLayout
import android.widget.Toast
import android.widget.VideoView
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

/**
 * Activit√© principale de l'application.
 * G√®re le fond vid√©o interactif et la barre de navigation inf√©rieure.
 */
class KikkoMainActivity : AppCompatActivity() {

    // AJOUT : Un TAG pour filtrer nos logs facilement dans Logcat
    private val TAG = "KikkoMainActivity"

    private lateinit var backgroundVideoView: VideoView

    // --- Variables pour la logique du "Grattage de Ventre" ---
    private var scratchJob: Job? = null
    private val bellyHotspot = Rect()
    private var isReactionPlaying = false
    // --------------------------------------------------------

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // NOTE: Le layout R.layout.activity_main_avec_nav est utilis√© ici.
        setContentView(R.layout.activity_deck_selection)
        Log.d(TAG, "onCreate: L'activit√© est cr√©√©e.")

        backgroundVideoView = findViewById(R.id.background_video_view)

        setupBackgroundVideo()
        setupNavigation()
        setupBellyScratchListener() // Initialisation de l'interaction secr√®te
    }

    private fun setupBackgroundVideo() {
        Log.d(TAG, "setupBackgroundVideo: Configuration de la vid√©o principale.")
        playVideo(R.raw.kikko_main, isLooping = true)
    }

    private fun playVideo(videoResId: Int, isLooping: Boolean) {
        val resourceName = resources.getResourceEntryName(videoResId)
        Log.d(TAG, "playVideo: Lancement de la vid√©o '$resourceName' (loop: $isLooping)")
        val videoPath = "android.resource://" + packageName + "/" + videoResId
        val uri = Uri.parse(videoPath)

        backgroundVideoView.setVideoURI(uri)
        backgroundVideoView.setOnPreparedListener { mediaPlayer ->
            mediaPlayer.isLooping = isLooping
            mediaPlayer.setVolume(0f, 0f)
        }
        backgroundVideoView.start()
    }

    private fun setupNavigation() {
        // ... (le code des listeners de navigation reste identique)
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupBellyScratchListener() {
        Log.d(TAG, "setupBellyScratchListener: Le listener de grattage est maintenant actif.")
        backgroundVideoView.setOnTouchListener { view, event ->
            if (isReactionPlaying) {
                Log.v(TAG, "Touch ignor√©: la vid√©o de r√©action est en cours.")
                return@setOnTouchListener false
            }

            val x = event.x.toInt()
            val y = event.y.toInt()

            val viewWidth = view.width
            val viewHeight = view.height
            bellyHotspot.set(
                (viewWidth * 0.25).toInt(),
                (viewHeight * 0.40).toInt(),
                (viewWidth * 0.75).toInt(),
                (viewHeight * 0.80).toInt()
            )

            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    Log.d(TAG, "ACTION_DOWN: Touch√© aux coordonn√©es ($x, $y). Hotspot: $bellyHotspot")
                    if (bellyHotspot.contains(x, y)) {
                        Log.i(TAG, "Touch√© DANS le hotspot. D√©marrage du timer de 4 secondes...")
                        scratchJob = lifecycleScope.launch {
                            delay(4000)
                            Log.i(TAG, "TIMER TERMIN√â: 4 secondes √©coul√©es. D√©clenchement de l'√©v√©nement.")
                            triggerBellyScratchEvent()
                        }
                    } else {
                        Log.d(TAG, "Touch√© HORS du hotspot.")
                    }
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    if (!bellyHotspot.contains(x, y)) {
                        if (scratchJob?.isActive == true) {
                            Log.w(TAG, "ACTION_MOVE: Doigt sorti du hotspot. Annulation du timer.")
                            scratchJob?.cancel()
                        }
                    }
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    if (scratchJob?.isActive == true) {
                        Log.w(TAG, "ACTION_UP/CANCEL: Doigt lev√©. Annulation du timer.")
                        scratchJob?.cancel()
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun triggerBellyScratchEvent() {
        if (isReactionPlaying) return
        isReactionPlaying = true

        runOnUiThread {
            Log.i(TAG, "triggerBellyScratchEvent: √âv√©nement d√©clench√© ! Changement de vid√©o.")
            Toast.makeText(this, "Interaction secr√®te d√©bloqu√©e !", Toast.LENGTH_SHORT).show()

            // NOTE DU BOURDON: J'ai corrig√© le nom de votre vid√©o de "kikko_deck_" √† "kikko_reaction" pour plus de clart√©.
            // Assurez-vous que le fichier R.raw.kikko_reaction existe bien.
            playVideo(R.raw.kikko_deck, isLooping = false)

            backgroundVideoView.setOnCompletionListener {
                Log.i(TAG, "onCompletion: La vid√©o de r√©action est termin√©e. Retour √† la vid√©o principale.")
                isReactionPlaying = false
                playVideo(R.raw.kikko_main, isLooping = true)
                backgroundVideoView.setOnCompletionListener(null)
            }
        }
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume: Reprise de l'activit√©, la vid√©o devrait (re)d√©marrer.")
        if (!isReactionPlaying) {
            backgroundVideoView.start()
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoMainActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/QueenModelAdapter.kt ---

package be.heyman.android.ai.kikko

import android.annotation.SuppressLint
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RadioButton
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import java.io.File

class QueenModelAdapter(
    private var models: List<File>,
    private var selectedModelName: String?,
    private val onModelSelected: (File) -> Unit
) : RecyclerView.Adapter<QueenModelAdapter.ViewHolder>() {

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val radioButton: RadioButton = view.findViewById(R.id.queen_model_radio_button)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_queen_model_selection, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val modelFile = models[position]
        holder.radioButton.text = modelFile.name
        holder.radioButton.isChecked = (modelFile.name == selectedModelName)

        holder.radioButton.setOnClickListener {
            if (modelFile.name != selectedModelName) {
                onModelSelected(modelFile)
                // Le fragment mettra √† jour l'adaptateur avec le nouveau nom s√©lectionn√©
            }
        }
    }

    override fun getItemCount() = models.size

    @SuppressLint("NotifyDataSetChanged")
    fun updateSelection(newModels: List<File>, newSelectedModelName: String?) {
        models = newModels
        selectedModelName = newSelectedModelName
        // On a besoin de redessiner toute la liste pour d√©cocher l'ancien et cocher le nouveau.
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/QueenModelAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/SagaArchiver.kt ---

package be.heyman.android.ai.kikko

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.util.Log
import androidx.core.content.FileProvider
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.persistence.AnalysisResultDao
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

object SagaArchiver {

    private const val TAG = "SagaArchiver"
    private const val IMAGE_MAX_SIZE = 1024

    suspend fun exportSaga(context: Context): Uri? = withContext(Dispatchers.IO) {
        val cardDao = CardDao(context)
        val pollenGrainDao = PollenGrainDao(context)
        val analysisResultDao = AnalysisResultDao(context)

        val allCards = cardDao.getAll()
        if (allCards.isEmpty()) {
            Log.w(TAG, "Aucune carte √† exporter.")
            return@withContext null
        }

        // BOURDON'S NOTE: On r√©cup√®re maintenant TOUTES les donn√©es.
        val allPollenGrains = allCards.mapNotNull { it.id }.mapNotNull { pollenGrainDao.findByForgedCardId(it) }
        val allAnalysisResults = allPollenGrains.flatMap { analysisResultDao.getByPollenGrainIdAndProperty(it.id, "identification") } // Exemple, √† √©tendre si n√©cessaire

        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val exportFileName = "KikkoSaga_Export_$timestamp.kikkoSaga"
        val exportDir = File(context.getExternalFilesDir(null), "exports")
        if (!exportDir.exists()) exportDir.mkdirs()
        val exportFile = File(exportDir, exportFileName)

        try {
            ZipOutputStream(FileOutputStream(exportFile)).use { zos ->
                // S√©rialisation des trois types de donn√©es
                addFileToZip("cards.json", Gson().toJson(allCards).toByteArray(), zos)
                addFileToZip("pollen_grains.json", Gson().toJson(allPollenGrains).toByteArray(), zos)
                addFileToZip("analysis_results.json", Gson().toJson(allAnalysisResults).toByteArray(), zos)

                // BOURDON'S NOTE: Redimensionnement et ajout des images
                allCards.forEach { card ->
                    card.imagePath?.let { path ->
                        val imageFile = File(path)
                        if (imageFile.exists()) {
                            resizeAndAddImageToZip(imageFile, "card_images/${imageFile.name}", zos)
                        }
                    }
                }
            }
            Log.i(TAG, "Exportation compl√®te de la Saga r√©ussie vers : ${exportFile.absolutePath}")
            return@withContext FileProvider.getUriForFile(context, "${context.packageName}.provider", exportFile)

        } catch (e: Exception) {
            Log.e(TAG, "Erreur lors de l'exportation compl√®te de la saga", e)
            exportFile.delete()
            return@withContext null
        }
    }

    suspend fun importSaga(context: Context, uri: Uri): Int = withContext(Dispatchers.IO) {
        val cardDao = CardDao(context)
        val pollenGrainDao = PollenGrainDao(context)
        val analysisResultDao = AnalysisResultDao(context)

        val existingCardNames = cardDao.getAll().map { it.specificName }.toSet()
        var importedCardCount = 0
        Log.d(TAG, "D√©marrage de l'importation relationnelle de la Saga depuis : $uri")

        try {
            context.contentResolver.openInputStream(uri)?.use { inputStream ->
                ZipInputStream(inputStream).use { zis ->
                    // √âtape 1: Extraire toutes les donn√©es en m√©moire
                    val imageBytesMap = mutableMapOf<String, ByteArray>()
                    var cardsJson: String? = null
                    var pollenJson: String? = null
                    var analysisJson: String? = null

                    var entry = zis.nextEntry
                    while (entry != null) {
                        when {
                            entry.name == "cards.json" -> cardsJson = zis.bufferedReader().readText()
                            entry.name == "pollen_grains.json" -> pollenJson = zis.bufferedReader().readText()
                            entry.name == "analysis_results.json" -> analysisJson = zis.bufferedReader().readText()
                            !entry.isDirectory && entry.name.startsWith("card_images/") -> {
                                imageBytesMap[File(entry.name).name] = zis.readBytes()
                            }
                        }
                        entry = zis.nextEntry
                    }

                    if (cardsJson == null || pollenJson == null || analysisJson == null) {
                        Log.e(TAG, "L'archive est invalide ou incompl√®te.")
                        return@withContext -1
                    }

                    // √âtape 2: D√©s√©rialiser et pr√©parer les donn√©es
                    val gson = Gson()
                    val importedCards: List<KnowledgeCard> = gson.fromJson(cardsJson, object : TypeToken<List<KnowledgeCard>>() {}.type)
                    val importedPollen: List<PollenGrain> = gson.fromJson(pollenJson, object : TypeToken<List<PollenGrain>>() {}.type)
                    val importedAnalysis: List<AnalysisResult> = gson.fromJson(analysisJson, object : TypeToken<List<AnalysisResult>>() {}.type)

                    // BOURDON'S NOTE: Logique de greffe relationnelle
                    val oldCardIdToNewId = mutableMapOf<Long, Long>()
                    val oldPollenIdToNewId = mutableMapOf<String, String>()

                    // Insertion des cartes
                    for (card in importedCards) {
                        if (existingCardNames.contains(card.specificName)) continue

                        val newImagePath = card.imagePath?.let {
                            val imageName = File(it).name
                            imageBytesMap[imageName]?.let { bytes -> saveImageToInternalStorage(context, bytes) }
                        }
                        val oldId = card.id
                        val newId = cardDao.insert(card.copy(id = 0, imagePath = newImagePath))
                        oldCardIdToNewId[oldId] = newId
                        importedCardCount++
                    }

                    // Insertion des grains de pollen
                    for (pollen in importedPollen) {
                        val newCardId = oldCardIdToNewId[pollen.forgedCardId] ?: continue // Si la carte a √©t√© saut√©e, on saute le pollen aussi
                        val oldPollenId = pollen.id
                        val newPollenId = UUID.randomUUID().toString()
                        pollenGrainDao.insert(pollen.copy(id = newPollenId, forgedCardId = newCardId))
                        oldPollenIdToNewId[oldPollenId] = newPollenId
                    }

                    // Insertion des r√©sultats d'analyse
                    for (analysis in importedAnalysis) {
                        val newPollenId = oldPollenIdToNewId[analysis.pollenGrainId] ?: continue
                        analysisResultDao.insert(analysis.copy(id = UUID.randomUUID().toString(), pollenGrainId = newPollenId))
                    }
                }
            }
            Log.i(TAG, "Importation de la Saga termin√©e. $importedCardCount cartes (et leurs donn√©es associ√©es) ont √©t√© ajout√©es.")
        } catch (e: Exception) {
            Log.e(TAG, "Erreur durant l'importation de la saga", e)
            return@withContext -1
        }
        return@withContext importedCardCount
    }

    private fun saveImageToInternalStorage(context: Context, imageBytes: ByteArray): String? {
        return try {
            val cardImagesDir = File(context.filesDir, "card_images")
            if (!cardImagesDir.exists()) cardImagesDir.mkdirs()
            val newImageFile = File(cardImagesDir, "card_${UUID.randomUUID()}.png")
            FileOutputStream(newImageFile).use { it.write(imageBytes) }
            newImageFile.absolutePath
        } catch (e: Exception) {
            Log.e(TAG, "Erreur lors de la sauvegarde de l'image import√©e", e)
            null
        }
    }

    private fun addFileToZip(entryName: String, data: ByteArray, zos: ZipOutputStream) {
        val entry = ZipEntry(entryName)
        zos.putNextEntry(entry)
        zos.write(data)
        zos.closeEntry()
    }

    // BOURDON'S NOTE: Nouvelle fonction pour redimensionner les images avant de les zipper.
    private fun resizeAndAddImageToZip(imageFile: File, entryName: String, zos: ZipOutputStream) {
        try {
            val originalBitmap = BitmapFactory.decodeFile(imageFile.absolutePath)
            if (originalBitmap == null) {
                Log.w(TAG, "Impossible de d√©coder le bitmap pour ${imageFile.path}")
                return
            }

            val (newWidth, newHeight) = calculateNewDimensions(originalBitmap.width, originalBitmap.height)

            val resizedBitmap = Bitmap.createScaledBitmap(originalBitmap, newWidth, newHeight, true)
            originalBitmap.recycle()

            ByteArrayOutputStream().use { baos ->
                resizedBitmap.compress(Bitmap.CompressFormat.PNG, 90, baos)
                addFileToZip(entryName, baos.toByteArray(), zos)
            }
            resizedBitmap.recycle()
        } catch (e: Exception) {
            Log.e(TAG, "Erreur lors du redimensionnement de l'image ${imageFile.path}", e)
        }
    }

    private fun calculateNewDimensions(width: Int, height: Int): Pair<Int, Int> {
        if (width <= IMAGE_MAX_SIZE && height <= IMAGE_MAX_SIZE) {
            return Pair(width, height)
        }
        return if (width > height) {
            val newHeight = (height.toFloat() / width.toFloat() * IMAGE_MAX_SIZE).toInt()
            Pair(IMAGE_MAX_SIZE, newHeight)
        } else {
            val newWidth = (width.toFloat() / height.toFloat() * IMAGE_MAX_SIZE).toInt()
            Pair(newWidth, IMAGE_MAX_SIZE)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/SagaArchiver.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartActivity.kt ---

package be.heyman.android.ai.kikko

import android.Manifest
import android.annotation.SuppressLint
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Rect
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.OpenableColumns
import android.util.Log
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import android.widget.Toast
import android.widget.VideoView
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.updateLayoutParams
import androidx.lifecycle.lifecycleScope
import be.heyman.android.ai.kikko.clash.ui.ClashActivity
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.deck.DeckViewerActivity
import be.heyman.android.ai.kikko.forge.ForgeWorkshopActivity
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import be.heyman.android.ai.kikko.pollen.ForgeLiveActivity
import be.heyman.android.ai.kikko.prompt.PromptEditorActivity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import java.util.zip.ZipInputStream

class StartActivity : AppCompatActivity(), ToolsDialogFragment.ToolsDialogListener {

    private val TAG = "KikkoStart"
    private var modelToTest: File? = null

    private lateinit var backgroundVideoView: VideoView
    private var scratchJob: Job? = null
    private val bellyHotspot = Rect()
    private var isReactionPlaying = false

    private lateinit var pollenGrainDao: PollenGrainDao
    private lateinit var cardDao: CardDao
    private lateinit var rawPollenCounter: TextView
    private lateinit var inForgePollenCounter: TextView
    private lateinit var totalHoneyCounter: TextView
    private lateinit var errorPollenCounter: TextView

    // BOURDON'S ADDITION: Le nouveau launcher pour les permissions multiples.
    private val requestMultiplePermissionsLauncher =
        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->
            val allGranted = permissions.entries.all { it.value }
            if (allGranted) {
                Toast.makeText(this, "Toutes les autorisations ont √©t√© accord√©es. La Ruche est pr√™te !", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Certaines autorisations ont √©t√© refus√©es. Certaines fonctionnalit√©s pourraient ne pas √™tre disponibles.", Toast.LENGTH_LONG).show()
            }
        }

    private val importSagaLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        if (uri != null) {
            lifecycleScope.launch {
                val importedCount = SagaArchiver.importSaga(this@StartActivity, uri)
                if (importedCount >= 0) {
                    val message = resources.getQuantityString(R.plurals.import_saga_success, importedCount, importedCount)
                    Toast.makeText(this@StartActivity, message, Toast.LENGTH_LONG).show()
                    updateForgeCounters()
                } else {
                    Toast.makeText(this@StartActivity, R.string.import_saga_failure, Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private val addModelLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        if (uri != null) {
            lifecycleScope.launch {
                Toast.makeText(this@StartActivity, R.string.importing_new_model, Toast.LENGTH_SHORT).show()
                val localPath = copyModelToAppStorage(uri, "imported_models")
                if (localPath != null) {
                    Toast.makeText(this@StartActivity, R.string.import_new_model_success, Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(this@StartActivity, R.string.import_new_model_failure, Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private val importVoskModelLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            lifecycleScope.launch {
                handleVoskModelImport(it)
            }
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_start)
        Log.d(TAG, "onCreate: L'activit√© de d√©marrage est en cours de cr√©ation.")

        // BOURDON'S ADDITION: La v√©rification des permissions est maintenant la premi√®re chose que nous faisons.
        checkAndRequestPermissions()

        pollenGrainDao = PollenGrainDao(this)
        cardDao = CardDao(this)
        Log.d(TAG, "onCreate: DAOs have been initialized.")

        backgroundVideoView = findViewById(R.id.background_video_view)
        setupBellyScratchListener()

        bindViewsAndSetupNavigation()
        setupWindowInsets()
    }

    // BOURDON'S ADDITION: Nouvelle fonction pour g√©rer la logique des permissions.
    private fun checkAndRequestPermissions() {
        val requiredPermissions = mutableListOf(
            Manifest.permission.CAMERA,
            Manifest.permission.RECORD_AUDIO,
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.ACCESS_COARSE_LOCATION
        )

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            requiredPermissions.add(Manifest.permission.BLUETOOTH_SCAN)
            requiredPermissions.add(Manifest.permission.BLUETOOTH_CONNECT)
            requiredPermissions.add(Manifest.permission.BLUETOOTH_ADVERTISE)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            requiredPermissions.add(Manifest.permission.POST_NOTIFICATIONS)
            requiredPermissions.add(Manifest.permission.NEARBY_WIFI_DEVICES)
        }

        val missingPermissions = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (missingPermissions.isNotEmpty()) {
            Log.i(TAG, "Demande des autorisations manquantes: $missingPermissions")
            requestMultiplePermissionsLauncher.launch(missingPermissions.toTypedArray())
        } else {
            Log.i(TAG, "Toutes les autorisations n√©cessaires sont d√©j√† accord√©es.")
        }
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume: L'activit√© est visible, mise √† jour des compteurs.")
        updateForgeCounters()

        if (!isReactionPlaying) {
            setupBackgroundVideo()
        }
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause: Mise en pause de l'activit√©, la vid√©o s'arr√™te.")
        backgroundVideoView.stopPlayback()
    }

    private fun setupWindowInsets() {
        val rootContainer: View = findViewById(R.id.start_root_container)
        val toolsButton: View = findViewById(R.id.start_button_tools)

        ViewCompat.setOnApplyWindowInsetsListener(rootContainer) { _, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())

            toolsButton.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                topMargin = systemBars.top + 16
            }
            WindowInsetsCompat.CONSUMED
        }
    }


    private fun bindViewsAndSetupNavigation() {
        val buttonDecks: View = findViewById(R.id.button_kikko)
        val buttonPollen: View = findViewById(R.id.button_pollen)
        val buttonForge: View = findViewById(R.id.button_forge)
        val buttonClash: View = findViewById(R.id.button_clash)
        val buttonTools: ImageButton = findViewById(R.id.start_button_tools)

        rawPollenCounter = findViewById(R.id.raw_pollen_counter)
        inForgePollenCounter = findViewById(R.id.in_forge_pollen_counter)
        totalHoneyCounter = findViewById(R.id.total_honey_counter)
        errorPollenCounter = findViewById(R.id.error_pollen_counter)
        Log.d(TAG, "bindViewsAndSetupNavigation: Toutes les vues ont √©t√© li√©es.")

        buttonDecks.setOnClickListener {
            startActivity(Intent(this, DeckViewerActivity::class.java))
        }
        buttonPollen.setOnClickListener {
            startActivity(Intent(this, ForgeLiveActivity::class.java))
        }
        buttonForge.setOnClickListener {
            startActivity(Intent(this, ForgeWorkshopActivity::class.java))
        }
        buttonClash.setOnClickListener {
            startActivity(ClashActivity.newIntent(this))
        }
        buttonTools.setOnClickListener {
            ToolsDialogFragment.newInstance().show(supportFragmentManager, ToolsDialogFragment.TAG)
        }
    }

    private fun updateForgeCounters() {
        lifecycleScope.launch {
            val pollenCounts = pollenGrainDao.countByStatus()
            val allCards = cardDao.getAll()
            val totalCardsCount = allCards.size

            withContext(Dispatchers.Main) {
                val forgingCount = (pollenCounts[PollenStatus.IDENTIFYING] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_DESCRIPTION] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_STATS] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_QUIZ] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_TRANSLATION] ?: 0)

                updateCounterView(rawPollenCounter, R.string.counter_label_raw, pollenCounts[PollenStatus.RAW])
                updateCounterView(inForgePollenCounter, R.string.counter_label_forging, forgingCount)
                updateCounterView(totalHoneyCounter, R.string.counter_label_honey, totalCardsCount)
                updateCounterView(errorPollenCounter, R.string.counter_label_error, pollenCounts[PollenStatus.ERROR])
            }
        }
    }

    private fun updateCounterView(textView: TextView, labelResId: Int, count: Int?) {
        val countValue = count ?: 0
        textView.text = getString(labelResId, countValue)
        textView.visibility = View.VISIBLE
    }

    private fun setupBackgroundVideo() {
        Log.d(TAG, "setupBackgroundVideo: Configuration de la vid√©o principale.")
        playVideo(R.raw.kikko_main, isLooping = true)
    }

    private fun playVideo(videoResId: Int, isLooping: Boolean) {
        val resourceName = resources.getResourceEntryName(videoResId)
        Log.d(TAG, "playVideo: Lancement de la vid√©o '$resourceName' (loop: $isLooping)")
        val videoPath = "android.resource://" + packageName + "/" + videoResId
        val uri = Uri.parse(videoPath)

        backgroundVideoView.setVideoURI(uri)
        backgroundVideoView.setOnPreparedListener { mediaPlayer ->
            mediaPlayer.isLooping = isLooping
            mediaPlayer.setVolume(0f, 0f)
            mediaPlayer.start()
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupBellyScratchListener() {
        Log.d(TAG, "setupBellyScratchListener: Le listener de grattage est maintenant actif.")
        backgroundVideoView.setOnTouchListener { view, event ->
            if (isReactionPlaying) {
                return@setOnTouchListener false
            }

            val x = event.x.toInt()
            val y = event.y.toInt()

            val viewWidth = view.width
            val viewHeight = view.height
            bellyHotspot.set(
                (viewWidth * 0.25).toInt(),
                (viewHeight * 0.40).toInt(),
                (viewWidth * 0.75).toInt(),
                (viewHeight * 0.80).toInt()
            )

            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    if (bellyHotspot.contains(x, y)) {
                        scratchJob = lifecycleScope.launch {
                            delay(1000)
                            triggerBellyScratchEvent()
                        }
                    }
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    if (!bellyHotspot.contains(x, y)) {
                        scratchJob?.cancel()
                    }
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    scratchJob?.cancel()
                    true
                }
                else -> false
            }
        }
    }

    private fun triggerBellyScratchEvent() {
        if (isReactionPlaying) return
        isReactionPlaying = true

        runOnUiThread {
            Log.i(TAG, "triggerBellyScratchEvent: √âv√©nement d√©clench√© ! Changement de vid√©o.")
            Toast.makeText(this, R.string.secret_interaction_unlocked, Toast.LENGTH_SHORT).show()

            playVideo(R.raw.kikko_deck, isLooping = false)

            backgroundVideoView.setOnCompletionListener {
                Log.i(TAG, "onCompletion: La vid√©o de r√©action est termin√©e. Retour √† la vid√©o principale.")
                isReactionPlaying = false
                playVideo(R.raw.kikko_main, isLooping = true)
                backgroundVideoView.setOnCompletionListener(null)
            }
        }
    }

    private suspend fun copyModelToAppStorage(sourceUri: Uri, directory: String): String? = withContext(Dispatchers.IO) {
        val tag = "ModelStorage"
        try {
            val fileName = contentResolver.query(sourceUri, null, null, null, null)?.use { cursor ->
                val nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)
                cursor.moveToFirst()
                cursor.getString(nameIndex)
            } ?: "imported_file_${System.currentTimeMillis()}"
            val destDir = File(filesDir, directory)
            if (!destDir.exists()) destDir.mkdirs()
            val destFile = File(destDir, fileName)
            contentResolver.openInputStream(sourceUri)?.use { inputStream ->
                FileOutputStream(destFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
            }
            destFile.absolutePath
        } catch (e: Exception) {
            Log.e(tag, "√âchec de la copie du fichier", e)
            null
        }
    }

    override fun onExportSagaRequested() {
        lifecycleScope.launch {
            val sagaUri = SagaArchiver.exportSaga(this@StartActivity)
            if (sagaUri != null) {
                val shareIntent = Intent().apply {
                    action = Intent.ACTION_SEND
                    putExtra(Intent.EXTRA_STREAM, sagaUri)
                    type = "application/zip"
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }
                startActivity(Intent.createChooser(shareIntent, getString(R.string.share_saga_title)))
            } else {
                Toast.makeText(this@StartActivity, R.string.export_saga_failure, Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onImportSagaRequested() {
        importSagaLauncher.launch("*/*")
    }

    override fun onDeleteModelRequested(modelFile: File) {
        if (modelFile.exists() && modelFile.delete()) {
            Toast.makeText(this, getString(R.string.model_deleted_success, modelFile.name), Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, getString(R.string.model_deleted_failure, modelFile.name), Toast.LENGTH_SHORT).show()
        }
    }

    override fun onAddModelRequested() {
        addModelLauncher.launch("*/*")
    }

    override fun onManagePromptsRequested() {
        startActivity(Intent(this, PromptEditorActivity::class.java))
    }

    private suspend fun handleVoskModelImport(uri: Uri) = withContext(Dispatchers.IO) {
        val modelName = getVoskModelNameFromZip(uri)
        if (modelName == null) {
            withContext(Dispatchers.Main) { Toast.makeText(this@StartActivity, R.string.vosk_model_import_invalid_zip, Toast.LENGTH_LONG).show() }
            return@withContext
        }
        val modelDir = File(File(filesDir, "vosk-models"), modelName)
        try {
            if (modelDir.exists()) modelDir.deleteRecursively()
            modelDir.mkdirs()
            contentResolver.openInputStream(uri)?.use { inputStream ->
                unzip(inputStream, modelDir, modelName)
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@StartActivity, getString(R.string.vosk_model_import_success, modelName), Toast.LENGTH_LONG).show()
                }
            } ?: throw Exception("Impossible d'ouvrir le flux de donn√©es pour l'URI.")
        } catch (e: Exception) {
            Log.e(TAG, "√âchec de l'importation du mod√®le Vosk", e)
            withContext(Dispatchers.Main) {
                Toast.makeText(this@StartActivity, getString(R.string.vosk_model_import_failure, e.message), Toast.LENGTH_LONG).show()
            }
            if (modelDir.exists()) modelDir.deleteRecursively()
        }
    }

    @Throws(Exception::class)
    private fun getVoskModelNameFromZip(uri: Uri): String? {
        contentResolver.openInputStream(uri)?.use { inputStream ->
            ZipInputStream(inputStream).use { zis ->
                return zis.nextEntry?.name?.substringBefore('/')
            }
        }
        return null
    }

    @Throws(Exception::class)
    private fun unzip(inputStream: InputStream, destination: File, rootFolder: String) {
        ZipInputStream(inputStream).use { zis ->
            var zipEntry = zis.nextEntry
            while (zipEntry != null) {
                if (zipEntry.name.startsWith("$rootFolder/")) {
                    val newName = zipEntry.name.substringAfter("$rootFolder/")
                    if (newName.isNotEmpty()) {
                        val newFile = File(destination, newName)
                        if (!newFile.canonicalPath.startsWith(destination.canonicalPath + File.separator)) {
                            throw SecurityException("Zip Slip Attack d√©tect√©e : ${zipEntry.name}")
                        }
                        if (zipEntry.isDirectory) {
                            if (!newFile.isDirectory && !newFile.mkdirs()) {
                                throw java.io.IOException("√âchec de la cr√©ation du r√©pertoire ${newFile}")
                            }
                        } else {
                            val parent = newFile.parentFile
                            if (parent != null && !parent.isDirectory && !parent.mkdirs()) {
                                throw java.io.IOException("√âchec de la cr√©ation du r√©pertoire ${parent}")
                            }
                            FileOutputStream(newFile).use { fos ->
                                val buffer = ByteArray(1024)
                                var len: Int
                                while (zis.read(buffer).also { len = it } > 0) {
                                    fos.write(buffer, 0, len)
                                }
                            }
                        }
                    }
                }
                zipEntry = zis.nextEntry
            }
        }
    }

    override fun onNukeDatabaseRequested() {
        lifecycleScope.launch {
            Log.w("BOURDON_NUKE", "Demande de purge de la base de donn√©es re√ßue.")
            withContext(Dispatchers.IO) {
                pollenGrainDao.nuke()
                cardDao.nuke()
            }
            withContext(Dispatchers.Main) {
                Toast.makeText(this@StartActivity, R.string.hive_memory_cleared, Toast.LENGTH_LONG).show()
                updateForgeCounters()
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartViewModel.kt ---

package be.heyman.android.ai.kikko

import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import javax.inject.Inject

data class StartUiState(
    val isLoading: Boolean = false,
    val statusMessage: String? = null,
    val errorMessage: String? = null
)


class StartViewModel @Inject constructor() : ViewModel() {

    private val _uiState = MutableStateFlow(StartUiState())
    val uiState = _uiState.asStateFlow()

    fun clearError() {
        _uiState.update { it.copy(errorMessage = null) }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/SttVoskService.kt ---

package be.heyman.android.ai.kikko

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import be.heyman.android.ai.kikko.data.Model
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.vosk.Recognizer
import org.vosk.android.RecognitionListener
import org.vosk.android.SpeechService
import java.io.File
import java.io.IOException

enum class VoskStatus {
    IDLE,
    LOADING,
    READY,
    LISTENING,
    FINAL_RESULT,
    ERROR
}

data class VoskResult(
    val status: VoskStatus,
    val text: String = "",
    val isPartial: Boolean = false
)

object SttVoskService {
    private const val TAG = "SttVoskService"

    private var voskModel: org.vosk.Model? = null
    private var speechService: SpeechService? = null
    private var currentModelPath: String? = null

    private val _voskResult = MutableLiveData<VoskResult>()
    val voskResult: LiveData<VoskResult> = _voskResult

    private val voskTranscript = StringBuilder()

    fun isModelLoaded(): Boolean {
        return voskModel != null
    }

    fun loadModel(modelToLoad: Model, baseDir: File, onFinished: (Boolean) -> Unit) {
        val modelPath = File(baseDir, modelToLoad.name).absolutePath
        if (currentModelPath == modelPath && voskModel != null) {
            onFinished(true)
            return
        }

        _voskResult.postValue(VoskResult(VoskStatus.LOADING, "Chargement du mod√®le ${modelToLoad.name}..."))

        CoroutineScope(Dispatchers.IO).launch {
            try {
                voskModel?.close()
                voskModel = org.vosk.Model(modelPath)
                currentModelPath = modelPath
                withContext(Dispatchers.Main) {
                    _voskResult.postValue(VoskResult(VoskStatus.READY, "Mod√®le ${modelToLoad.name} pr√™t."))
                    onFinished(true)
                }
            } catch (e: IOException) {
                withContext(Dispatchers.Main) {
                    _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Erreur chargement mod√®le: ${e.message}"))
                    onFinished(false)
                }
            }
        }
    }

    fun startListening() {
        if (speechService != null) return
        val localModel = voskModel ?: run {
            _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Aucun mod√®le Vosk n'est charg√©."))
            return
        }

        voskTranscript.clear()
        _voskResult.postValue(VoskResult(VoskStatus.LISTENING, "√âcoute..."))

        try {
            val recognizer = Recognizer(localModel, 16000.0f)
            speechService = SpeechService(recognizer, 16000.0f)
            speechService?.startListening(recognitionListener)
        } catch (e: IOException) {
            _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Erreur au d√©marrage: ${e.message}"))
        }
    }

    fun stopListening() {
        speechService?.stop()
        speechService = null
        if (_voskResult.value?.status == VoskStatus.LISTENING) {
            _voskResult.postValue(VoskResult(VoskStatus.IDLE, voskTranscript.toString()))
        }
    }

    fun reset() {
        stopListening()
        voskTranscript.clear()
        _voskResult.postValue(VoskResult(VoskStatus.IDLE, ""))
        Log.d(TAG, "Service Vosk r√©initialis√©.")
    }

    fun shutdown() {
        speechService?.shutdown()
        voskModel?.close()
        speechService = null
        voskModel = null
        currentModelPath = null
    }

    private val recognitionListener = object : RecognitionListener {
        override fun onResult(hypothesis: String?) {
            try {
                val resultText = hypothesis?.let { JSONObject(it).getString("text") } ?: ""
                if (resultText.isNotBlank()) {
                    voskTranscript.append(resultText).append(" ")
                    _voskResult.postValue(VoskResult(VoskStatus.FINAL_RESULT, voskTranscript.toString().trim()))
                }
            } catch (e: Exception) {
                // Ignore parsing errors
            }
        }

        override fun onPartialResult(hypothesis: String?) {
            try {
                val partialText = hypothesis?.let { JSONObject(it).getString("partial") } ?: ""
                _voskResult.postValue(VoskResult(VoskStatus.LISTENING, voskTranscript.toString() + partialText, isPartial = true))
            } catch (e: Exception) {
                // Ignore parsing errors
            }
        }

        override fun onFinalResult(hypothesis: String?) {
            onResult(hypothesis)
            onListeningStopped()
        }

        override fun onError(e: Exception?) {
            _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Erreur: ${e?.message}"))
            onListeningStopped()
        }

        override fun onTimeout() {
            onListeningStopped()
        }

        private fun onListeningStopped(){
            if(speechService != null){
                stopListening()
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/SttVoskService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsDialogFragment.kt ---

package be.heyman.android.ai.kikko

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.RadioGroup
import android.widget.TextView
import android.widget.Toast
import androidx.fragment.app.DialogFragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.data.ModelCatalogue
import be.heyman.android.ai.kikko.prompt.PromptEditorActivity
import be.heyman.android.ai.kikko.ui.adapters.LocalModelAdapter
import be.heyman.android.ai.kikko.worker.DownloadManagerKikko
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.switchmaterial.SwitchMaterial
import java.io.File

class ToolsDialogFragment : DialogFragment() {

    interface ToolsDialogListener {
        fun onExportSagaRequested()
        fun onImportSagaRequested()
        fun onAddModelRequested()
        fun onDeleteModelRequested(modelFile: File)
        fun onNukeDatabaseRequested()
        // BOURDON'S ADDITION: Nouvelle m√©thode pour lancer l'√©diteur de prompts.
        fun onManagePromptsRequested()
    }

    private var listener: ToolsDialogListener? = null
    private lateinit var queenManagementAdapter: LocalModelAdapter
    private lateinit var queenSelectorAdapter: QueenModelAdapter
    private val TAG = "ToolsDialog"

    private lateinit var prefs: SharedPreferences
    private lateinit var requireChargingSwitch: SwitchMaterial
    private lateinit var requireIdleSwitch: SwitchMaterial
    private lateinit var nukeDbButton: Button
    private lateinit var queenAcceleratorRadioGroup: RadioGroup
    private lateinit var downloadModelsButton: Button
    private lateinit var downloadDecksButton: Button
    // BOURDON'S ADDITION: R√©f√©rence pour le nouveau bouton.
    private lateinit var managePromptsButton: Button


    companion object {
        const val TAG = "ToolsDialog"
        const val PREFS_NAME = "ForgeSettings"
        const val KEY_REQUIRE_CHARGING = "KEY_FORGE_WHILE_CHARGING"
        const val KEY_REQUIRE_IDLE = "KEY_FORGE_WHEN_IDLE"
        const val KEY_SELECTED_FORGE_QUEEN = "KEY_SELECTED_FORGE_QUEEN"
        const val KEY_SELECTED_FORGE_QUEEN_ACCELERATOR = "KEY_SELECTED_FORGE_QUEEN_ACCELERATOR"


        fun newInstance(): ToolsDialogFragment {
            return ToolsDialogFragment()
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = context as? ToolsDialogListener
            ?: throw ClassCastException("$context must implement ToolsDialogListener")
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_tools, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle(R.string.tools_dialog_title)

        prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        bindViews(view)
        setupForgeQueenSelector(view)
        setupForgeQueenAccelerator()
        setupQueenModelManagement(view)
        setupSagaButtons(view)
        setupForgeSettings()
        setupNukeButton()
        // BOURDON'S ADDITION: Appel √† la nouvelle m√©thode de configuration.
        setupPromptManagementButton()
    }

    private fun bindViews(view: View) {
        requireChargingSwitch = view.findViewById(R.id.tools_switch_require_charging)
        requireIdleSwitch = view.findViewById(R.id.tools_switch_require_idle)
        nukeDbButton = view.findViewById(R.id.tools_button_nuke_db)
        queenAcceleratorRadioGroup = view.findViewById(R.id.tools_radiogroup_queen_accelerator)
        downloadModelsButton = view.findViewById(R.id.tools_button_download_models)
        downloadDecksButton = view.findViewById(R.id.tools_button_download_decks)
        // BOURDON'S ADDITION: Liaison du nouveau bouton.
        managePromptsButton = view.findViewById(R.id.tools_button_manage_prompts)
    }

    private fun setupForgeQueenSelector(view: View) {
        val queenSelectorRecyclerView: RecyclerView = view.findViewById(R.id.tools_recyclerview_queen_selector)
        val selectedQueenName = prefs.getString(KEY_SELECTED_FORGE_QUEEN, null)

        queenSelectorAdapter = QueenModelAdapter(
            mutableListOf(),
            selectedQueenName
        ) { selectedFile ->
            prefs.edit().putString(KEY_SELECTED_FORGE_QUEEN, selectedFile.name).apply()
            Toast.makeText(context, getString(R.string.queen_selected_toast, selectedFile.name), Toast.LENGTH_SHORT).show()
            loadForgeQueenModels()
        }

        queenSelectorRecyclerView.layoutManager = LinearLayoutManager(context)
        queenSelectorRecyclerView.adapter = queenSelectorAdapter
        loadForgeQueenModels()
    }

    private fun setupForgeQueenAccelerator() {
        val savedAccelerator = prefs.getString(KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")
        if (savedAccelerator == "CPU") {
            queenAcceleratorRadioGroup.check(R.id.tools_radio_cpu)
        } else {
            queenAcceleratorRadioGroup.check(R.id.tools_radio_gpu)
        }

        queenAcceleratorRadioGroup.setOnCheckedChangeListener { _, checkedId ->
            val selectedAccelerator = if (checkedId == R.id.tools_radio_cpu) "CPU" else "GPU"
            prefs.edit().putString(KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, selectedAccelerator).apply()
            Toast.makeText(context, getString(R.string.accelerator_set_toast, selectedAccelerator), Toast.LENGTH_SHORT).show()
        }
    }

    private fun setupQueenModelManagement(view: View) {
        val queenRecyclerView: RecyclerView = view.findViewById(R.id.tools_recyclerview_models)
        val addModelButton: Button = view.findViewById(R.id.tools_button_add_model)

        queenManagementAdapter = LocalModelAdapter(mutableListOf()) { modelFile ->
            listener?.onDeleteModelRequested(modelFile)
            loadQueenManagementModels()
        }
        queenRecyclerView.layoutManager = LinearLayoutManager(context)
        queenRecyclerView.adapter = queenManagementAdapter
        loadQueenManagementModels()
        addModelButton.setOnClickListener { listener?.onAddModelRequested() }

        downloadModelsButton.setOnClickListener {
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://www.kikko.be/model"))
            startActivity(intent)
            dismiss()
        }
    }

    private fun setupSagaButtons(view: View) {
        val exportSagaButton: Button = view.findViewById(R.id.tools_button_export_saga)
        val importSagaButton: Button = view.findViewById(R.id.tools_button_import_saga)
        importSagaButton.setOnClickListener { listener?.onImportSagaRequested(); dismiss() }
        exportSagaButton.setOnClickListener { listener?.onExportSagaRequested(); dismiss() }

        // Ajout du listener pour le nouveau bouton de t√©l√©chargement de decks
        downloadDecksButton.setOnClickListener {
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://www.kikko.be/sagas"))
            startActivity(intent)
            dismiss()
        }
    }

    // BOURDON'S ADDITION: Nouvelle m√©thode pour configurer le bouton de gestion des prompts.
    private fun setupPromptManagementButton() {
        managePromptsButton.setOnClickListener {
            listener?.onManagePromptsRequested()
            dismiss()
        }
    }

    private fun setupForgeSettings() {
        requireChargingSwitch.isChecked = prefs.getBoolean(KEY_REQUIRE_CHARGING, false)
        requireIdleSwitch.isChecked = prefs.getBoolean(KEY_REQUIRE_IDLE, false)

        requireChargingSwitch.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean(KEY_REQUIRE_CHARGING, isChecked).apply()
            val status = if(isChecked) getString(R.string.generic_enabled) else getString(R.string.generic_disabled)
            Toast.makeText(context, getString(R.string.forge_charging_toast, status), Toast.LENGTH_SHORT).show()
        }
        requireIdleSwitch.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean(KEY_REQUIRE_IDLE, isChecked).apply()
            val status = if(isChecked) getString(R.string.generic_enabled) else getString(R.string.generic_disabled)
            Toast.makeText(context, getString(R.string.forge_idle_toast, status), Toast.LENGTH_SHORT).show()
        }
    }

    private fun setupNukeButton() {
        nukeDbButton.setOnClickListener {
            MaterialAlertDialogBuilder(requireContext())
                .setTitle(R.string.dialog_confirmation_required_title)
                .setMessage(R.string.dialog_nuke_db_message)
                .setNegativeButton(R.string.dialog_cancel, null)
                .setPositiveButton(R.string.dialog_confirm_nuke) { _, _ ->
                    listener?.onNukeDatabaseRequested()
                    dismiss()
                }
                .show()
        }
    }

    private fun loadForgeQueenModels() {
        val modelsDir = File(requireContext().filesDir, "imported_models")
        val modelFiles = if (modelsDir.exists() && modelsDir.isDirectory) {
            modelsDir.listFiles { _, name -> name.endsWith(".task") }?.toList()?.sortedBy { it.name } ?: emptyList()
        } else {
            emptyList()
        }
        val selectedQueenName = prefs.getString(KEY_SELECTED_FORGE_QUEEN, null)
        queenSelectorAdapter.updateSelection(modelFiles, selectedQueenName)
    }

    private fun loadQueenManagementModels() {
        val modelsDir = File(requireContext().filesDir, "imported_models")
        if (modelsDir.exists() && modelsDir.isDirectory) {
            val modelFiles = modelsDir.listFiles { _, name -> name.endsWith(".task") }?.toList() ?: emptyList()
            queenManagementAdapter.updateModels(modelFiles.sortedBy { it.name })
        } else {
            queenManagementAdapter.updateModels(emptyList())
        }
        loadForgeQueenModels()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsViewModel.kt ---

package be.heyman.android.ai.kikko


import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.data.Model
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ToolsUiState(
    val isLoading: Boolean = false,
    val models: List<Model> = emptyList(),
    val errorMessage: String? = null
)


class ToolsViewModel @Inject constructor(
    // private val modelRepository: ModelRepository // Sera inject√© plus tard
) : ViewModel() {

    private val _uiState = MutableStateFlow(ToolsUiState())
    val uiState = _uiState.asStateFlow()

    fun loadModels() = viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true) }
        // TODO: Remplacer par un v√©ritable appel au repository pour lister les mod√®les disponibles et locaux
        val dummyModels = listOf(
            Model(name = "gemma-3n-E2B-it-int4.task", url = "...", downloadFileName = "gemma-3n-E2B-it-int4.task", sizeInBytes = 1_200_000_000, llmSupportImage = true),
            Model(name = "gemma-3n-E4B-it-int4.task", url = "...", downloadFileName = "gemma-3n-E4B-it-int4.task", sizeInBytes = 2_500_000_000, llmSupportImage = true)
        )
        _uiState.update { it.copy(isLoading = false, models = dummyModels) }
    }

    fun downloadModel(model: Model) = viewModelScope.launch {
        // TODO: Impl√©menter la logique de t√©l√©chargement du mod√®le
        _uiState.update { it.copy(errorMessage = "La fonctionnalit√© de t√©l√©chargement n'est pas encore impl√©ment√©e.") }
    }

    fun deleteModel(model: Model) = viewModelScope.launch {
        // TODO: Impl√©menter la logique de suppression du mod√®le
        _uiState.update { it.copy(errorMessage = "La fonctionnalit√© de suppression n'est pas encore impl√©ment√©e.") }
    }

    fun clearError() {
        _uiState.update { it.copy(errorMessage = null) }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/TtsService.kt ---

package be.heyman.android.ai.kikko

import android.content.Context
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.Locale
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue

object TtsService : TextToSpeech.OnInitListener {

    private const val TAG = "TtsService"

    private var tts: TextToSpeech? = null
    private var isTtsInitialized = false

    private val _isSpeaking = MutableStateFlow(false)
    val isSpeaking = _isSpeaking.asStateFlow()

    private data class SpeakRequest(val utteranceId: String, val text: String, val locale: Locale, val onDone: (() -> Unit)?)
    private val directSpeakQueue = ConcurrentLinkedQueue<SpeakRequest>()

    fun initialize(context: Context) {
        if (tts == null) {
            Log.d(TAG, "Initialisation du moteur TTS...")
            tts = TextToSpeech(context.applicationContext, this)
            tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) {
                    _isSpeaking.value = true
                    Log.d(TAG, "TTS a commenc√© √† parler: $utteranceId")
                }

                override fun onDone(utteranceId: String?) {
                    Log.d(TAG, "TTS a fini de parler: $utteranceId")
                    _isSpeaking.value = false
                    val completedRequest = directSpeakQueue.poll()
                    completedRequest?.onDone?.invoke()
                    processDirectSpeakQueue()
                }

                override fun onError(utteranceId: String?) {
                    Log.e(TAG, "Erreur TTS pour: $utteranceId")
                    _isSpeaking.value = false
                    directSpeakQueue.poll()
                    processDirectSpeakQueue()
                }
            })
        }
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isTtsInitialized = true
            Log.d(TAG, "Moteur TTS initialis√© avec succ√®s.")
            tts?.language = Locale.getDefault()
            processDirectSpeakQueue()
        } else {
            isTtsInitialized = false
            Log.e(TAG, "√âchec de l'initialisation du moteur TTS. Statut: $status")
        }
    }

    fun speak(text: String, locale: Locale, onDone: (() -> Unit)? = null) {
        // BOURDON'S CRITICAL FIX: Nettoyage du texte avant de le parler.
        val cleanedText = text.replace("*", "")

        val utteranceId = "KikkoDirectSpeak-${UUID.randomUUID()}"
        val request = SpeakRequest(utteranceId, cleanedText, locale, onDone)
        directSpeakQueue.add(request)

        if (isTtsInitialized) {
            processDirectSpeakQueue()
        }
    }

    private fun processDirectSpeakQueue() {
        if (_isSpeaking.value || !isTtsInitialized || directSpeakQueue.isEmpty()) {
            return
        }

        val request = directSpeakQueue.peek() ?: return
        tts?.language = request.locale
        tts?.speak(request.text, TextToSpeech.QUEUE_ADD, null, request.utteranceId)
    }

    fun stopAndClearQueue() {
        tts?.stop()
        directSpeakQueue.clear()
        _isSpeaking.value = false
        Log.d(TAG, "TTS arr√™t√© et file d'attente vid√©e.")
    }

    fun shutdown() {
        stopAndClearQueue()
        tts?.shutdown()
        tts = null
        isTtsInitialized = false
        Log.d(TAG, "Moteur TTS lib√©r√©.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/TtsService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/VoskModelAdapter.kt ---

package be.heyman.android.ai.kikko

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import java.io.File

/**
 * Adaptateur pour afficher une liste de mod√®les Vosk (reconnaissance vocale).
 * D√©plac√© depuis le package `debug` car il est utilis√© par `ToolsDialogFragment`
 * pour g√©rer les mod√®les STT.
 *
 * @param models La liste mutable des fichiers de mod√®le Vosk √† afficher.
 * @param onTestModel Callback lorsqu'un mod√®le est test√©.
 * @param onDeleteModel Callback lorsqu'un mod√®le est supprim√©.
 */
class VoskModelAdapter(
    private var models: MutableList<File>,
    private val onTestModel: (File) -> Unit,
    private val onDeleteModel: (File) -> Unit
) : RecyclerView.Adapter<VoskModelAdapter.ModelViewHolder>() {

    private var isListening = false

    class ModelViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val modelName: TextView = view.findViewById(R.id.vosk_model_name)
        val testButton: ImageButton = view.findViewById(R.id.button_test_vosk_model)
        val deleteButton: ImageButton = view.findViewById(R.id.button_delete_vosk_model)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ModelViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_vosk_model, parent, false)
        return ModelViewHolder(view)
    }

    override fun onBindViewHolder(holder: ModelViewHolder, position: Int) {
        val modelFile = models[position]
        holder.modelName.text = modelFile.name

        // BOURDON'S FIX: Change l'ic√¥ne en fonction de l'√©tat d'√©coute.
        if (isListening) {
            holder.testButton.setImageResource(android.R.drawable.ic_media_pause) // ou une ic√¥ne "stop"
        } else {
            holder.testButton.setImageResource(android.R.drawable.ic_media_play)
        }

        holder.testButton.setOnClickListener { onTestModel(modelFile) }
        holder.deleteButton.setOnClickListener { onDeleteModel(modelFile) }
    }

    override fun getItemCount() = models.size

    fun updateModels(newModels: List<File>) {
        models.clear()
        models.addAll(newModels)
        notifyDataSetChanged()
    }

    // BOURDON'S FIX: M√©thode pour que le fragment puisse informer l'adaptateur de l'√©tat.
    fun setIsListening(listening: Boolean) {
        isListening = listening
        notifyDataSetChanged() // Redessine toute la liste pour mettre √† jour les ic√¥nes.
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/VoskModelAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashP2pModels.kt ---

package be.heyman.android.ai.kikko.clash.data

import android.graphics.Color

/**
 * BOURDON'S NOTE:
 * Ce fichier contient les data classes utilis√©es sp√©cifiquement pour la phase de D√âCOUVERTE P2P.
 * Elles sont une copie de celles du prototype et servent de "carte de visite" l√©g√®re
 * qu'un joueur envoie pour se pr√©senter sur le r√©seau. Elles sont distinctes de l'entit√©
 * principale `KnowledgeCard` qui est bien plus riche.
 */

/**
 * Repr√©sente un seul deck de cartes dans le catalogue partiel d'un joueur pour la d√©couverte.
 */
data class Deck(
    val name: String,
    val cardCount: Int
)

/**
 * Repr√©sente le catalogue partiel d'un joueur, encod√© dans l'endpointName de Nearby.
 */
data class PlayerCatalogue(
    val playerName: String,
    val decks: List<Deck>,
    val latitude: Double? = null,
    val longitude: Double? = null,
    val wins: Int = 0,
    val losses: Int = 0,
    var color: Int = Color.WHITE
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashP2pModels.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashSettings.kt ---

package be.heyman.android.ai.kikko.clash.data

/**
 * Data class pour contenir tous les param√®tres de configuration du Clash.
 */
data class ClashSettings(
    val queenModelName: String,
    val brain: String = "CPU",
    val temperature: Float = 0.44f,
    val isTtsEnabled: Boolean = true,
    val showSetupOnLaunch: Boolean = true
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashSettings.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashState.kt ---

package be.heyman.android.ai.kikko.clash.data

import be.heyman.android.ai.kikko.model.KnowledgeCard

/**
 * Repr√©sente l'√©tat complet d'un seul duel dans l'Ar√®ne.
 * Contient les cartes combattantes, la question, le statut, les raisonnements et le verdict.
 */
data class ClashState(
    val deckName: String,
    val player1Card: KnowledgeCard,
    val player2Card: KnowledgeCard,
    var status: ClashStatus = ClashStatus.PENDING,
    var question: String? = null,
    var winner: String = "tie",
    var rawReasoning: String = "",
    var streamingReasoning: String? = "",
    var translatedReasoning: String? = "",
    // BOURDON'S REFACTOR: Ajout du champ pour le script TTS g√©n√©r√© par l'IA.
    var ttsScript: String? = "",
    var errorMessage: String? = "",
    // BOURDON'S FIX V6: Ajout du drapeau pour le contr√¥le du TTS.
    var ttsHasBeenPlayed: Boolean = false,
    // BOURDON'S FIX V7: Ajout du drapeau pour le TTS de la question.
    var ttsQuestionHasBeenPlayed: Boolean = false
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashState.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashStatus.kt ---

package be.heyman.android.ai.kikko.clash.data

/**
 * Repr√©sente les diff√©rents √©tats possibles pour un seul duel dans le tournoi.
 *
 * - PENDING: Le duel est en attente, l'inf√©rence n'a pas encore √©t√© lanc√©e.
 * - INFERRING: Le Juge IA (LLM) est en train de d√©lib√©rer sur le verdict.
 * - TRANSLATING: Le raisonnement brut est re√ßu, la traduction est en cours.
 * - COMPLETED: Le verdict et le raisonnement traduit sont finaux et pr√™ts √† √™tre affich√©s.
 * - ERROR: Une erreur est survenue durant l'inf√©rence ou la traduction.
 */
enum class ClashStatus {
    PENDING,
    INFERRING,
    TRANSLATING,
    COMPLETED,
    ERROR
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashStatus.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/P2pPayload.kt ---

package be.heyman.android.ai.kikko.clash.data

import be.heyman.android.ai.kikko.clash.helpers.LocalizedQuestion
import be.heyman.android.ai.kikko.model.KnowledgeCard

sealed class P2pPayload {
    // √âchang√© par les deux joueurs pendant la s√©lection.
    // BOURDON'S FIX : Ajout de l'ID du payload de l'image. La carte sera "all√©g√©e" (sans imagePath).
    data class CardSelectionPayload(
        val deckName: String,
        val selectedCard: KnowledgeCard,
        val imagePayloadId: Long? = null
    ) : P2pPayload()

    // Envoy√© par l'H√¥te pour d√©marrer le Clash sur les deux appareils.
    data class StartClashPayload(val command: String = "START_CLASH") : P2pPayload()

    // Envoy√© par l'H√¥te √† l'Invit√© pour synchroniser la question du duel.
    data class QuestionPayload(val deckName: String, val question: LocalizedQuestion) : P2pPayload()

    // Envoy√© par l'H√¥te √† l'Invit√© avec le r√©sultat de chaque duel.
    data class DuelResultPayload(val deckName: String, val winner: String, val reasoning: String, val ttsScript: String) : P2pPayload()

    // Envoy√© par l'H√¥te pour passer au duel suivant.
    data class NextDuelPayload(val command: String = "NEXT_DUEL") : P2pPayload()
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/P2pPayload.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashLlmHelper.kt ---

// app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashLlmHelper.kt

package be.heyman.android.ai.kikko.clash.helpers

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.data.Accelerator
import be.heyman.android.ai.kikko.data.Model
import com.google.mediapipe.tasks.genai.llminference.GraphOptions
import com.google.mediapipe.tasks.genai.llminference.LlmInference
import com.google.mediapipe.tasks.genai.llminference.LlmInferenceSession
import javax.inject.Inject

private const val TAG = "ClashLlmHelper"

typealias ResultListener = (partialResult: String, done: Boolean) -> Unit

class ClashLlmHelper @Inject constructor(
    val context: Context
) {
    private var llmInference: LlmInference? = null
    private var session: LlmInferenceSession? = null
    private var currentSessionTemperature: Float? = null

    fun initialize(model: Model, accelerator: String): String? {
        Log.d(TAG, "INITIALISATION ...")
        cleanUp()
        try {
            Log.d(TAG, "INITIALISATION BRUTE DU MOTEUR...")
            val optionsBuilder = LlmInference.LlmInferenceOptions.builder()
                .setModelPath(model.url)
                .setMaxTokens(4096)
                .setPreferredBackend(
                    if (accelerator == Accelerator.GPU.label) LlmInference.Backend.GPU
                    else LlmInference.Backend.CPU
                )
            val options = optionsBuilder.build()
            llmInference = LlmInference.createFromOptions(context, options)
            Log.d(TAG, "MOTEUR CR√â√â AVEC SUCC√àS.")

            // On cr√©e la session initiale IMM√âDIATEMENT.
            session = createNewSession(0.44f) // Temp√©rature par d√©faut
            if (session == null) {
                throw IllegalStateException("√âchec de la cr√©ation de la session LlmInference.")
            }
            Log.d(TAG, "SESSION CR√â√âE AVEC SUCC√àS.")
            return null // Succ√®s
        } catch (e: Exception) {
            val errorMsg = e.message ?: "Erreur inconnue pendant l'initialisation"
            Log.e(TAG, "L'initialisation du ClashLlmHelper a √©chou√©: $errorMsg", e)
            cleanUp()
            return errorMsg
        }
    }

    private fun createNewSession(temperature: Float): LlmInferenceSession? {
        val inferenceEngine = llmInference ?: return null

        return try {
            Log.d(TAG, "Cr√©ation d'une nouvelle session avec temp√©rature: $temperature")
            currentSessionTemperature = temperature

            val sessionOptions = LlmInferenceSession.LlmInferenceSessionOptions.builder()
                .setTemperature(temperature)
                .setTopK(40)
                .setGraphOptions(
                    GraphOptions.builder()
                        .setEnableVisionModality(false)
                        .build()
                )
                .build()

            LlmInferenceSession.createFromOptions(inferenceEngine, sessionOptions)
        } catch (e: Exception) {
            Log.e(TAG, "√âchec de la cr√©ation de la nouvelle session", e)
            null
        }
    }

    fun resetSession() {
        Log.d(TAG, "R√©initialisation de la session du Juge.")
        session?.close()
        session = createNewSession(currentSessionTemperature ?: 0.44f)
    }

    fun generateResponse(
        prompt: String,
        temperature: Float,
        resultListener: ResultListener
    ) {
        if (currentSessionTemperature != temperature) {
            session?.close()
            session = createNewSession(temperature)
        }

        val currentSession = session ?: run {
            val errorMsg = "Erreur Critique: La session est nulle."
            Log.e(TAG, errorMsg)
            resultListener(errorMsg, true)
            return
        }

        try {
            currentSession.addQueryChunk(prompt)
            currentSession.generateResponseAsync(resultListener)
        } catch (e: Exception) {
            Log.e(TAG, "Erreur durant l'inf√©rence dans le Clash", e)
            resultListener(e.message ?: "Error during inference", true)
        }
    }

    fun cleanUp() {
        session?.close()
        llmInference?.close()
        session = null
        llmInference = null
        currentSessionTemperature = null
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashLlmHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashPromptGenerator.kt ---

package be.heyman.android.ai.kikko.clash.helpers

import android.content.Context
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.prompt.PromptManager
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.IOException
import java.util.Locale

data class LocalizedQuestion(val en: String, val fr: String, val ja: String)

object ClashPromptGenerator {

    private var clashQuestionBank: Map<String, List<LocalizedQuestion>> = emptyMap()
    private var isQuestionBankLoaded = false

    fun loadClashQuestions(context: Context) {
        if (isQuestionBankLoaded) return

        try {
            val jsonString = context.assets.open("clash_questions_i18n.json").bufferedReader().use { it.readText() }
            val type = object : TypeToken<Map<String, List<LocalizedQuestion>>>() {}.type
            clashQuestionBank = Gson().fromJson(jsonString, type)
            isQuestionBankLoaded = true
        } catch (ioException: IOException) {
            ioException.printStackTrace()
        }
    }

    fun getRandomClashQuestionSet(deckName: String): LocalizedQuestion? {
        if (!isQuestionBankLoaded) return null
        return clashQuestionBank[deckName]?.randomOrNull()
    }

    fun getLocalizedQuestion(question: LocalizedQuestion): String {
        return when (Locale.getDefault().language) {
            "fr" -> question.fr
            "ja" -> question.ja
            else -> question.en
        }
    }

    fun generateClashVerdictPrompt(question: String, card1: KnowledgeCard, card2: KnowledgeCard): String {
        val player1Json = Gson().toJson(card1.stats?.items ?: emptyMap<String, String>())
        val player2Json = Gson().toJson(card2.stats?.items ?: emptyMap<String, String>())

        val deviceLanguage = when (Locale.getDefault().language) {
            "fr" -> "French"
            "ja" -> "Japanese"
            else -> "English"
        }

        // BOURDON'S FINAL REFACTOR: Le g√©n√©rateur r√©cup√®re le prompt brut et effectue le formatage.
        val rawPrompt = PromptManager.getPrompt("clash_verdict")
        return String.format(
            rawPrompt,
            question,
            deviceLanguage,
            card1.specificName,
            player1Json,
            card2.specificName,
            player2Json
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashPromptGenerator.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashTranslationHelper.kt ---

package be.heyman.android.ai.kikko.clash.helpers

import android.util.Log
import com.google.android.gms.tasks.Tasks
import com.google.mlkit.common.model.DownloadConditions
import com.google.mlkit.nl.languageid.LanguageIdentification
import com.google.mlkit.nl.translate.Translation
import com.google.mlkit.nl.translate.Translator
import com.google.mlkit.nl.translate.TranslatorOptions
import java.util.Locale

/**
 * Un helper pour encapsuler la logique de traduction de ML Kit pour le Clash.
 */
object ClashTranslationHelper {

    private const val TAG = "ClashTranslationHelper"

    private var translator: Translator? = null
    private var lastOptions: TranslatorOptions? = null
    private val languageIdentifier = LanguageIdentification.getClient()

    /**
     * Traduit un texte donn√© vers la langue cible sp√©cifi√©e.
     * D√©tecte automatiquement la langue source.
     */
    suspend fun translate(textToTranslate: String, targetLanguage: String): String {
        if (textToTranslate.isBlank()) {
            return ""
        }

        return try {
            val languageCode = Tasks.await(languageIdentifier.identifyLanguage(textToTranslate))
            if (languageCode == "und") {
                return "[Erreur: Langue non d√©tect√©e]"
            }

            if (languageCode == targetLanguage) {
                val langName = Locale.forLanguageTag(languageCode).displayName
                return "[Texte d√©j√† en ${langName}]"
            }

            Log.d(TAG, "Langue d√©tect√©e: $languageCode, Cible: $targetLanguage")
            executeTranslation(textToTranslate, languageCode, targetLanguage)
        } catch (e: Exception) {
            Log.e(TAG, "L'identification ou la traduction a √©chou√©", e)
            "[Erreur: ${e.message}]"
        }
    }

    private suspend fun executeTranslation(textToTranslate: String, sourceLanguage: String, targetLanguage: String): String {
        val options = TranslatorOptions.Builder()
            .setSourceLanguage(sourceLanguage)
            .setTargetLanguage(targetLanguage)
            .build()

        // R√©utilise ou cr√©e un nouveau traducteur si les options ont chang√©
        if (lastOptions != options) {
            closeTranslator()
            lastOptions = options
            translator = Translation.getClient(options)
        }
        val localTranslator = translator ?: return "[Erreur: Client de traduction non initialis√©]"

        // T√©l√©charge le mod√®le si n√©cessaire
        val conditions = DownloadConditions.Builder().requireWifi().build()
        Tasks.await(localTranslator.downloadModelIfNeeded(conditions))
        Log.d(TAG, "Mod√®le de traduction pr√™t.")

        // Effectue la traduction
        return Tasks.await(localTranslator.translate(textToTranslate))
    }

    fun closeTranslator() {
        translator?.close()
        translator = null
        lastOptions = null
        Log.d(TAG, "Client de traduction ferm√©.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashTranslationHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/TtsService.kt ---

package be.heyman.android.ai.kikko.clash.helpers

import android.content.Context
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import java.util.Locale
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue

object TtsService : TextToSpeech.OnInitListener {

    private const val TAG = "KikkoTtsService"

    private var tts: TextToSpeech? = null
    private var isTtsInitialized = false
    private var isSpeaking = false

    private data class SpeakRequest(val utteranceId: String, val text: String, val locale: Locale, val onDone: (() -> Unit)?)
    private val directSpeakQueue = ConcurrentLinkedQueue<SpeakRequest>()

    fun initialize(context: Context) {
        if (tts == null) {
            Log.d(TAG, "Initialisation du moteur TTS...")
            tts = TextToSpeech(context.applicationContext, this)
            tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) {
                    isSpeaking = true
                    Log.d(TAG, "TTS a commenc√© √† parler: $utteranceId")
                }

                override fun onDone(utteranceId: String?) {
                    Log.d(TAG, "TTS a fini de parler: $utteranceId")
                    isSpeaking = false
                    val completedRequest = directSpeakQueue.poll()
                    completedRequest?.onDone?.invoke()
                    processDirectSpeakQueue()
                }

                override fun onError(utteranceId: String?) {
                    Log.e(TAG, "Erreur TTS pour: $utteranceId")
                    isSpeaking = false
                    directSpeakQueue.poll()
                    processDirectSpeakQueue()
                }
            })
        }
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isTtsInitialized = true
            Log.d(TAG, "Moteur TTS initialis√© avec succ√®s.")
            tts?.language = Locale.getDefault()
            processDirectSpeakQueue()
        } else {
            isTtsInitialized = false
            Log.e(TAG, "√âchec de l'initialisation du moteur TTS. Statut: $status")
        }
    }

    fun speak(text: String, locale: Locale, onDone: (() -> Unit)? = null) {
        val utteranceId = "KikkoSpeak-${UUID.randomUUID()}"
        val request = SpeakRequest(utteranceId, text, locale, onDone)
        directSpeakQueue.add(request)

        if (isTtsInitialized) {
            processDirectSpeakQueue()
        }
    }

    private fun processDirectSpeakQueue() {
        if (isSpeaking || !isTtsInitialized || directSpeakQueue.isEmpty()) {
            return
        }

        val request = directSpeakQueue.peek() ?: return
        tts?.language = request.locale
        tts?.speak(request.text, TextToSpeech.QUEUE_ADD, null, request.utteranceId)
    }

    fun stopAndClearQueue() {
        tts?.stop()
        directSpeakQueue.clear()
        isSpeaking = false
        Log.d(TAG, "TTS arr√™t√© et file d'attente vid√©e.")
    }

    fun shutdown() {
        stopAndClearQueue()
        tts?.shutdown()
        tts = null
        isTtsInitialized = false
        Log.d(TAG, "Moteur TTS lib√©r√©.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/TtsService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/services/ClashArenaService.kt ---

package be.heyman.android.ai.kikko.clash.services

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.Deck
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import com.google.android.gms.nearby.Nearby
import com.google.android.gms.nearby.connection.*
import com.google.android.gms.tasks.OnFailureListener
import java.nio.charset.StandardCharsets
import java.util.Locale
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.math.abs

@Singleton
class ClashArenaService @Inject constructor(
    private val context: Context
) {
    private val TAG = "ClashArenaService"
    private val connectionsClient: ConnectionsClient = Nearby.getConnectionsClient(context)

    private val STRATEGY = Strategy.P2P_STAR
    private val SERVICE_ID = "be.heyman.android.ai.kikko.SERVICE_ID"

    private var listener: ClashArenaListener? = null
    private var myName: String = "KikkoUser${(100..999).random()}"
    private val turtleColorPalette: List<Int> = context.resources.getIntArray(R.array.turtle_colors).toList()

    private val incomingFilePayloads = mutableMapOf<Long, Payload>()

    interface ClashArenaListener {
        fun onStatusUpdate(message: String)
        fun onEndpointFound(endpointId: String, catalogue: PlayerCatalogue)
        fun onEndpointLost(endpointId: String)
        fun onConnectionInitiated(endpointId: String, opponentName: String, authDigits: String)
        fun onConnectionResult(endpointId: String, isSuccess: Boolean)
        fun onDisconnected(endpointId: String)
        fun onPayloadReceived(endpointId: String, payloadString: String)
        fun onFilePayloadReceived(endpointId: String, payload: Payload)
        fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate)
    }

    fun setListener(listener: ClashArenaListener) {
        this.listener = listener
    }

    private fun detailedFailureListener(action: String): OnFailureListener {
        return OnFailureListener { e ->
            val errorMessage = "Erreur $action: ${e.localizedMessage}"
            Log.e(TAG, errorMessage, e)
            listener?.onStatusUpdate(errorMessage)
        }
    }

    fun startAdvertising(myCatalogue: PlayerCatalogue) {
        listener?.onStatusUpdate("Devenir visible...")
        val advertisingOptions = AdvertisingOptions.Builder().setStrategy(STRATEGY).build()
        val endpointNameCompact = buildEndpointName(myCatalogue)

        connectionsClient.startAdvertising(endpointNameCompact, SERVICE_ID, connectionLifecycleCallback, advertisingOptions)
            .addOnSuccessListener { listener?.onStatusUpdate("Vous √™tes maintenant visible.") }
            .addOnFailureListener(detailedFailureListener("publicit√©"))
    }

    fun stopAdvertising() {
        connectionsClient.stopAdvertising()
        listener?.onStatusUpdate("Visibilit√© arr√™t√©e.")
    }

    fun startDiscovery() {
        listener?.onStatusUpdate("Recherche d'adversaires...")
        val discoveryOptions = DiscoveryOptions.Builder().setStrategy(STRATEGY).build()
        connectionsClient.startDiscovery(SERVICE_ID, endpointDiscoveryCallback, discoveryOptions)
            .addOnSuccessListener { listener?.onStatusUpdate("Recherche en cours...") }
            .addOnFailureListener(detailedFailureListener("d√©couverte"))
    }

    fun stopDiscovery() {
        connectionsClient.stopDiscovery()
        listener?.onStatusUpdate("Recherche arr√™t√©e.")
    }

    fun requestConnection(endpointId: String) {
        connectionsClient.requestConnection(myName, endpointId, connectionLifecycleCallback)
            .addOnFailureListener(detailedFailureListener("demande de connexion"))
    }

    fun acceptConnection(endpointId: String) {
        connectionsClient.acceptConnection(endpointId, payloadCallback)
            .addOnFailureListener(detailedFailureListener("acceptation de connexion"))
    }

    fun rejectConnection(endpointId: String) {
        connectionsClient.rejectConnection(endpointId)
            .addOnFailureListener(detailedFailureListener("refus de connexion"))
    }

    fun sendPayload(endpointId: String, payloadString: String) {
        val payload = Payload.fromBytes(payloadString.toByteArray(StandardCharsets.UTF_8))
        connectionsClient.sendPayload(endpointId, payload)
            .addOnFailureListener(detailedFailureListener("envoi de payload"))
    }

    fun sendPayload(endpointId: String, payload: Payload) {
        connectionsClient.sendPayload(endpointId, payload)
            .addOnFailureListener(detailedFailureListener("envoi de payload fichier"))
    }

    fun disconnect(endpointId: String) {
        connectionsClient.disconnectFromEndpoint(endpointId)
    }

    fun stopAllEndpoints() {
        connectionsClient.stopAllEndpoints()
    }

    private fun buildEndpointName(myCatalogue: PlayerCatalogue): String {
        val deckCountsCsv = GameConstants.MASTER_DECK_LIST.joinToString(",") { deckName ->
            myCatalogue.decks.find { it.name == deckName }?.cardCount?.toString() ?: "0"
        }
        val recordCsv = "${myCatalogue.wins},${myCatalogue.losses}"
        val latFormatted = String.format(Locale.US, "%.6f", myCatalogue.latitude ?: 0.0)
        val lonFormatted = String.format(Locale.US, "%.6f", myCatalogue.longitude ?: 0.0)
        return "$myName|$deckCountsCsv|$recordCsv|$latFormatted $lonFormatted"
    }

    private val endpointDiscoveryCallback = object : EndpointDiscoveryCallback() {
        override fun onEndpointFound(endpointId: String, info: DiscoveredEndpointInfo) {
            try {
                val parts = info.endpointName.split('|')
                if (parts.size == 4) {
                    val name = parts[0]
                    val deckCountsCsv = parts[1].split(',')
                    val recordParts = parts[2].split(',')
                    val locationParts = parts[3].split(' ')

                    val wins = recordParts.getOrNull(0)?.toIntOrNull() ?: 0
                    val losses = recordParts.getOrNull(1)?.toIntOrNull() ?: 0
                    val lat = locationParts.getOrNull(0)?.toDoubleOrNull()
                    val lon = locationParts.getOrNull(1)?.toDoubleOrNull()

                    val reconstructedDecks = GameConstants.MASTER_DECK_LIST.mapIndexedNotNull { index, deckName ->
                        val count = deckCountsCsv.getOrNull(index)?.toIntOrNull() ?: 0
                        if (count > 0) Deck(deckName, count) else null
                    }
                    val colorIndex = abs(endpointId.hashCode()) % turtleColorPalette.size
                    val assignedColor = turtleColorPalette[colorIndex]
                    val partialCatalogue = PlayerCatalogue(name, reconstructedDecks, lat, lon, wins, losses, assignedColor)
                    listener?.onEndpointFound(endpointId, partialCatalogue)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erreur parsing endpointName: ${info.endpointName}", e)
            }
        }
        override fun onEndpointLost(endpointId: String) { listener?.onEndpointLost(endpointId) }
    }

    private val connectionLifecycleCallback = object : ConnectionLifecycleCallback() {
        override fun onConnectionInitiated(endpointId: String, info: ConnectionInfo) {
            val opponentName = info.endpointName.split('|').firstOrNull() ?: "Adversaire"
            listener?.onConnectionInitiated(endpointId, opponentName, info.authenticationDigits)
        }
        override fun onConnectionResult(endpointId: String, result: ConnectionResolution) {
            val isSuccess = result.status.statusCode == ConnectionsStatusCodes.STATUS_OK
            if (!isSuccess) {
                Log.e(TAG, "√âchec de connexion. Code: ${result.status.statusCode} - ${result.status.statusMessage}")
            }
            listener?.onConnectionResult(endpointId, isSuccess)
        }
        override fun onDisconnected(endpointId: String) { listener?.onDisconnected(endpointId) }
    }

    private val payloadCallback = object : PayloadCallback() {
        override fun onPayloadReceived(endpointId: String, payload: Payload) {
            when (payload.type) {
                Payload.Type.BYTES -> {
                    val receivedJson = String(payload.asBytes()!!, StandardCharsets.UTF_8)
                    Log.i(TAG, "[P2P RECV] Payload de type BYTES (m√©tadonn√©es JSON) re√ßu de $endpointId.")
                    listener?.onPayloadReceived(endpointId, receivedJson)
                }
                Payload.Type.FILE -> {
                    Log.i(TAG, "[P2P RECV] Payload de type FILE (image) re√ßu de $endpointId. En attente du transfert complet. Payload ID: ${payload.id}")
                    incomingFilePayloads[payload.id] = payload
                }
                Payload.Type.STREAM -> { /* Non utilis√© */ }
            }
        }

        override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
            val payloadId = update.payloadId
            if (update.status == PayloadTransferUpdate.Status.SUCCESS) {
                val payload = incomingFilePayloads.remove(payloadId)
                if (payload != null && payload.type == Payload.Type.FILE) {
                    Log.i(TAG, "[P2P RECV] Transfert du payload ID $payloadId termin√© avec succ√®s. Notification du listener pour le traitement du fichier.")
                    listener?.onFilePayloadReceived(endpointId, payload)
                }
            } else if (update.status == PayloadTransferUpdate.Status.FAILURE) {
                Log.e(TAG, "[P2P RECV] √âchec du transfert pour le payload ID $payloadId. Suppression du payload en attente.")
                incomingFilePayloads.remove(payloadId)
            }
            listener?.onPayloadTransferUpdate(endpointId, update)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/services/ClashArenaService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashActivity.kt ---

package be.heyman.android.ai.kikko.clash.ui

import android.Manifest
import android.animation.ObjectAnimator
import android.content.Context
import android.content.Intent
import android.content.pm.ActivityInfo
import android.content.pm.PackageManager
import android.graphics.BitmapFactory
import android.location.Location
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Looper
import android.util.Log
import android.view.View
import android.view.WindowInsets
import android.view.WindowInsetsController
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.Group
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.viewpager2.widget.ViewPager2
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.clash.ui.adapter.PlayerAdapter
import be.heyman.android.ai.kikko.clash.ui.dialogs.ClashSetupDialogFragment
import be.heyman.android.ai.kikko.clash.viewmodel.ClashFlowState
import be.heyman.android.ai.kikko.clash.viewmodel.ClashMode
import be.heyman.android.ai.kikko.clash.viewmodel.ClashUiState
import be.heyman.android.ai.kikko.clash.viewmodel.ClashViewModel
import be.heyman.android.ai.kikko.clash.viewmodel.DialogState
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.ui.adapters.CardPreviewAdapter
import com.google.android.gms.location.*
import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
import kotlinx.coroutines.launch
import java.io.File


class ClashActivity : AppCompatActivity(),
    ClashSetupDialogFragment.ClashSetupListener {

    private val TAG = "ClashActivity"
    private val viewModel: ClashViewModel by viewModels()

    private lateinit var setupGroup: Group
    private lateinit var viewPager: ViewPager2
    private lateinit var backgroundPlayerView: PlayerView
    private var exoPlayer: ExoPlayer? = null

    private lateinit var randomButton: ImageButton
    private lateinit var settingsButton: ImageButton
    private lateinit var radarButton: ImageButton
    private lateinit var startSoloButton: ExtendedFloatingActionButton
    private lateinit var queenStatusTextView: TextView
    private lateinit var judgeLoadingContainer: View

    private lateinit var p1SlotFood: FrameLayout
    private lateinit var p1SlotPlant: FrameLayout
    private lateinit var p1SlotInsect: FrameLayout
    private lateinit var p1SlotBird: FrameLayout
    private lateinit var p2SlotFood: FrameLayout
    private lateinit var p2SlotPlant: FrameLayout
    private lateinit var p2SlotInsect: FrameLayout
    private lateinit var p2SlotBird: FrameLayout

    private lateinit var p2pPanel: View
    private lateinit var p2pPanelCloseButton: ImageButton
    private lateinit var p2pPanelRadarView: be.heyman.android.ai.kikko.clash.ui.views.RadarView
    private lateinit var p2pPanelStatusText: TextView
    private lateinit var p2pPanelRecyclerView: RecyclerView
    private lateinit var p2pPanelPlayerAdapter: PlayerAdapter

    private lateinit var cardSelectorPanel: View
    private lateinit var selectorDeckIcon: ImageView
    private lateinit var selectorDeckName: TextView
    private lateinit var selectorCloseButton: ImageButton
    private lateinit var selectorRecyclerView: RecyclerView
    private lateinit var selectorAdapter: CardPreviewAdapter

    private var pagerAdapter: ClashPagerAdapter? = null
    private var clashDialog: AlertDialog? = null
    private var connectionRequestDialog: AlertDialog? = null

    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient
    private var myLocation: Location? = null
    private val locationCallback: LocationCallback

    init {
        locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.lastLocation?.let {
                    myLocation = it
                    if (p2pPanel.translationX == 0f) {
                        viewModel.uiState.value.let { state ->
                            p2pPanelPlayerAdapter.updatePlayers(state.discoveredPlayers, myLocation)
                            p2pPanelRadarView.updatePlayers(state.discoveredPlayers, myLocation)
                        }
                    }
                }
            }
        }
    }

    private val requestMultiplePermissions =
        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->
            if (permissions.all { it.value }) {
                startP2PWithLocation()
            } else {
                Toast.makeText(this, R.string.p2p_permissions_required, Toast.LENGTH_LONG).show()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
        setContentView(R.layout.activity_clash_arena)
        hideSystemUI()

        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)

        bindViews()
        setupListeners()
        observeViewModel()
        setupViewPagerOnce()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
    }

    override fun onStop() {
        super.onStop()
        releasePlayer()
    }


    override fun onWindowFocusChanged(hasFocus: Boolean) {
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus) {
            hideSystemUI()
        }
    }

    private fun hideSystemUI() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            window.insetsController?.let {
                it.hide(WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars())
                it.systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
            }
        } else {
            @Suppress("DEPRECATION")
            window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_FULLSCREEN)
        }
    }

    private fun bindViews() {
        setupGroup = findViewById(R.id.clash_setup_group)
        viewPager = findViewById(R.id.tournament_viewpager)
        backgroundPlayerView = findViewById(R.id.clash_background_video_view)

        randomButton = findViewById(R.id.clash_button_random)
        settingsButton = findViewById(R.id.clash_button_settings)
        radarButton = findViewById(R.id.clash_button_radar)
        startSoloButton = findViewById(R.id.clash_button_start_solo)
        queenStatusTextView = findViewById(R.id.clash_queen_status)
        judgeLoadingContainer = findViewById(R.id.clash_judge_loading_container)


        p1SlotFood = findViewById(R.id.p1_slot_food)
        p1SlotPlant = findViewById(R.id.p1_slot_plant)
        p1SlotInsect = findViewById(R.id.p1_slot_insect)
        p1SlotBird = findViewById(R.id.p1_slot_bird)
        p2SlotFood = findViewById(R.id.p2_slot_food)
        p2SlotPlant = findViewById(R.id.p2_slot_plant)
        p2SlotInsect = findViewById(R.id.p2_slot_insect)
        p2SlotBird = findViewById(R.id.p2_slot_bird)

        cardSelectorPanel = findViewById(R.id.card_selector_panel_include)
        selectorDeckIcon = cardSelectorPanel.findViewById(R.id.selector_panel_deck_icon)
        selectorDeckName = cardSelectorPanel.findViewById(R.id.selector_panel_deck_name)
        selectorCloseButton = cardSelectorPanel.findViewById(R.id.selector_panel_close_button)
        selectorRecyclerView = cardSelectorPanel.findViewById(R.id.selector_panel_recyclerview)

        p2pPanel = findViewById(R.id.p2p_panel)
        p2pPanelCloseButton = findViewById(R.id.p2p_panel_close_button)
        p2pPanelRadarView = findViewById(R.id.p2p_panel_radar_view)
        p2pPanelStatusText = findViewById(R.id.p2p_panel_status_text)
        p2pPanelRecyclerView = findViewById(R.id.p2p_panel_recycler_view)

        p2pPanelPlayerAdapter = PlayerAdapter(emptyMap(), null) { endpointId ->
            viewModel.connectToPlayer(endpointId)
        }
        p2pPanelRecyclerView.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)
        p2pPanelRecyclerView.adapter = p2pPanelPlayerAdapter
    }

    private fun setupListeners() {
        startSoloButton.setOnClickListener { viewModel.confirmSetupAndStartSoloClash() }
        settingsButton.setOnClickListener { showClashSetupDialog() }
        randomButton.setOnClickListener { viewModel.generateRandomTeams() }

        radarButton.setOnClickListener {
            if (p2pPanel.translationX > 0f) {
                showP2pPanel()
            } else {
                hideP2pPanel()
            }
        }
        p2pPanelCloseButton.setOnClickListener { hideP2pPanel() }


        p1SlotFood.setOnClickListener { onDeckSlotClicked("Food", 1) }
        p1SlotPlant.setOnClickListener { onDeckSlotClicked("Plant", 1) }
        p1SlotInsect.setOnClickListener { onDeckSlotClicked("Insect", 1) }
        p1SlotBird.setOnClickListener { onDeckSlotClicked("Bird", 1) }

        p2SlotFood.setOnClickListener { onDeckSlotClicked("Food", 2) }
        p2SlotPlant.setOnClickListener { onDeckSlotClicked("Plant", 2) }
        p2SlotInsect.setOnClickListener { onDeckSlotClicked("Insect", 2) }
        p2SlotBird.setOnClickListener { onDeckSlotClicked("Bird", 2) }

        selectorCloseButton.setOnClickListener { hideCardSelector() }
    }

    private fun initializePlayer() {
        exoPlayer = ExoPlayer.Builder(this).build().also { player ->
            backgroundPlayerView.player = player
            val videoUri = Uri.parse("android.resource://$packageName/${R.raw.kikko_clash}")
            val mediaItem = MediaItem.fromUri(videoUri)
            player.setMediaItem(mediaItem)
            player.repeatMode = Player.REPEAT_MODE_ONE
            player.volume = 0f
            player.playWhenReady = true
            player.prepare()
        }
    }

    private fun releasePlayer() {
        exoPlayer?.release()
        exoPlayer = null
    }

    private fun showP2pPanel() {
        val panelWidth = p2pPanel.width.toFloat()
        ObjectAnimator.ofFloat(p2pPanel, "translationX", panelWidth, 0f).apply {
            duration = 300
            start()
        }
        checkPermissionsAndStartDiscovery()
    }

    private fun hideP2pPanel() {
        val panelWidth = p2pPanel.width.toFloat()
        ObjectAnimator.ofFloat(p2pPanel, "translationX", 0f, panelWidth).apply {
            duration = 300
            start()
        }
        if (viewModel.uiState.value.clashMode == ClashMode.P2P_DISCOVERING) {
            viewModel.stopP2P()
        }
    }

    private fun onDeckSlotClicked(deckName: String, playerIndex: Int) {
        Log.d(TAG, "Deck slot clicked: $deckName for player $playerIndex")

        if (viewModel.uiState.value.clashMode != ClashMode.SOLO && playerIndex == 2) {
            Toast.makeText(this, R.string.clash_waiting_for_opponent, Toast.LENGTH_SHORT).show()
            return
        }

        if (viewModel.uiState.value.isJudgeInitializing) {
            Toast.makeText(this, R.string.clash_waiting_for_judge, Toast.LENGTH_SHORT).show()
            return
        }

        lifecycleScope.launch {
            val cards = viewModel.getCardsForDeck(deckName)
            if (cards.isEmpty()) {
                Toast.makeText(this@ClashActivity, getString(R.string.clash_no_cards_in_deck, deckName), Toast.LENGTH_SHORT).show()
                return@launch
            }
            showCardSelectorForDeck(deckName, cards, playerIndex)
        }
    }

    private fun showCardSelectorForDeck(deckName: String, cards: List<KnowledgeCard>, playerIndex: Int) {
        selectorDeckName.text = getString(R.string.clash_selector_title_format, playerIndex, deckName)
        selectorDeckIcon.setImageResource(getDeckIcon(deckName))

        selectorAdapter = CardPreviewAdapter(cards.toMutableList()) { selectedCard ->
            viewModel.handleChampionSelection(deckName, selectedCard, playerIndex)
            hideCardSelector()
        }
        selectorRecyclerView.layoutManager = GridLayoutManager(this, 4)
        selectorRecyclerView.adapter = selectorAdapter

        cardSelectorPanel.visibility = View.VISIBLE
    }

    private fun hideCardSelector() {
        cardSelectorPanel.visibility = View.GONE
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    viewModel.uiState.collect { state ->
                        Log.d(TAG, "Nouvel √©tat UI re√ßu: flowState=${state.flowState}, clashMode=${state.clashMode}, isJudgeInitializing=${state.isJudgeInitializing}")
                        when (state.flowState) {
                            ClashFlowState.SETUP -> showSetupUI(state)
                            ClashFlowState.DUELING -> showDuelingUI(state)
                            ClashFlowState.FINISHED -> showFinishedUI()
                        }
                        handleDialogState(state.dialogState)
                        state.errorMessage?.let {
                            Toast.makeText(this@ClashActivity, it, Toast.LENGTH_LONG).show()
                            viewModel.clearErrorMessage()
                        }
                    }
                }

                launch {
                    viewModel.p2pEvent.collect { event ->
                        when (event) {
                            is ClashViewModel.P2pEvent.ShowConnectionDialog -> {
                                showConnectionRequestDialog(event.endpointId, event.opponentName, event.authCode)
                            }
                        }
                    }
                }
            }
        }
    }

    private fun showSetupUI(state: ClashUiState) {
        setupGroup.visibility = View.VISIBLE
        viewPager.visibility = View.GONE

        judgeLoadingContainer.visibility = if (state.isJudgeInitializing) View.VISIBLE else View.GONE
        val isUiEnabled = !state.isJudgeInitializing

        if (state.clashMode == ClashMode.P2P_CARD_SELECTION && p2pPanel.translationX == 0f) {
            hideP2pPanel()
        }

        queenStatusTextView.text = state.clashSettings?.let {
            getString(R.string.clash_judge_status_format, it.queenModelName, it.brain, it.temperature)
        } ?: getString(R.string.clash_judge_status_placeholder)

        startSoloButton.isEnabled = state.isReadyToClash && isUiEnabled
        randomButton.isEnabled = isUiEnabled
        settingsButton.isEnabled = isUiEnabled
        radarButton.isEnabled = isUiEnabled

        updateAllSelectionSlots(state)

        val isPlayer1Clickable = isUiEnabled
        val isPlayer2Clickable = (state.clashMode == ClashMode.SOLO) && isUiEnabled

        p1SlotFood.isClickable = isPlayer1Clickable
        p1SlotPlant.isClickable = isPlayer1Clickable
        p1SlotInsect.isClickable = isPlayer1Clickable
        p1SlotBird.isClickable = isPlayer1Clickable

        p2SlotFood.isClickable = isPlayer2Clickable
        p2SlotPlant.isClickable = isPlayer2Clickable
        p2SlotInsect.isClickable = isPlayer2Clickable
        p2SlotBird.isClickable = isPlayer2Clickable

        p2pPanelStatusText.text = state.p2pStatus
        p2pPanelPlayerAdapter.updatePlayers(state.discoveredPlayers, myLocation)
        p2pPanelRadarView.updatePlayers(state.discoveredPlayers, myLocation)
    }

    private fun updateAllSelectionSlots(state: ClashUiState) {
        updateSelectionSlot(p1SlotFood, state.myChampions["Food"])
        updateSelectionSlot(p1SlotPlant, state.myChampions["Plant"])
        updateSelectionSlot(p1SlotInsect, state.myChampions["Insect"])
        updateSelectionSlot(p1SlotBird, state.myChampions["Bird"])

        updateSelectionSlot(p2SlotFood, state.opponentChampions["Food"])
        updateSelectionSlot(p2SlotPlant, state.opponentChampions["Plant"])
        updateSelectionSlot(p2SlotInsect, state.opponentChampions["Insect"])
        updateSelectionSlot(p2SlotBird, state.opponentChampions["Bird"])
    }

    private fun updateSelectionSlot(slotView: FrameLayout, card: KnowledgeCard?) {
        val placeholderButton = slotView.getChildAt(0)
        val cardThumbnail = slotView.getChildAt(1)

        if (card == null) {
            placeholderButton.visibility = View.VISIBLE
            cardThumbnail.visibility = View.GONE
        } else {
            placeholderButton.visibility = View.GONE
            cardThumbnail.visibility = View.VISIBLE
            val cardNameView: TextView = cardThumbnail.findViewById(R.id.card_thumbnail_name)
            val cardImageView: ImageView = cardThumbnail.findViewById(R.id.card_thumbnail_image)
            cardNameView.text = card.specificName
            card.imagePath?.let { path ->
                val imgFile = File(path)
                if (imgFile.exists()) {
                    cardImageView.setImageBitmap(BitmapFactory.decodeFile(imgFile.absolutePath))
                } else {
                    cardImageView.setImageResource(R.drawable.ic_placeholder_card)
                }
            } ?: cardImageView.setImageResource(R.drawable.ic_placeholder_card)
        }
    }


    private fun showDuelingUI(state: ClashUiState) {
        Log.d(TAG, "showDuelingUI: Passage √† l'√©cran de duel.")
        setupGroup.visibility = View.GONE
        viewPager.visibility = View.VISIBLE

        if (pagerAdapter == null || pagerAdapter?.itemCount != state.clashStates.size) {
            pagerAdapter = ClashPagerAdapter(this, state.clashStates.size)
            viewPager.adapter = pagerAdapter
        }

        if (viewPager.currentItem != state.currentDuelIndex && state.currentDuelIndex != -1) {
            viewPager.setCurrentItem(state.currentDuelIndex, true)
        }
    }


    private fun showFinishedUI() {
        Toast.makeText(this, R.string.clash_tournament_finished, Toast.LENGTH_LONG).show()
        lifecycleScope.launch {
            kotlinx.coroutines.delay(2000)
            viewModel.stopP2P()
            finish()
        }
    }

    private fun checkPermissionsAndStartDiscovery() {
        val requiredPermissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            arrayOf(Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_ADVERTISE, Manifest.permission.BLUETOOTH_CONNECT, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.NEARBY_WIFI_DEVICES)
        } else {
            arrayOf(Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_ADVERTISE, Manifest.permission.BLUETOOTH_CONNECT, Manifest.permission.ACCESS_FINE_LOCATION)
        }
        val missingPermissions = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }
        if (missingPermissions.isEmpty()) {
            startP2PWithLocation()
        } else {
            requestMultiplePermissions.launch(missingPermissions.toTypedArray())
        }
    }


    private fun startP2PWithLocation() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }
        fusedLocationProviderClient.lastLocation.addOnSuccessListener { location: Location? ->
            myLocation = location
            viewModel.startP2PDiscovery(myLocation)
        }
        startLocationUpdates()
    }


    private fun startLocationUpdates() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }
        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000).build()
        fusedLocationProviderClient.requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper())
    }

    private fun stopLocationUpdates() {
        fusedLocationProviderClient.removeLocationUpdates(locationCallback)
    }

    private fun setupViewPagerOnce() {
        viewPager.isUserInputEnabled = true
        viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                super.onPageSelected(position)
                viewModel.onDuelSelected(position)
            }
        })
    }

    private fun showClashSetupDialog() {
        if (supportFragmentManager.findFragmentByTag(ClashSetupDialogFragment.TAG) == null) {
            val currentState = viewModel.uiState.value
            val dialog = ClashSetupDialogFragment.newInstance(
                availableModels = currentState.availableModels,
                currentSettings = currentState.clashSettings
            )
            dialog.show(supportFragmentManager, ClashSetupDialogFragment.TAG)
        }
    }

    private fun handleDialogState(dialogState: DialogState) {
        if (dialogState == DialogState.None) {
            clashDialog?.dismiss()
            clashDialog = null
            return
        }
        if (clashDialog != null) { return }
        when (dialogState) {
            DialogState.ReadyToClash -> {
                clashDialog = AlertDialog.Builder(this@ClashActivity, R.style.KikkoAlertDialogTheme)
                    .setTitle(R.string.dialog_arena_ready_title)
                    .setMessage(R.string.dialog_arena_ready_message)
                    .setPositiveButton(R.string.dialog_launch) { _, _ -> viewModel.confirmAndStartP2pClash() }
                    .setNegativeButton(R.string.dialog_cancel) { _, _ -> viewModel.dismissDialog() }
                    .setOnDismissListener { clashDialog = null }
                    .setCancelable(false)
                    .show()
            }
            DialogState.WaitingForHost -> {
                clashDialog = AlertDialog.Builder(this@ClashActivity, R.style.KikkoAlertDialogTheme)
                    .setTitle(R.string.dialog_teams_complete_title)
                    .setMessage(R.string.dialog_waiting_for_host_message)
                    .setCancelable(false)
                    .setOnDismissListener { clashDialog = null }
                    .show()
            }
            else -> {}
        }
    }

    private fun showConnectionRequestDialog(endpointId: String, opponentName: String, authCode: String) {
        connectionRequestDialog?.dismiss()
        connectionRequestDialog = AlertDialog.Builder(this, R.style.KikkoAlertDialogTheme)
            .setTitle(getString(R.string.dialog_connection_title, opponentName))
            .setMessage(getString(R.string.dialog_connection_message, authCode))
            .setPositiveButton(R.string.dialog_accept) { _, _ ->
                viewModel.acceptConnection(endpointId)
            }
            .setNegativeButton(R.string.dialog_decline) { _, _ ->
                viewModel.rejectConnection(endpointId)
            }
            .setOnDismissListener { connectionRequestDialog = null }
            .setCancelable(false)
            .show()
    }

    private fun getDeckIcon(deckName: String): Int {
        return when (deckName) {
            "Food" -> R.drawable.ic_deck_food
            "Plant" -> R.drawable.ic_deck_plant
            "Insect" -> R.drawable.ic_deck_insect
            "Bird" -> R.drawable.ic_deck_bird
            else -> R.drawable.ic_deck_default
        }
    }

    override fun onClashSettingsConfirmed(settings: ClashSettings) {
        viewModel.updateClashSettings(settings)
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy: L'activit√© de Clash est d√©truite.")
        clashDialog?.dismiss()
        connectionRequestDialog?.dismiss()
        viewModel.stopP2P()
        stopLocationUpdates()
    }

    companion object {
        fun newIntent(context: Context): Intent {
            return Intent(context, ClashActivity::class.java)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashDuelFragment.kt ---

package be.heyman.android.ai.kikko.clash.ui

import android.animation.AnimatorSet
import android.animation.ObjectAnimator
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.animation.AccelerateDecelerateInterpolator
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.ClashStatus
import be.heyman.android.ai.kikko.clash.viewmodel.ClashMode
import be.heyman.android.ai.kikko.clash.viewmodel.ClashUiState
import be.heyman.android.ai.kikko.clash.viewmodel.ClashViewModel
import be.heyman.android.ai.kikko.model.KnowledgeCard
import com.google.android.material.progressindicator.CircularProgressIndicator
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import java.io.File

private const val ARG_DUEL_INDEX = "duel_index"

class ClashDuelFragment : Fragment() {

    private var duelIndex: Int = 0
    private val viewModel: ClashViewModel by activityViewModels()

    private lateinit var playerView: PlayerView
    private var exoPlayer: ExoPlayer? = null

    private lateinit var questionTextView: TextView
    private lateinit var player1CardView: View
    private lateinit var player2CardView: View
    private lateinit var reasoningTextView: TextView
    private lateinit var streamingReasoningTextView: TextView
    private lateinit var loadingIndicator: CircularProgressIndicator
    private lateinit var previousButton: Button
    private lateinit var nextButton: Button
    private lateinit var finishButton: Button
    private lateinit var navSpacer: View


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            duelIndex = it.getInt(ARG_DUEL_INDEX)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_duel_page, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        bindViews(view)
        observeViewModel()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
    }

    override fun onStop() {
        super.onStop()
        releasePlayer()
    }

    override fun onResume() {
        super.onResume()
        val currentState = viewModel.uiState.value
        val duelState = currentState.clashStates.getOrNull(duelIndex)
        if (duelState != null && currentState.currentDuelIndex == duelIndex && duelState.status == ClashStatus.PENDING) {
            if (currentState.isArbitrator || currentState.clashMode == ClashMode.SOLO) {
                viewModel.runInferenceForCurrentDuel()
            }
        }
    }

    private fun bindViews(view: View) {
        playerView = view.findViewById(R.id.duel_background_video_view)
        questionTextView = view.findViewById(R.id.duel_question_textview)
        player1CardView = view.findViewById(R.id.duel_player1_card)
        player2CardView = view.findViewById(R.id.duel_player2_card)
        reasoningTextView = view.findViewById(R.id.duel_reasoning_textview)
        streamingReasoningTextView = view.findViewById(R.id.duel_streaming_reasoning_textview)
        loadingIndicator = view.findViewById(R.id.duel_loading_indicator)
        previousButton = view.findViewById(R.id.duel_previous_button)
        nextButton = view.findViewById(R.id.duel_next_button)
        finishButton = view.findViewById(R.id.duel_finish_button)
        navSpacer = view.findViewById(R.id.duel_nav_spacer)

        previousButton.setOnClickListener { viewModel.proceedToPreviousDuel() }
        nextButton.setOnClickListener { viewModel.proceedToNextDuel() }
        finishButton.setOnClickListener { viewModel.proceedToNextDuel() }
    }

    private fun initializePlayer() {
        exoPlayer = ExoPlayer.Builder(requireContext()).build().also { player ->
            playerView.player = player
            val videoUri = Uri.parse("android.resource://${requireContext().packageName}/${R.raw.kikko_question}")
            val mediaItem = MediaItem.fromUri(videoUri)
            player.setMediaItem(mediaItem)
            player.repeatMode = Player.REPEAT_MODE_ONE
            player.volume = 0f
            player.playWhenReady = true
            player.prepare()
        }
    }

    private fun releasePlayer() {
        exoPlayer?.release()
        exoPlayer = null
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collectLatest { state ->
                state.clashStates.getOrNull(duelIndex)?.let {
                    updateUi(state)
                }
            }
        }
    }

    private fun updateUi(state: ClashUiState) {
        val duelState = state.clashStates.getOrNull(duelIndex) ?: return
        val totalDuels = state.clashStates.size

        questionTextView.text = duelState.question ?: getString(R.string.clash_duel_question_placeholder)
        bindCard(player1CardView, duelState.player1Card)
        bindCard(player2CardView, duelState.player2Card)

        if (state.clashSettings?.isTtsEnabled == true) {
            viewModel.requestTtsForQuestion(duelIndex, autoPlay = true)
        }

        val isHost = state.isArbitrator || state.clashMode == ClashMode.SOLO
        val isCompleted = duelState.status == ClashStatus.COMPLETED || duelState.status == ClashStatus.ERROR

        previousButton.visibility = if (isHost && isCompleted && duelIndex > 0) View.VISIBLE else View.GONE
        nextButton.visibility = if (isHost && isCompleted && duelIndex < totalDuels - 1) View.VISIBLE else View.GONE
        finishButton.visibility = if (isHost && isCompleted && duelIndex == totalDuels - 1) View.VISIBLE else View.GONE
        navSpacer.visibility = if (previousButton.visibility == View.VISIBLE && (nextButton.visibility == View.VISIBLE || finishButton.visibility == View.VISIBLE)) View.VISIBLE else View.GONE
        loadingIndicator.visibility = if (duelState.status == ClashStatus.INFERRING || duelState.status == ClashStatus.TRANSLATING) View.VISIBLE else View.GONE

        streamingReasoningTextView.visibility = if (duelState.status == ClashStatus.INFERRING) View.VISIBLE else View.GONE
        streamingReasoningTextView.text = duelState.streamingReasoning
        reasoningTextView.visibility = if (isCompleted) View.VISIBLE else View.INVISIBLE

        if (isCompleted) {
            reasoningTextView.text = duelState.translatedReasoning ?: duelState.errorMessage ?: ""
            animateWinner(duelState.winner)
            if (state.clashSettings?.isTtsEnabled == true && !duelState.ttsHasBeenPlayed) {
                viewModel.requestTtsForReasoning(duelIndex, autoPlay = true)
            }
        }
    }

    private fun bindCard(cardView: View, card: KnowledgeCard) {
        val cardTitle = cardView.findViewById<TextView>(R.id.card_title)
        val cardDeckName = cardView.findViewById<TextView>(R.id.card_deck_name)
        val cardImage = cardView.findViewById<ImageView>(R.id.card_image)

        cardTitle.text = card.specificName
        cardDeckName.text = card.deckName

        card.imagePath?.let {
            val imgFile = File(it)
            if (imgFile.exists()) {
                val myBitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                cardImage.setImageBitmap(myBitmap)
            }
        }
    }

    private fun animateWinner(winner: String?) {
        val winnerScale = 1.05f
        val loserScale = 0.95f
        val winnerElevation = 16f
        val loserElevation = 4f
        val duration = 500L

        val (winnerView, loserView) = when (winner) {
            "player1" -> player1CardView to player2CardView
            "player2" -> player2CardView to player1CardView
            else -> null to null
        }

        if (winnerView != null && loserView != null) {
            winnerView.bringToFront()

            // BOURDON'S FIX: Remplacement de "cardElevation" par la propri√©t√© universelle "elevation".
            val winnerScaleX = ObjectAnimator.ofFloat(winnerView, "scaleX", winnerScale)
            val winnerScaleY = ObjectAnimator.ofFloat(winnerView, "scaleY", winnerScale)
            val winnerElevationAnim = ObjectAnimator.ofFloat(winnerView, "elevation", winnerElevation)

            val loserScaleX = ObjectAnimator.ofFloat(loserView, "scaleX", loserScale)
            val loserScaleY = ObjectAnimator.ofFloat(loserView, "scaleY", loserScale)
            val loserElevationAnim = ObjectAnimator.ofFloat(loserView, "elevation", loserElevation)

            val animatorSet = AnimatorSet().apply {
                playTogether(winnerScaleX, winnerScaleY, winnerElevationAnim, loserScaleX, loserScaleY, loserElevationAnim)
                this.duration = duration
                interpolator = AccelerateDecelerateInterpolator()
            }
            animatorSet.start()
        }
    }

    companion object {
        @JvmStatic
        fun newInstance(duelIndex: Int) =
            ClashDuelFragment().apply {
                arguments = Bundle().apply {
                    putInt(ARG_DUEL_INDEX, duelIndex)
                }
            }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashDuelFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashPagerAdapter.kt ---

package be.heyman.android.ai.kikko.clash.ui

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter

/**
 * L'adaptateur pour le ViewPager2 de l'ar√®ne de Clash.
 * Il est responsable de la cr√©ation d'un ClashDuelFragment pour chaque duel.
 *
 * @param fa L'activit√© h√¥te du fragment.
 * @param duelCount Le nombre total de duels √† afficher.
 */
class ClashPagerAdapter(
    fa: FragmentActivity,
    private val duelCount: Int
) : FragmentStateAdapter(fa) {

    /**
     * Retourne le nombre total de pages (duels).
     */
    override fun getItemCount(): Int = duelCount

    /**
     * Cr√©e et retourne un nouveau fragment pour la position donn√©e.
     * Chaque fragment repr√©sente un seul duel.
     */
    override fun createFragment(position: Int): Fragment {
        // Passe la position (index du duel) au fragment pour qu'il sache quelles donn√©es afficher.
        return ClashDuelFragment.newInstance(position)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashPagerAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/PlayerAdapter.kt ---

package be.heyman.android.ai.kikko.clash.ui.adapter

import android.content.Context
import android.graphics.PorterDuff
import android.location.Location
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue

class PlayerAdapter(
    private var players: Map<String, PlayerCatalogue>,
    private var currentUserLocation: Location?,
    private val onClick: (endpointId: String) -> Unit
) : RecyclerView.Adapter<PlayerAdapter.PlayerViewHolder>() {

    private val TAG = "PlayerAdapter"

    class PlayerViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val playerIcon: ImageView = view.findViewById(R.id.player_icon)
        val playerNameText: TextView = view.findViewById(R.id.player_name_text)
        val decksColumn1Text: TextView = view.findViewById(R.id.decks_column_1_text)
        val decksColumn2Text: TextView = view.findViewById(R.id.decks_column_2_text)
        val playerDistanceText: TextView = view.findViewById(R.id.player_distance_text)
        val playerRecordText: TextView = view.findViewById(R.id.player_record_text)
    }

    fun updatePlayers(newPlayers: Map<String, PlayerCatalogue>, location: Location?) {
        this.players = newPlayers
        this.currentUserLocation = location
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PlayerViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_player_card, parent, false)
        return PlayerViewHolder(view)
    }

    override fun onBindViewHolder(holder: PlayerViewHolder, position: Int) {
        val (endpointId, catalogue) = players.entries.toList()[position]
        val context = holder.itemView.context

        holder.playerNameText.text = catalogue.playerName

        val column1Decks = StringBuilder()
        val column2Decks = StringBuilder()

        catalogue.decks.forEach { deck ->
            val emoji = GameConstants.DECK_EMOJIS[deck.name] ?: "‚ùì"
            val deckString = "$emoji(${deck.cardCount})\n"
            when (deck.name) {
                GameConstants.MASTER_DECK_LIST[0], GameConstants.MASTER_DECK_LIST[1] -> column1Decks.append(deckString)
                GameConstants.MASTER_DECK_LIST[2], GameConstants.MASTER_DECK_LIST[3] -> column2Decks.append(deckString)
            }
        }

        holder.decksColumn1Text.text = column1Decks.toString().trim()
        holder.decksColumn2Text.text = column2Decks.toString().trim()

        holder.playerRecordText.text = context.getString(R.string.card_record_format, catalogue.wins, catalogue.losses)

        if (currentUserLocation != null && catalogue.latitude != null && catalogue.longitude != null) {
            val playerLocation = Location("player").apply {
                latitude = catalogue.latitude
                longitude = catalogue.longitude
            }

            val distance = currentUserLocation!!.distanceTo(playerLocation)

            if (distance < 1.0f) {
                val distanceInCm = distance * 100
                holder.playerDistanceText.text = context.getString(R.string.card_distance_format_cm, distanceInCm)
            } else {
                holder.playerDistanceText.text = context.getString(R.string.card_distance_format_m, distance)
            }
        } else {
            holder.playerDistanceText.text = "?? m"
        }

        holder.playerIcon.setColorFilter(catalogue.color, PorterDuff.Mode.SRC_IN)
        holder.itemView.setOnClickListener { onClick(endpointId) }
    }

    override fun getItemCount() = players.size
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/PlayerAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/CardSelectionDialogFragment.kt ---

package be.heyman.android.ai.kikko.clash.ui.dialogs

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.EditText
import android.widget.Spinner
import androidx.core.widget.addTextChangedListener
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.viewmodel.ClashViewModel
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.ui.adapters.KnowledgeCardAdapter
import com.google.android.material.appbar.MaterialToolbar
import kotlinx.coroutines.launch

class CardSelectionDialogFragment : DialogFragment() {

    private val viewModel: ClashViewModel by activityViewModels()
    private lateinit var adapter: KnowledgeCardAdapter
    private var isPlayerOne: Boolean = true

    // BOURDON'S FIX: Le dialog va chercher ses propres donn√©es pour l'instant.
    private val cardDao: CardDao by lazy {
        (requireActivity().application as KikkoApplication).cardDao
    }

    private lateinit var toolbar: MaterialToolbar
    private lateinit var searchEditText: EditText
    private lateinit var sortSpinner: Spinner
    private lateinit var recyclerView: RecyclerView


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        isPlayerOne = arguments?.getBoolean(ARG_IS_PLAYER_ONE) ?: true
        setStyle(STYLE_NORMAL, R.style.Theme_Kikko_FullScreenDialog)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val view = inflater.inflate(R.layout.dialog_card_selection, container, false)
        toolbar = view.findViewById(R.id.card_selection_toolbar)
        searchEditText = view.findViewById(R.id.card_selection_search_edittext)
        sortSpinner = view.findViewById(R.id.card_selection_sort_spinner)
        recyclerView = view.findViewById(R.id.card_selection_recyclerview)
        return view
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupToolbar()
        setupRecyclerView()
        loadCards() // BOURDON'S FIX: Chargement des cartes
        setupSearchAndSort()
    }

    private fun setupToolbar() {
        toolbar.setNavigationOnClickListener { dismiss() }
        toolbar.title = if (isPlayerOne) "S√©lectionnez votre Champion (Joueur 1)" else "S√©lectionnez votre Champion (Joueur 2)"
    }

    private fun setupRecyclerView() {
        adapter = KnowledgeCardAdapter { card ->
            viewModel.selectCardForClash(card, isPlayerOne)
            dismiss()
        }
        recyclerView.adapter = adapter
        recyclerView.layoutManager = GridLayoutManager(context, 3)
    }

    // BOURDON'S FIX: Nouvelle m√©thode pour charger les cartes depuis le DAO
    private fun loadCards() {
        viewLifecycleOwner.lifecycleScope.launch {
            val cards = cardDao.getAll()
            adapter.submitList(cards)
        }
    }

    private fun setupSearchAndSort() {
        searchEditText.addTextChangedListener { text ->
            // viewModel.searchCards(text.toString()) // Logique √† impl√©menter dans le ViewModel
        }

        // BOURDON'S NOTE: Il faudra cr√©er un fichier res/values/arrays.xml pour que R.array.sort_options fonctionne.
        ArrayAdapter.createFromResource(
            requireContext(),
            R.array.sort_options,
            android.R.layout.simple_spinner_item
        ).also { adapter ->
            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            sortSpinner.adapter = adapter
        }

        sortSpinner.onItemSelectedListener = object : android.widget.AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: android.widget.AdapterView<*>?, view: View?, position: Int, id: Long) {
                val sortBy = parent?.getItemAtPosition(position).toString()
                // viewModel.sortCards(sortBy) // Logique √† impl√©menter dans le ViewModel
            }

            override fun onNothingSelected(parent: android.widget.AdapterView<*>?) {
                // Rien √† faire
            }
        }
    }

    companion object {
        private const val ARG_IS_PLAYER_ONE = "is_player_one"
        const val TAG = "CardSelectionDialog"

        @JvmStatic
        fun newInstance(isPlayerOne: Boolean) =
            CardSelectionDialogFragment().apply {
                arguments = Bundle().apply {
                    putBoolean(ARG_IS_PLAYER_ONE, isPlayerOne)
                }
            }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/CardSelectionDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/ClashSetupDialogFragment.kt ---

package be.heyman.android.ai.kikko.clash.ui.dialogs

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.CheckBox
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.Spinner
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.data.Model
import com.google.android.material.slider.Slider
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.util.Locale

class ClashSetupDialogFragment : DialogFragment() {

    interface ClashSetupListener {
        fun onClashSettingsConfirmed(settings: ClashSettings)
    }

    private var listener: ClashSetupListener? = null

    private lateinit var modelSpinner: Spinner
    private lateinit var acceleratorRadioGroup: RadioGroup
    private lateinit var temperatureLabel: TextView
    private lateinit var temperatureSlider: Slider
    private lateinit var ttsSwitch: com.google.android.material.switchmaterial.SwitchMaterial
    private lateinit var dontShowAgainCheckbox: CheckBox
    private lateinit var confirmButton: Button

    private var availableModels: List<Model> = emptyList()
    private var currentSettings: ClashSettings? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = parentFragment as? ClashSetupListener ?: context as? ClashSetupListener
        if (listener == null) {
            throw ClassCastException("$context must implement ClashSetupListener")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            val modelsJson = it.getString(ARG_MODELS)
            val settingsJson = it.getString(ARG_SETTINGS)
            val gson = Gson()
            val modelListType = object : TypeToken<List<Model>>() {}.type
            availableModels = gson.fromJson(modelsJson, modelListType)
            currentSettings = gson.fromJson(settingsJson, ClashSettings::class.java)
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_clash_setup, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle("Pr√©paration au Clash")

        bindViews(view)
        setupViews()
        setupListeners()
    }

    private fun bindViews(view: View) {
        modelSpinner = view.findViewById(R.id.clash_setup_model_spinner)
        acceleratorRadioGroup = view.findViewById(R.id.clash_setup_accelerator_radiogroup)
        temperatureLabel = view.findViewById(R.id.clash_setup_temperature_label)
        temperatureSlider = view.findViewById(R.id.clash_setup_temperature_slider)
        ttsSwitch = view.findViewById(R.id.clash_setup_tts_switch)
        dontShowAgainCheckbox = view.findViewById(R.id.clash_setup_dont_show_again_checkbox)
        confirmButton = view.findViewById(R.id.clash_setup_confirm_button)
    }

    private fun setupViews() {
        // Model Spinner
        val modelNames = availableModels.map { it.name }
        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, modelNames)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        modelSpinner.adapter = adapter

        // Set initial values from currentSettings
        currentSettings?.let {
            val modelIndex = availableModels.indexOfFirst { model -> model.name == it.queenModelName }
            if (modelIndex != -1) modelSpinner.setSelection(modelIndex)

            if (it.brain == "CPU") {
                acceleratorRadioGroup.check(R.id.clash_setup_cpu_radio)
            } else {
                acceleratorRadioGroup.check(R.id.clash_setup_gpu_radio)
            }

            temperatureSlider.value = it.temperature
            temperatureLabel.text = "Temp√©rament du Juge (${String.format(Locale.US, "%.2f", it.temperature)})"

            ttsSwitch.isChecked = it.isTtsEnabled
            dontShowAgainCheckbox.isChecked = !it.showSetupOnLaunch
        }
    }

    private fun setupListeners() {
        temperatureSlider.addOnChangeListener { _, value, _ ->
            temperatureLabel.text = "Temp√©rament du Juge (${String.format(Locale.US, "%.2f", value)})"
        }

        confirmButton.setOnClickListener {
            val selectedModel = availableModels[modelSpinner.selectedItemPosition]
            val selectedAcceleratorId = acceleratorRadioGroup.checkedRadioButtonId
            val selectedAccelerator = if (selectedAcceleratorId == R.id.clash_setup_cpu_radio) "CPU" else "GPU"
            val selectedTemperature = temperatureSlider.value
            val isTtsEnabled = ttsSwitch.isChecked
            val shouldShowAgain = !dontShowAgainCheckbox.isChecked

            val newSettings = ClashSettings(
                queenModelName = selectedModel.name,
                brain = selectedAccelerator,
                temperature = selectedTemperature,
                isTtsEnabled = isTtsEnabled,
                showSetupOnLaunch = shouldShowAgain
            )

            listener?.onClashSettingsConfirmed(newSettings)
            dismiss()
        }
    }

    companion object {
        const val TAG = "ClashSetupDialog"
        private const val ARG_MODELS = "available_models"
        private const val ARG_SETTINGS = "current_settings"

        fun newInstance(availableModels: List<Model>, currentSettings: ClashSettings?): ClashSetupDialogFragment {
            val fragment = ClashSetupDialogFragment()
            val args = Bundle()
            val gson = Gson()
            args.putString(ARG_MODELS, gson.toJson(availableModels))
            args.putString(ARG_SETTINGS, gson.toJson(currentSettings))
            fragment.arguments = args
            return fragment
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/ClashSetupDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/views/RadarView.kt ---

package be.heyman.android.ai.kikko.clash.ui.views

import android.content.Context
import android.graphics.*
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.location.Location
import android.util.AttributeSet
import android.util.Log
import android.util.TypedValue
import android.view.View
import androidx.annotation.AttrRes
import androidx.appcompat.content.res.AppCompatResources
import androidx.core.graphics.drawable.toBitmap
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import kotlin.math.cos
import kotlin.math.min
import kotlin.math.sin

class RadarView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr), SensorEventListener {

    private val TAG = "RadarView"
    private val TURTLE_ICON_SIZE_DP = 36f
    private val CARDINAL_POINTS_RADIUS_OFFSET_DP = 25f
    private val DISTANCE_LABEL_VERTICAL_OFFSET_DP = 7f
    private val PLAYER_NAME_VERTICAL_OFFSET_DP = 12f

    private val turtleIconSizePx: Int
    private val cardinalPointsRadiusOffsetPx: Float
    private val distanceLabelVerticalOffsetPx: Float
    private val playerNameVerticalOffsetPx: Float

    private val playerTextPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val cardinalPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val labelPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val turtleBitmap: Bitmap

    private val sensorManager: SensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    private val accelerometerReading = FloatArray(3)
    private val magnetometerReading = FloatArray(3)
    private var smoothedAccelerometerReading = FloatArray(3)
    private var smoothedMagnetometerReading = FloatArray(3)
    private val rotationMatrix = FloatArray(9)
    private val orientationAngles = FloatArray(3)
    private var azimuth: Float = 0f
    private var players: Map<String, PlayerCatalogue> = emptyMap()
    private var userLocation: Location? = null
    private val maxDistanceMeters = 20f
    private val cardinalPoints = mapOf("N" to 0f, "E" to 90f, "S" to 180f, "O" to 270f)
    private val alpha: Float = 0.1f

    init {
        val density = context.resources.displayMetrics.density
        turtleIconSizePx = (TURTLE_ICON_SIZE_DP * density).toInt()
        cardinalPointsRadiusOffsetPx = CARDINAL_POINTS_RADIUS_OFFSET_DP * density
        distanceLabelVerticalOffsetPx = DISTANCE_LABEL_VERTICAL_OFFSET_DP * density
        playerNameVerticalOffsetPx = PLAYER_NAME_VERTICAL_OFFSET_DP * density

        val primaryColor = resolveThemeColor(com.google.android.material.R.attr.colorPrimary)
        val onSurfaceColor = resolveThemeColor(com.google.android.material.R.attr.colorOnSurface)

        playerTextPaint.color = onSurfaceColor
        playerTextPaint.textSize = 28f
        playerTextPaint.textAlign = Paint.Align.CENTER

        cardinalPaint.color = primaryColor
        cardinalPaint.textSize = 52f
        cardinalPaint.textAlign = Paint.Align.CENTER
        cardinalPaint.isFakeBoldText = true

        labelPaint.color = onSurfaceColor
        labelPaint.textSize = 30f
        labelPaint.textAlign = Paint.Align.CENTER
        labelPaint.isFakeBoldText = true

        val turtleDrawable = AppCompatResources.getDrawable(context, R.drawable.ic_turtle)
        turtleBitmap = turtleDrawable?.toBitmap(turtleIconSizePx, turtleIconSizePx, Bitmap.Config.ARGB_8888)!!
    }

    private fun resolveThemeColor(@AttrRes attr: Int): Int {
        val typedValue = TypedValue()
        context.theme.resolveAttribute(attr, typedValue, true)
        return typedValue.data
    }

    fun updatePlayers(newPlayers: Map<String, PlayerCatalogue>, currentUserLocation: Location?) {
        this.players = newPlayers
        this.userLocation = currentUserLocation
        invalidate() // Redessine la vue
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        val centerX = width / 2f
        val centerY = height / 2f
        val radius = min(centerX, centerY) * 0.55f

        // Dessin des labels de distance
        val distances = listOf(5f, 10f, 15f, 20f)
        distances.forEach { distance ->
            val circleRadius = (distance / maxDistanceMeters) * radius
            canvas.drawText(
                "${distance.toInt()}m",
                centerX,
                centerY - circleRadius + labelPaint.textSize + distanceLabelVerticalOffsetPx,
                labelPaint
            )
        }

        // Dessin des points cardinaux
        val textRadius = radius + cardinalPointsRadiusOffsetPx
        cardinalPoints.forEach { (point, angle) ->
            val angleOnRadar = (angle - Math.toDegrees(azimuth.toDouble())).toFloat()
            val angleInRad = Math.toRadians(angleOnRadar.toDouble())
            val x = centerX + (textRadius * sin(angleInRad)).toFloat()
            val y = centerY - (textRadius * cos(angleInRad)).toFloat() + (cardinalPaint.textSize / 2)
            canvas.drawText(point, x, y, cardinalPaint)
        }

        // Dessin des joueurs
        val currentUserLoc = userLocation ?: return

        for (player in players.values) {
            val lat = player.latitude
            val lon = player.longitude
            if (lat != null && lon != null) {
                val playerLocation = Location("player").apply { latitude = lat; longitude = lon }
                val distance = currentUserLoc.distanceTo(playerLocation)

                if (distance <= maxDistanceMeters) {
                    val bearing = currentUserLoc.bearingTo(playerLocation)
                    val angleOnRadar = (bearing - Math.toDegrees(azimuth.toDouble())).toFloat()
                    val angleInRad = Math.toRadians(angleOnRadar.toDouble())
                    val distanceOnRadar = (distance / maxDistanceMeters) * radius
                    val playerX = centerX + (distanceOnRadar * sin(angleInRad)).toFloat()
                    val playerY = centerY - (distanceOnRadar * cos(angleInRad)).toFloat()

                    val paint = Paint()
                    paint.colorFilter = PorterDuffColorFilter(player.color, PorterDuff.Mode.SRC_IN)
                    canvas.drawBitmap(turtleBitmap, playerX - turtleBitmap.width / 2, playerY - turtleBitmap.height / 2, paint)
                    canvas.drawText(player.playerName, playerX, playerY + turtleBitmap.height / 2 + playerNameVerticalOffsetPx, playerTextPaint)
                }
            }
        }
    }

    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
        sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        sensorManager.unregisterListener(this)
    }

    override fun onSensorChanged(event: SensorEvent) {
        if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {
            smoothedAccelerometerReading = lowPass(event.values, smoothedAccelerometerReading)
        } else if (event.sensor.type == Sensor.TYPE_MAGNETIC_FIELD) {
            smoothedMagnetometerReading = lowPass(event.values, smoothedMagnetometerReading)
        }
        updateOrientationAngles()
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}

    private fun lowPass(input: FloatArray, output: FloatArray): FloatArray {
        for (i in input.indices) {
            output[i] = output[i] + alpha * (input[i] - output[i])
        }
        return output
    }

    private fun updateOrientationAngles() {
        SensorManager.getRotationMatrix(rotationMatrix, null, smoothedAccelerometerReading, smoothedMagnetometerReading)
        SensorManager.getOrientation(rotationMatrix, orientationAngles)
        azimuth = orientationAngles[0]
        invalidate()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/views/RadarView.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashUiState.kt ---

// app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashUiState.kt

package be.heyman.android.ai.kikko.clash.viewmodel

import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.clash.data.ClashState
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import be.heyman.android.ai.kikko.clash.helpers.LocalizedQuestion
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.KnowledgeCard

enum class ClashFlowState { SETUP, DUELING, FINISHED }
enum class ClashMode { SOLO, P2P_DISCOVERING, P2P_AWAITING_SETUP, P2P_CARD_SELECTION, P2P_DUELING }

sealed class DialogState {
    data object None : DialogState()
    data object ReadyToClash : DialogState()
    data object WaitingForHost : DialogState()
}

data class ClashUiState(
    // --- FLUX GLOBAL ---
    val flowState: ClashFlowState = ClashFlowState.SETUP,
    val clashMode: ClashMode = ClashMode.SOLO,
    val errorMessage: String? = null,
    val dialogState: DialogState = DialogState.None,

    // --- CONFIGURATION ---
    val availableModels: List<Model> = emptyList(),
    // BOURDON'S DEFINITIVE FIX: Ajout du champ manquant pour le mod√®le s√©lectionn√©
    val selectedModel: Model? = null,
    val clashSettings: ClashSettings? = null,
    val isJudgeInitializing: Boolean = false,
    val myChampions: Map<String, KnowledgeCard> = emptyMap(),
    val opponentChampions: Map<String, KnowledgeCard> = emptyMap(),
    val isReadyToClash: Boolean = false,

    // BOURDON'S FIX V5: Ajout d'un set pour suivre la r√©ception des images des champions.
    val opponentChampionImagesReady: Set<String> = emptySet(), // Contient les deckNames des champions dont l'image est pr√™te.

    // --- P2P ---
    val p2pStatus: String = "Ar√®ne P2P inactive.",
    val isArbitrator: Boolean = false,
    val discoveredPlayers: Map<String, PlayerCatalogue> = emptyMap(),
    val connectedEndpointId: String? = null,
    val duelQuestions: Map<String, LocalizedQuestion> = emptyMap(),

    // --- DUEL ---
    val clashStates: List<ClashState> = emptyList(),
    val currentDuelIndex: Int = -1
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashUiState.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashViewModel.kt ---

// app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashViewModel.kt

package be.heyman.android.ai.kikko.clash.viewmodel

import android.app.Application
import android.content.Context
import android.location.Location
import android.os.ParcelFileDescriptor
import android.util.Log
import android.widget.Toast
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.clash.data.ClashState
import be.heyman.android.ai.kikko.clash.data.ClashStatus
import be.heyman.android.ai.kikko.clash.data.Deck
import be.heyman.android.ai.kikko.clash.data.P2pPayload
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import be.heyman.android.ai.kikko.forge.ForgeLlmHelper
import be.heyman.android.ai.kikko.clash.helpers.ClashPromptGenerator
import be.heyman.android.ai.kikko.TtsService
import be.heyman.android.ai.kikko.clash.services.ClashArenaService
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.persistence.CardDao
import com.google.android.gms.nearby.connection.Payload
import com.google.android.gms.nearby.connection.PayloadTransferUpdate
import com.google.gson.Gson
import com.google.gson.JsonParser
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.util.Locale

class ClashViewModel(application: Application) : AndroidViewModel(application), ClashArenaService.ClashArenaListener {

    private val cardDao: CardDao = (application as KikkoApplication).cardDao
    private val llmHelper: ForgeLlmHelper = (application as KikkoApplication).forgeLlmHelper
    private val arenaService: ClashArenaService = (application as KikkoApplication).clashArenaService

    private val TAG = "ClashViewModel"
    private val gson = Gson()

    private val _uiState = MutableStateFlow(ClashUiState())
    val uiState = _uiState.asStateFlow()

    private val _p2pEvent = MutableSharedFlow<P2pEvent>()
    val p2pEvent = _p2pEvent.asSharedFlow()
    sealed class P2pEvent {
        data class ShowConnectionDialog(val endpointId: String, val opponentName: String, val authCode: String) : P2pEvent()
    }

    private var inferenceJob: Job? = null
    private var judgeInitializationJob: Job? = null
    private val pendingImageTransfers = mutableMapOf<Long, KnowledgeCard>()
    private var allCardsCache: List<KnowledgeCard> = emptyList()

    init {
        arenaService.setListener(this)
        TtsService.initialize(getApplication())
        ClashPromptGenerator.loadClashQuestions(getApplication())
        loadInitialData()
    }

    private fun loadInitialData() {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                allCardsCache = cardDao.getAll()
            }
            loadAvailableModelsAndInitializeJudge()
        }
    }

    suspend fun getCardsForDeck(deckName: String): List<KnowledgeCard> {
        return withContext(Dispatchers.Default) {
            allCardsCache.filter { it.deckName == deckName }
        }
    }

    fun selectCardForClash(card: KnowledgeCard, isPlayerOne: Boolean) {
        val deckName = card.deckName
        handleChampionSelection(deckName, card, if (isPlayerOne) 1 else 2)
    }

    fun handleChampionSelection(deckName: String, card: KnowledgeCard, playerIndex: Int = 1) {
        if (_uiState.value.clashMode != ClashMode.SOLO && playerIndex == 1) {
            sendCardSelectionToOpponent(deckName, card)
        }

        _uiState.update { currentState ->
            val updatedChampions = if (playerIndex == 1) {
                currentState.myChampions.toMutableMap()
            } else {
                currentState.opponentChampions.toMutableMap()
            }
            updatedChampions[deckName] = card

            if (playerIndex == 1) {
                currentState.copy(myChampions = updatedChampions)
            } else {
                currentState.copy(opponentChampions = updatedChampions)
            }
        }
        checkReadyState()
    }

    private fun sendCardSelectionToOpponent(deckName: String, card: KnowledgeCard) {
        _uiState.value.connectedEndpointId?.let { endpointId ->
            var imagePayloadId: Long? = null
            card.imagePath?.let { path ->
                val imageFile = File(path)
                if (imageFile.exists()) {
                    val filePayload = Payload.fromFile(imageFile)
                    imagePayloadId = filePayload.id
                    Log.i(TAG, "[P2P SEND] Envoi du payload image pour '${card.specificName}' (Payload ID: ${filePayload.id}) vers $endpointId")
                    arenaService.sendPayload(endpointId, filePayload)
                }
            }
            val lightweightCard = card.copy(imagePath = null)
            val metadataPayload = P2pPayload.CardSelectionPayload(deckName, lightweightCard, imagePayloadId)
            val payloadJson = gson.toJson(metadataPayload)
            Log.i(TAG, "[P2P SEND] Envoi du payload de m√©tadonn√©es pour '${card.specificName}' (associ√© √† l'image ID: $imagePayloadId) vers $endpointId")
            arenaService.sendPayload(endpointId, payloadJson)
        }
    }

    fun startP2PDiscovery(myLocation: Location?) {
        viewModelScope.launch {
            _uiState.update { it.copy(clashMode = ClashMode.P2P_DISCOVERING, discoveredPlayers = emptyMap()) }
            val myCatalogue = withContext(Dispatchers.IO) {
                val decks = allCardsCache.groupBy { it.deckName }.map { (deckName, cards) -> Deck(deckName, cards.size) }
                val defaultPlayerName = getApplication<Application>().getString(R.string.p2p_default_player_name, (100..999).random())
                PlayerCatalogue(defaultPlayerName, decks, myLocation?.latitude, myLocation?.longitude, 15, 4)
            }
            arenaService.startAdvertising(myCatalogue)
            arenaService.startDiscovery()
        }
    }

    fun stopP2P() {
        arenaService.stopAllEndpoints()
        _uiState.update { it.copy(
            clashMode = ClashMode.SOLO, isArbitrator = false, discoveredPlayers = emptyMap(),
            connectedEndpointId = null, p2pStatus = getApplication<Application>().getString(R.string.p2p_status_inactive)
        )}
    }

    fun connectToPlayer(endpointId: String) {
        _uiState.update { it.copy(isArbitrator = true) }
        arenaService.requestConnection(endpointId)
    }

    fun acceptConnection(endpointId: String) {
        if (!_uiState.value.isArbitrator) {
            _uiState.update { it.copy(isArbitrator = false) }
        }
        arenaService.acceptConnection(endpointId)
    }

    fun rejectConnection(endpointId: String) {
        arenaService.rejectConnection(endpointId)
    }

    override fun onStatusUpdate(message: String) {
        _uiState.update { it.copy(p2pStatus = message) }
    }

    override fun onEndpointFound(endpointId: String, catalogue: PlayerCatalogue) {
        _uiState.update {
            val updatedPlayers = it.discoveredPlayers.toMutableMap().apply { put(endpointId, catalogue) }
            it.copy(discoveredPlayers = updatedPlayers)
        }
    }

    override fun onEndpointLost(endpointId: String) {
        _uiState.update {
            val updatedPlayers = it.discoveredPlayers.toMutableMap().apply { remove(endpointId) }
            it.copy(discoveredPlayers = updatedPlayers)
        }
    }

    override fun onConnectionInitiated(endpointId: String, opponentName: String, authDigits: String) {
        viewModelScope.launch { _p2pEvent.emit(P2pEvent.ShowConnectionDialog(endpointId, opponentName, authDigits)) }
    }

    override fun onConnectionResult(endpointId: String, isSuccess: Boolean) {
        if (isSuccess) {
            _uiState.update { it.copy(
                discoveredPlayers = emptyMap(),
                clashMode = ClashMode.P2P_CARD_SELECTION,
                connectedEndpointId = endpointId,
                p2pStatus = getApplication<Application>().getString(R.string.p2p_status_connected)
            )}
        } else {
            _uiState.update { it.copy(
                p2pStatus = getApplication<Application>().getString(R.string.p2p_status_connection_failed),
                clashMode = ClashMode.P2P_DISCOVERING,
                isArbitrator = false)
            }
        }
    }

    override fun onDisconnected(endpointId: String) {
        _uiState.update { it.copy(
            connectedEndpointId = null,
            p2pStatus = getApplication<Application>().getString(R.string.p2p_status_disconnected),
            clashMode = ClashMode.SOLO)
        }
    }

    override fun onPayloadReceived(endpointId: String, payloadString: String) {
        try {
            val jsonObject = JsonParser.parseString(payloadString).asJsonObject
            when {
                jsonObject.has("selectedCard") -> handleCardSelectionPayload(payloadString)
                jsonObject.has("question") -> handleQuestionPayload(payloadString)
                jsonObject.has("winner") -> handleDuelResultPayload(payloadString)
                jsonObject.has("command") -> {
                    val command = jsonObject.get("command").asString
                    Log.i(TAG, "[P2P RECV] Commande '$command' re√ßue de $endpointId.")
                    when (command) {
                        "START_CLASH" -> startDuels()
                        "NEXT_DUEL" -> proceedToNextDuel()
                        "PREVIOUS_DUEL" -> proceedToPreviousDuel()
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erreur de d√©s√©rialisation du payload", e)
        }
    }

    override fun onFilePayloadReceived(endpointId: String, payload: Payload) {
        Log.i(TAG, "[P2P RECV] Fichier complet re√ßu (Payload ID: ${payload.id}). Traitement de l'image...")
        val cardToUpdate = pendingImageTransfers.remove(payload.id)
        if (cardToUpdate != null) {
            processAndSaveImage(payload, cardToUpdate)
        } else {
            Log.w(TAG, "[P2P RECV] Fichier re√ßu (Payload ID: ${payload.id}) mais aucune carte en attente trouv√©e.")
        }
    }

    override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
        if (update.status == PayloadTransferUpdate.Status.FAILURE || update.status == PayloadTransferUpdate.Status.CANCELED) {
            Log.e(TAG, "[P2P RECV] Echec du transfert pour le payload ID ${update.payloadId}. Annulation de l'attente.")
            pendingImageTransfers.remove(update.payloadId)
            checkReadyState()
        }
    }

    private fun handleCardSelectionPayload(payloadString: String) {
        val payload = gson.fromJson(payloadString, P2pPayload.CardSelectionPayload::class.java)
        if (payload.imagePayloadId != null) {
            Log.i(TAG, "[P2P RECV] M√©tadonn√©es re√ßues pour '${payload.selectedCard.specificName}'. En attente de l'image (Payload ID: ${payload.imagePayloadId}).")
            pendingImageTransfers[payload.imagePayloadId] = payload.selectedCard
        } else {
            Log.i(TAG, "[P2P RECV] M√©tadonn√©es re√ßues pour '${payload.selectedCard.specificName}'. Aucune image associ√©e.")
        }
        _uiState.update { it.copy(opponentChampions = it.opponentChampions.toMutableMap().apply { set(payload.deckName, payload.selectedCard) }) }
        checkReadyState()
    }

    private fun processAndSaveImage(filePayload: Payload, card: KnowledgeCard) {
        viewModelScope.launch(Dispatchers.IO) {
            val pfd: ParcelFileDescriptor? = filePayload.asFile()?.asParcelFileDescriptor()
            if (pfd != null) {
                val inputStream = FileInputStream(pfd.fileDescriptor)
                val destDir = File(getApplication<Application>().filesDir, "clash_images")
                if (!destDir.exists()) destDir.mkdirs()
                val newFile = File(destDir, "clash_${card.id}_${System.currentTimeMillis()}.png")
                try {
                    FileOutputStream(newFile).use { it.write(inputStream.readBytes()) }
                    Log.i(TAG, "[P2P RECV] Image pour '${card.specificName}' sauvegard√©e vers : ${newFile.absolutePath}")
                } finally {
                    inputStream.close()
                    pfd.close()
                }
                val updatedCard = card.copy(imagePath = newFile.absolutePath)
                withContext(Dispatchers.Main) {
                    _uiState.update { state ->
                        val key = state.opponentChampions.entries.find { it.value.id == card.id }?.key
                        state.copy(opponentChampions = state.opponentChampions.toMutableMap().apply { if(key!=null) set(key, updatedCard) })
                    }
                    checkReadyState()
                }
            }
        }
    }

    private fun checkReadyState() {
        _uiState.update { currentState ->
            val isReady = currentState.myChampions.size == GameConstants.MASTER_DECK_LIST.size &&
                    currentState.opponentChampions.size == GameConstants.MASTER_DECK_LIST.size

            var newDialogState = currentState.dialogState
            if (currentState.clashMode != ClashMode.SOLO) {
                val allImagesReady = pendingImageTransfers.isEmpty()
                if (isReady && allImagesReady) {
                    Log.i(TAG, "[P2P STATUS] Toutes les cartes et images sont pr√™tes. Mode: ${if (currentState.isArbitrator) "H√¥te" else "Invit√©"}")
                }
                if(isReady && allImagesReady && currentState.dialogState == DialogState.None) {
                    newDialogState = if (currentState.isArbitrator) DialogState.ReadyToClash else DialogState.WaitingForHost
                } else if (!isReady || !allImagesReady) {
                    newDialogState = DialogState.None
                }
            }
            currentState.copy(isReadyToClash = isReady, dialogState = newDialogState)
        }
    }

    fun dismissDialog() {
        _uiState.update { it.copy(dialogState = DialogState.None) }
    }

    fun confirmAndStartP2pClash() {
        _uiState.value.connectedEndpointId?.let {
            if (_uiState.value.isArbitrator) {
                arenaService.sendPayload(it, gson.toJson(P2pPayload.StartClashPayload()))
            }
        }
        startDuels()
    }

    fun confirmSetupAndStartSoloClash() {
        if (!_uiState.value.isReadyToClash) return
        if (_uiState.value.isJudgeInitializing) {
            _uiState.update { it.copy(errorMessage = getApplication<Application>().getString(R.string.judge_awakening_please_wait)) }
            return
        }
        _uiState.update { it.copy(clashMode = ClashMode.SOLO) }
        startDuels()
    }

    private fun startDuels() {
        viewModelScope.launch {
            judgeInitializationJob?.join()
            if (_uiState.value.errorMessage != null) {
                return@launch
            }

            _uiState.update { currentState ->
                val duelStates = GameConstants.MASTER_DECK_LIST.mapNotNull { deck ->
                    val p1 = currentState.myChampions[deck]
                    val p2 = currentState.opponentChampions[deck]
                    if (p1 != null && p2 != null) ClashState(deck, p1, p2) else null
                }
                currentState.copy(flowState = ClashFlowState.DUELING, clashStates = duelStates, currentDuelIndex = 0, dialogState = DialogState.None)
            }
        }
    }

    fun runInferenceForCurrentDuel() {
        if (!_uiState.value.isArbitrator && _uiState.value.clashMode != ClashMode.SOLO) return
        inferenceJob?.cancel()
        val clashIndex = _uiState.value.currentDuelIndex.takeIf { it != -1 } ?: return
        val clashState = _uiState.value.clashStates.getOrNull(clashIndex)?.takeIf { it.status == ClashStatus.PENDING } ?: return

        inferenceJob = viewModelScope.launch(Dispatchers.IO) {
            val settings = _uiState.value.clashSettings ?: return@launch
            val questionSet = ClashPromptGenerator.getRandomClashQuestionSet(clashState.deckName)!!

            withContext(Dispatchers.Main) {
                updateClashState(clashIndex) { it.copy(status = ClashStatus.INFERRING, question = ClashPromptGenerator.getLocalizedQuestion(questionSet)) }
                _uiState.value.connectedEndpointId?.let {
                    arenaService.sendPayload(it, gson.toJson(P2pPayload.QuestionPayload(clashState.deckName, questionSet)))
                }
            }

            try {
                llmHelper.resetSession(
                    model = _uiState.value.selectedModel!!,
                    isMultimodal = false,
                    temperature = settings.temperature,
                    topK = 40
                )
                val prompt = ClashPromptGenerator.generateClashVerdictPrompt(ClashPromptGenerator.getLocalizedQuestion(questionSet), clashState.player1Card, clashState.player2Card)
                Log.d(TAG, "[PROMPT ENVOY√â AU JUGE]:\n$prompt")
                val responseBuilder = StringBuilder()

                llmHelper.runInference(prompt, emptyList()) { partial, done ->
                    responseBuilder.append(partial)

                    viewModelScope.launch(Dispatchers.Main) {
                        updateClashState(clashIndex) { it.copy(streamingReasoning = responseBuilder.toString()) }
                    }

                    if (done) {
                        val rawResponse = responseBuilder.toString()
                        Log.d(TAG, "[R√âPONSE BRUTE DU JUGE]:\n$rawResponse")
                        val (winner, reasoning, ttsScript) = parseVerdict(rawResponse)

                        viewModelScope.launch(Dispatchers.Main) {
                            updateClashState(clashIndex) { it.copy(winner = winner, rawReasoning = reasoning, translatedReasoning = reasoning, ttsScript = ttsScript, status = ClashStatus.COMPLETED, streamingReasoning = null) }
                            _uiState.value.connectedEndpointId?.let {
                                val resultPayload = P2pPayload.DuelResultPayload(clashState.deckName, winner, reasoning, ttsScript)
                                arenaService.sendPayload(it, gson.toJson(resultPayload))
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    val errorMessage = e.message ?: getApplication<Application>().getString(R.string.inference_error_generic)
                    updateClashState(clashIndex) { it.copy(status = ClashStatus.ERROR, errorMessage = errorMessage) }
                }
            }
        }
    }

    private fun handleQuestionPayload(payloadString: String) {
        val payload = gson.fromJson(payloadString, P2pPayload.QuestionPayload::class.java)
        val duelIndex = _uiState.value.clashStates.indexOfFirst { it.deckName == payload.deckName }
        if (duelIndex != -1) updateClashState(duelIndex) { it.copy(question = ClashPromptGenerator.getLocalizedQuestion(payload.question), status = ClashStatus.INFERRING) }
    }

    private fun handleDuelResultPayload(payloadString: String) {
        val payload = gson.fromJson(payloadString, P2pPayload.DuelResultPayload::class.java)
        val duelIndex = _uiState.value.clashStates.indexOfFirst { it.deckName == payload.deckName }
        if (duelIndex != -1) {
            val winner = when(payload.winner) { "player1" -> "player2"; "player2" -> "player1"; else -> "tie" }
            updateClashState(duelIndex) { it.copy(winner = winner, rawReasoning = payload.reasoning, translatedReasoning = payload.reasoning, ttsScript = payload.ttsScript, status = ClashStatus.COMPLETED) }
        }
    }

    private suspend fun loadAvailableModelsAndInitializeJudge() {
        withContext(Dispatchers.IO) {
            val modelsDir = File(getApplication<Application>().filesDir, "imported_models")
            val modelFiles = modelsDir.listFiles { _, name -> name.endsWith(".task") } ?: emptyArray()
            val llmModels = modelFiles.map { Model(name = it.name, downloadFileName = it.name, url = it.absolutePath, sizeInBytes = it.length(), imported = true, llmSupportImage = it.name.contains("gemma-3n", ignoreCase = true)) }.sortedBy { it.name }

            withContext(Dispatchers.Main) {
                val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                val savedModelName = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null)
                val savedAccelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!

                val currentSettings = _uiState.value.clashSettings ?: ClashSettings(
                    queenModelName = savedModelName ?: llmModels.firstOrNull()?.name ?: "",
                    brain = savedAccelerator
                )
                _uiState.update { it.copy(
                    availableModels = llmModels,
                    clashSettings = currentSettings,
                    selectedModel = llmModels.find { m -> m.name == currentSettings.queenModelName }
                )}

                initializeJudge()
            }
        }
    }

    fun updateClashSettings(settings: ClashSettings) {
        val oldSettings = _uiState.value.clashSettings
        if (settings != oldSettings) {
            _uiState.update { it.copy(
                clashSettings = settings,
                selectedModel = it.availableModels.find { m -> m.name == settings.queenModelName }
            ) }
            judgeInitializationJob?.cancel()
            judgeInitializationJob = null
            viewModelScope.launch {
                withContext(Dispatchers.IO) { llmHelper.cleanUp() }
                initializeJudge()
            }
        }
    }

    private fun initializeJudge() {
        if (judgeInitializationJob != null) return

        val settings = _uiState.value.clashSettings ?: return
        val model = _uiState.value.selectedModel ?: run {
            _uiState.update { it.copy(errorMessage = getApplication<Application>().getString(R.string.error_no_model_selected)) }
            return
        }

        _uiState.update { it.copy(isJudgeInitializing = true) }
        judgeInitializationJob = viewModelScope.launch {
            Log.i(TAG, "Lancement de l'initialisation du Juge IA pour le Clash...")
            val error = withContext(Dispatchers.IO) {
                llmHelper.initialize(model, settings.brain, isMultimodal = false)
            }
            if (error == null) {
                Log.i(TAG, "Initialisation du Juge IA termin√©e avec succ√®s pour le Clash.")
                withContext(Dispatchers.Main) {
                    Toast.makeText(getApplication(), getApplication<Application>().getString(R.string.judge_ready_toast, model.name), Toast.LENGTH_SHORT).show()
                }
                _uiState.update { it.copy(isJudgeInitializing = false) }
            } else {
                Log.e(TAG, "√âchec de l'initialisation du Juge IA: $error")
                _uiState.update { it.copy(isJudgeInitializing = false, errorMessage = getApplication<Application>().getString(R.string.judge_error_toast, error)) }
            }
        }
    }

    fun generateRandomTeams() {
        viewModelScope.launch(Dispatchers.IO) {
            val p1Champions = mutableMapOf<String, KnowledgeCard>()
            val p2Champions = mutableMapOf<String, KnowledgeCard>()
            var errorDeck = ""
            for (deckName in GameConstants.MASTER_DECK_LIST) {
                val cardsInDeck = allCardsCache.filter { it.deckName == deckName }
                if (cardsInDeck.size < 2) { errorDeck = deckName; break }
                val shuffled = cardsInDeck.shuffled()
                p1Champions[deckName] = shuffled[0]
                p2Champions[deckName] = shuffled[1]
            }
            withContext(Dispatchers.Main) {
                if (errorDeck.isNotEmpty()) {
                    _uiState.update { it.copy(errorMessage = getApplication<Application>().getString(R.string.error_not_enough_cards_in_deck, errorDeck)) }
                } else {
                    _uiState.update { it.copy(myChampions = p1Champions, opponentChampions = p2Champions) }
                    checkReadyState()
                }
            }
        }
    }

    fun onDuelSelected(index: Int) {
        if (index != _uiState.value.currentDuelIndex) _uiState.update { it.copy(currentDuelIndex = index) }
    }

    fun proceedToPreviousDuel() {
        if (_uiState.value.isArbitrator || _uiState.value.clashMode == ClashMode.SOLO) {
            _uiState.value.connectedEndpointId?.let { endpointId ->
                val payloadJson = gson.toJson(mapOf("command" to "PREVIOUS_DUEL"))
                Log.i(TAG, "[P2P SEND] Envoi de la commande PREVIOUS_DUEL vers $endpointId")
                arenaService.sendPayload(endpointId, payloadJson)
            }
        }

        val previousIndex = _uiState.value.currentDuelIndex - 1
        if (previousIndex >= 0) {
            _uiState.update { it.copy(currentDuelIndex = previousIndex) }
        }
    }

    fun proceedToNextDuel() {
        if(_uiState.value.isArbitrator || _uiState.value.clashMode == ClashMode.SOLO) {
            _uiState.value.connectedEndpointId?.let { endpointId ->
                val payloadJson = gson.toJson(P2pPayload.NextDuelPayload())
                Log.i(TAG, "[P2P SEND] Envoi de la commande NEXT_DUEL vers $endpointId")
                arenaService.sendPayload(endpointId, payloadJson)
            }
        }
        val nextIndex = _uiState.value.currentDuelIndex + 1
        if (nextIndex < _uiState.value.clashStates.size) {
            _uiState.update { it.copy(currentDuelIndex = nextIndex) }
        } else {
            _uiState.update { it.copy(flowState = ClashFlowState.FINISHED) }
        }
    }

    private fun parseVerdict(rawResponse: String): Triple<String, String, String> {
        return try {
            val cleanJson = rawResponse.substringAfter("{").substringBeforeLast("}")
            val jsonObject = JsonParser.parseString("{$cleanJson}").asJsonObject
            val winner = jsonObject.get("winner")?.asString ?: "tie"
            val reasoning = jsonObject.get("reasoning")?.asString ?: getApplication<Application>().getString(R.string.verdict_parse_reasoning_fallback)
            val ttsScript = jsonObject.get("tts_script")?.asString ?: getApplication<Application>().getString(R.string.verdict_parse_tts_fallback_script)
            Triple(winner, reasoning, ttsScript)
        } catch (e: Exception) {
            Log.e(TAG, "Erreur de parsing du verdict: '$rawResponse'", e)
            Triple("tie", getApplication<Application>().getString(R.string.verdict_parse_error_reasoning), getApplication<Application>().getString(R.string.verdict_parse_error_tts))
        }
    }

    private fun updateClashState(index: Int, updateAction: (ClashState) -> ClashState) {
        _uiState.update { currentState ->
            val updatedClashes = currentState.clashStates.toMutableList()
            if (index in updatedClashes.indices) updatedClashes[index] = updateAction(updatedClashes[index])
            currentState.copy(clashStates = updatedClashes)
        }
    }

    fun requestTtsForQuestion(clashIndex: Int, autoPlay: Boolean = false) {
        val clash = uiState.value.clashStates.getOrNull(clashIndex) ?: return
        val settings = uiState.value.clashSettings
        val questionToSpeak = clash.question

        if (!questionToSpeak.isNullOrBlank() && (settings?.isTtsEnabled == true || !autoPlay) && !clash.ttsQuestionHasBeenPlayed) {
            TtsService.speak(questionToSpeak, Locale.getDefault())
            updateClashState(clashIndex) { it.copy(ttsQuestionHasBeenPlayed = true) }
        }
    }

    fun requestTtsForReasoning(clashIndex: Int, autoPlay: Boolean = false) {
        val clash = uiState.value.clashStates.getOrNull(clashIndex) ?: return
        val settings = uiState.value.clashSettings

        if (!clash.ttsHasBeenPlayed) {
            val scriptToSpeak = clash.ttsScript
            if (clash.status == ClashStatus.COMPLETED && !scriptToSpeak.isNullOrBlank() && (settings?.isTtsEnabled == true || !autoPlay)) {
                TtsService.speak(scriptToSpeak, Locale.getDefault())
                updateClashState(clashIndex) { it.copy(ttsHasBeenPlayed = true) }
            }
        }
    }

    fun clearErrorMessage() {
        _uiState.update { it.copy(errorMessage = null) }
    }

    override fun onCleared() {
        super.onCleared()
        arenaService.stopAllEndpoints()
        llmHelper.cleanUp()
        TtsService.shutdown()
        inferenceJob?.cancel()
        judgeInitializationJob?.cancel()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Types.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.common

import androidx.compose.ui.graphics.Color

interface LatencyProvider {
  val latencyMs: Float
}

data class Classification(val label: String, val score: Float, val color: Color)

data class JsonObjAndTextContent<T>(val jsonObj: T, val textContent: String)

class AudioClip(val audioData: ByteArray, val sampleRate: Int)


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Types.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Utils.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.common

import android.content.Context
import android.net.Uri
import android.util.Log
import be.heyman.android.ai.kikko.data.SAMPLE_RATE
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File
import java.net.HttpURLConnection
import java.net.URL
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.floor

data class LaunchInfo(val ts: Long)

private const val TAG = "AGUtils"
private const val LAUNCH_INFO_FILE_NAME = "launch_info"
private const val START_THINKING = "***Thinking...***"
private const val DONE_THINKING = "***Done thinking***"



fun cleanUpMediapipeTaskErrorMessage(message: String): String {
  val index = message.indexOf("=== Source Location Trace")
  if (index >= 0) {
    return message.substring(0, index)
  }
  return message
}

fun processLlmResponse(response: String): String {
  // Add "thinking" and "done thinking" around the thinking content.
  var newContent =
    response.replace("<think>", "$START_THINKING\n").replace("</think>", "\n$DONE_THINKING")

  // Remove empty thinking content.
  val endThinkingIndex = newContent.indexOf(DONE_THINKING)
  if (endThinkingIndex >= 0) {
    val thinkingContent =
      newContent
        .substring(0, endThinkingIndex + DONE_THINKING.length)
        .replace(START_THINKING, "")
        .replace(DONE_THINKING, "")
    if (thinkingContent.isBlank()) {
      newContent = newContent.substring(endThinkingIndex + DONE_THINKING.length)
    }
  }

  newContent = newContent.replace("\\n", "\n")

  return newContent
}

fun writeLaunchInfo(context: Context) {
  try {
    val gson = Gson()
    val launchInfo = LaunchInfo(ts = System.currentTimeMillis())
    val jsonString = gson.toJson(launchInfo)
    val file = File(context.getExternalFilesDir(null), LAUNCH_INFO_FILE_NAME)
    file.writeText(jsonString)
  } catch (e: Exception) {
    Log.e(TAG, "Failed to write launch info", e)
  }
}

inline fun <reified T> getJsonResponse(url: String): JsonObjAndTextContent<T>? {
  try {
    val connection = URL(url).openConnection() as HttpURLConnection
    connection.requestMethod = "GET"
    connection.connect()

    val responseCode = connection.responseCode
    if (responseCode == HttpURLConnection.HTTP_OK) {
      val inputStream = connection.inputStream
      val response = inputStream.bufferedReader().use { it.readText() }

      val gson = Gson()
      val type = object : TypeToken<T>() {}.type
      val jsonObj = gson.fromJson<T>(response, type)
      return JsonObjAndTextContent(jsonObj = jsonObj, textContent = response)
    } else {
      Log.e("AGUtils", "HTTP error: $responseCode")
    }
  } catch (e: Exception) {
    Log.e("AGUtils", "Error when getting json response: ${e.message}")
    e.printStackTrace()
  }

  return null
}

fun convertWavToMonoWithMaxSeconds(
  context: Context,
  stereoUri: Uri,
  maxSeconds: Int = 30,
): AudioClip? {
  Log.d(TAG, "Start to convert wav file to mono channel")

  try {
    val inputStream = context.contentResolver.openInputStream(stereoUri) ?: return null
    val originalBytes = inputStream.readBytes()
    inputStream.close()

    // Read WAV header
    if (originalBytes.size < 44) {
      // Not a valid WAV file
      Log.e(TAG, "Not a valid wav file")
      return null
    }

    val headerBuffer = ByteBuffer.wrap(originalBytes, 0, 44).order(ByteOrder.LITTLE_ENDIAN)
    val channels = headerBuffer.getShort(22)
    var sampleRate = headerBuffer.getInt(24)
    val bitDepth = headerBuffer.getShort(34)
    Log.d(TAG, "File metadata: channels: $channels, sampleRate: $sampleRate, bitDepth: $bitDepth")

    // Normalize audio to 16-bit.
    val audioDataBytes = originalBytes.copyOfRange(fromIndex = 44, toIndex = originalBytes.size)
    var sixteenBitBytes: ByteArray =
      if (bitDepth.toInt() == 8) {
        Log.d(TAG, "Converting 8-bit audio to 16-bit.")
        convert8BitTo16Bit(audioDataBytes)
      } else {
        // Assume 16-bit or other format that can be handled directly
        audioDataBytes
      }

    // Convert byte array to short array for processing
    val shortBuffer =
      ByteBuffer.wrap(sixteenBitBytes).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer()
    var pcmSamples = ShortArray(shortBuffer.remaining())
    shortBuffer.get(pcmSamples)

    // Resample if sample rate is less than 16000 Hz ---
    if (sampleRate < SAMPLE_RATE) {
      Log.d(TAG, "Resampling from $sampleRate Hz to $SAMPLE_RATE Hz.")
      pcmSamples = resample(pcmSamples, sampleRate, SAMPLE_RATE, channels.toInt())
      sampleRate = SAMPLE_RATE
      Log.d(TAG, "Resampling complete. New sample count: ${pcmSamples.size}")
    }

    // Convert stereo to mono if necessary
    var monoSamples =
      if (channels.toInt() == 2) {
        Log.d(TAG, "Converting stereo to mono.")
        val mono = ShortArray(pcmSamples.size / 2)
        for (i in mono.indices) {
          val left = pcmSamples[i * 2]
          val right = pcmSamples[i * 2 + 1]
          mono[i] = ((left + right) / 2).toShort()
        }
        mono
      } else {
        Log.d(TAG, "Audio is already mono. No channel conversion needed.")
        pcmSamples
      }

    // Trim the audio to maxSeconds ---
    val maxSamples = maxSeconds * sampleRate
    if (monoSamples.size > maxSamples) {
      Log.d(TAG, "Trimming clip from ${monoSamples.size} samples to $maxSamples samples.")
      monoSamples = monoSamples.copyOfRange(0, maxSamples)
    }

    val monoByteBuffer = ByteBuffer.allocate(monoSamples.size * 2).order(ByteOrder.LITTLE_ENDIAN)
    monoByteBuffer.asShortBuffer().put(monoSamples)
    return AudioClip(audioData = monoByteBuffer.array(), sampleRate = sampleRate)
  } catch (e: Exception) {
    Log.e(TAG, "Failed to convert wav to mono", e)
    return null
  }
}

/** Converts 8-bit unsigned PCM audio data to 16-bit signed PCM. */
private fun convert8BitTo16Bit(eightBitData: ByteArray): ByteArray {
  // The new 16-bit data will be twice the size
  val sixteenBitData = ByteArray(eightBitData.size * 2)
  val buffer = ByteBuffer.wrap(sixteenBitData).order(ByteOrder.LITTLE_ENDIAN)

  for (byte in eightBitData) {
    // Convert the unsigned 8-bit byte (0-255) to a signed 16-bit short (-32768 to 32767)
    // 1. Get the unsigned value by masking with 0xFF
    // 2. Subtract 128 to center the waveform around 0 (range becomes -128 to 127)
    // 3. Scale by 256 to expand to the 16-bit range
    val unsignedByte = byte.toInt() and 0xFF
    val sixteenBitSample = ((unsignedByte - 128) * 256).toShort()
    buffer.putShort(sixteenBitSample)
  }
  return sixteenBitData
}

/** Resamples PCM audio data from an original sample rate to a target sample rate. */
private fun resample(
  inputSamples: ShortArray,
  originalSampleRate: Int,
  targetSampleRate: Int,
  channels: Int,
): ShortArray {
  if (originalSampleRate == targetSampleRate) {
    return inputSamples
  }

  val ratio = targetSampleRate.toDouble() / originalSampleRate
  val outputLength = (inputSamples.size * ratio).toInt()
  val resampledData = ShortArray(outputLength)

  if (channels == 1) { // Mono
    for (i in resampledData.indices) {
      val position = i / ratio
      val index1 = floor(position).toInt()
      val index2 = index1 + 1
      val fraction = position - index1

      val sample1 = if (index1 < inputSamples.size) inputSamples[index1].toDouble() else 0.0
      val sample2 = if (index2 < inputSamples.size) inputSamples[index2].toDouble() else 0.0

      resampledData[i] = (sample1 * (1 - fraction) + sample2 * fraction).toInt().toShort()
    }
  }

  return resampledData
}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Utils.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Config.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

import kotlin.math.abs

/**
 * The types of configuration editors available.
 *
 * This enum defines the different UI components used to edit configuration values. Each type
 * corresponds to a specific editor widget, such as a slider or a switch.
 */
enum class ConfigEditorType {
  LABEL,
  NUMBER_SLIDER,
  BOOLEAN_SWITCH,
  DROPDOWN,
}

/** The data types of configuration values. */
enum class ValueType {
  INT,
  FLOAT,
  DOUBLE,
  STRING,
  BOOLEAN,
}

enum class ConfigKey(val label: String) {
  MAX_TOKENS("Max tokens"),
  TOPK("TopK"),
  TOPP("TopP"),
  TEMPERATURE("Temperature"),
  DEFAULT_MAX_TOKENS("Default max tokens"),
  DEFAULT_TOPK("Default TopK"),
  DEFAULT_TOPP("Default TopP"),
  DEFAULT_TEMPERATURE("Default temperature"),
  SUPPORT_IMAGE("Support image"),
  SUPPORT_AUDIO("Support audio"),
  MAX_RESULT_COUNT("Max result count"),
  USE_GPU("Use GPU"),
  ACCELERATOR("Choose accelerator"),
  COMPATIBLE_ACCELERATORS("Compatible accelerators"),
  WARM_UP_ITERATIONS("Warm up iterations"),
  BENCHMARK_ITERATIONS("Benchmark iterations"),
  ITERATIONS("Iterations"),
  THEME("Theme"),
  NAME("Name"),
  MODEL_TYPE("Model type"),
}

/**
 * Base class for configuration settings.
 *
 * @param type The type of configuration editor.
 * @param key The unique key for the configuration setting.
 * @param defaultValue The default value for the configuration setting.
 * @param valueType The data type of the configuration value.
 * @param needReinitialization Indicates whether the model needs to be reinitialized after changing
 *   this config.
 */
open class Config(
  val type: ConfigEditorType,
  open val key: ConfigKey,
  open val defaultValue: Any,
  open val valueType: ValueType,
  open val needReinitialization: Boolean = true,
)

/** Configuration setting for a label. */
class LabelConfig(override val key: ConfigKey, override val defaultValue: String = "") :
  Config(
    type = ConfigEditorType.LABEL,
    key = key,
    defaultValue = defaultValue,
    valueType = ValueType.STRING,
  )

/**
 * Configuration setting for a number slider.
 *
 * @param sliderMin The minimum value of the slider.
 * @param sliderMax The maximum value of the slider.
 */
class NumberSliderConfig(
  override val key: ConfigKey,
  val sliderMin: Float,
  val sliderMax: Float,
  override val defaultValue: Float,
  override val valueType: ValueType,
  override val needReinitialization: Boolean = true,
) :
  Config(
    type = ConfigEditorType.NUMBER_SLIDER,
    key = key,
    defaultValue = defaultValue,
    valueType = valueType,
  )

/** Configuration setting for a boolean switch. */
class BooleanSwitchConfig(
  override val key: ConfigKey,
  override val defaultValue: Boolean,
  override val needReinitialization: Boolean = true,
) :
  Config(
    type = ConfigEditorType.BOOLEAN_SWITCH,
    key = key,
    defaultValue = defaultValue,
    valueType = ValueType.BOOLEAN,
  )

/** Configuration setting for a dropdown. */
class SegmentedButtonConfig(
  override val key: ConfigKey,
  override val defaultValue: String,
  val options: List<String>,
  val allowMultiple: Boolean = false,
) :
  Config(
    type = ConfigEditorType.DROPDOWN,
    key = key,
    defaultValue = defaultValue,
    // The emitted value will be comma-separated labels when allowMultiple=true.
    valueType = ValueType.STRING,
  )

fun convertValueToTargetType(value: Any, valueType: ValueType): Any {
  return when (valueType) {
    ValueType.INT ->
      when (value) {
        is Int -> value
        is Float -> value.toInt()
        is Double -> value.toInt()
        is String -> value.toIntOrNull() ?: ""
        is Boolean -> if (value) 1 else 0
        else -> ""
      }

    ValueType.FLOAT ->
      when (value) {
        is Int -> value.toFloat()
        is Float -> value
        is Double -> value.toFloat()
        is String -> value.toFloatOrNull() ?: ""
        is Boolean -> if (value) 1f else 0f
        else -> ""
      }

    ValueType.DOUBLE ->
      when (value) {
        is Int -> value.toDouble()
        is Float -> value.toDouble()
        is Double -> value
        is String -> value.toDoubleOrNull() ?: ""
        is Boolean -> if (value) 1.0 else 0.0
        else -> ""
      }

    ValueType.BOOLEAN ->
      when (value) {
        is Int -> value == 0
        is Boolean -> value
        is Float -> abs(value) > 1e-6
        is Double -> abs(value) > 1e-6
        is String -> value.isNotEmpty()
        else -> false
      }

    ValueType.STRING -> value.toString()
  }
}

fun createLlmChatConfigs(
  defaultMaxToken: Int = DEFAULT_MAX_TOKEN,
  defaultTopK: Int = DEFAULT_TOPK,
  defaultTopP: Float = DEFAULT_TOPP,
  defaultTemperature: Float = DEFAULT_TEMPERATURE,
  accelerators: List<Accelerator> = DEFAULT_ACCELERATORS,
): List<Config> {
  return listOf(
    LabelConfig(key = ConfigKey.MAX_TOKENS, defaultValue = "$defaultMaxToken"),
    NumberSliderConfig(
      key = ConfigKey.TOPK,
      sliderMin = 5f,
      sliderMax = 100f,
      defaultValue = defaultTopK.toFloat(),
      valueType = ValueType.INT,
    ),
    NumberSliderConfig(
      key = ConfigKey.TOPP,
      sliderMin = 0.0f,
      sliderMax = 1.0f,
      defaultValue = defaultTopP,
      valueType = ValueType.FLOAT,
    ),
    NumberSliderConfig(
      key = ConfigKey.TEMPERATURE,
      sliderMin = 0.0f,
      sliderMax = 2.0f,
      defaultValue = defaultTemperature,
      valueType = ValueType.FLOAT,
    ),
    SegmentedButtonConfig(
      key = ConfigKey.ACCELERATOR,
      defaultValue = accelerators[0].label,
      options = accelerators.map { it.label },
    ),
  )
}

fun getConfigValueString(value: Any, config: Config): String {
  var strNewValue = "$value"
  if (config.valueType == ValueType.FLOAT) {
    strNewValue = "%.2f".format(value)
  }
  return strNewValue
}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Config.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Consts.kt ---

package be.heyman.android.ai.kikko.data

// Keys used to send/receive data to Work.
const val KEY_MODEL_URL = "KEY_MODEL_URL"
const val KEY_MODEL_NAME = "KEY_MODEL_NAME"
const val KEY_MODEL_VERSION = "KEY_MODEL_VERSION"
const val KEY_MODEL_DOWNLOAD_MODEL_DIR = "KEY_MODEL_DOWNLOAD_MODEL_DIR"
const val KEY_MODEL_DOWNLOAD_FILE_NAME = "KEY_MODEL_DOWNLOAD_FILE_NAME"
const val KEY_MODEL_TOTAL_BYTES = "KEY_MODEL_TOTAL_BYTES"
const val KEY_MODEL_DOWNLOAD_RECEIVED_BYTES = "KEY_MODEL_DOWNLOAD_RECEIVED_BYTES"
const val KEY_MODEL_DOWNLOAD_RATE = "KEY_MODEL_DOWNLOAD_RATE"
const val KEY_MODEL_DOWNLOAD_REMAINING_MS = "KEY_MODEL_DOWNLOAD_REMAINING_SECONDS"
const val KEY_MODEL_DOWNLOAD_ERROR_MESSAGE = "KEY_MODEL_DOWNLOAD_ERROR_MESSAGE"
const val KEY_MODEL_DOWNLOAD_ACCESS_TOKEN = "KEY_MODEL_DOWNLOAD_ACCESS_TOKEN"
const val KEY_MODEL_DOWNLOAD_APP_TS = "KEY_MODEL_DOWNLOAD_APP_TS"
const val KEY_MODEL_EXTRA_DATA_URLS = "KEY_MODEL_EXTRA_DATA_URLS"
const val KEY_MODEL_EXTRA_DATA_DOWNLOAD_FILE_NAMES = "KEY_MODEL_EXTRA_DATA_DOWNLOAD_FILE_NAMES"
const val KEY_MODEL_IS_ZIP = "KEY_MODEL_IS_ZIP"
const val KEY_MODEL_UNZIPPED_DIR = "KEY_MODEL_UNZIPPED_DIR"
const val KEY_MODEL_START_UNZIPPING = "KEY_MODEL_START_UNZIPPING"

// Default values for LLM models.
const val DEFAULT_MAX_TOKEN = 1024
const val DEFAULT_TOPK = 40
const val DEFAULT_TOPP = 0.9f
const val DEFAULT_TEMPERATURE = 1.0f
val DEFAULT_ACCELERATORS = listOf(Accelerator.GPU)

// Max number of images allowed in a "ask image" session.
const val MAX_IMAGE_COUNT = 10

// Max number of audio clip in an "ask audio" session.
const val MAX_AUDIO_CLIP_COUNT = 1

// Max audio clip duration in seconds.
const val MAX_AUDIO_CLIP_DURATION_SEC = 30

// Audio-recording related consts.
const val SAMPLE_RATE = 16000

// BOURDON'S FIX: Constantes de d√©bogage qui sont maintenant utilis√©es dans l'application principale.
const val DEFAULT_MAX_TOKENS_DEBUG = 2048

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Consts.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Model.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

import android.content.Context
import java.io.File

data class ModelDataFile(
  val name: String,
  val url: String,
  val downloadFileName: String,
  val sizeInBytes: Long,
)

const val IMPORTS_DIR = "__imports"
private val NORMALIZE_NAME_REGEX = Regex("[^a-zA-Z0-9]")

data class PromptTemplate(val title: String, val description: String, val prompt: String)

/** A model for a task */
data class Model(
  /** The name (for display purpose) of the model. */
  val name: String,

  /** The version of the model. */
  val version: String = "_",

  /**
   * The name of the downloaded model file.
   *
   * The final file path of the downloaded model will be:
   * {context.getExternalFilesDir}/{normalizedName}/{version}/{downloadFileName}
   */
  val downloadFileName: String,

  /** The URL to download the model from. */
  val url: String,

  /** The size of the model file in bytes. */
  val sizeInBytes: Long,

  /** A list of additional data files required by the model. */
  val extraDataFiles: List<ModelDataFile> = listOf(),

  /**
   * A description or information about the model.
   *
   * Will be shown at the start of the chat session and in the expanded model item.
   */
  val info: String = "",

  /** The url to jump to when clicking "learn more" in expanded model item. */
  val learnMoreUrl: String = "",

  /** A list of configurable parameters for the model. */
  val configs: List<Config> = listOf(),

  /** Whether to show the "run again" button in the UI. */
  val showRunAgainButton: Boolean = true,

  /** Whether to show the "benchmark" button in the UI. */
  val showBenchmarkButton: Boolean = true,

  /** Indicates whether the model is a zip file. */
  val isZip: Boolean = false,

  /** The name of the directory to unzip the model to (if it's a zip file). */
  val unzipDir: String = "",

  /** The prompt templates for the model (only for LLM). */
  val llmPromptTemplates: List<PromptTemplate> = listOf(),

  /** Whether the LLM model supports image input. */
  val llmSupportImage: Boolean = false,

  /** Whether the LLM model supports audio input. */
  val llmSupportAudio: Boolean = false,

  /** Whether the model is imported or not. */
  val imported: Boolean = false,

  // The following fields are managed by the app. Don't need to set manually.
  var normalizedName: String = "",
  var instance: Any? = null,
  var initializing: Boolean = false,
  // TODO(jingjin): use a "queue" system to manage model init and cleanup.
  var cleanUpAfterInit: Boolean = false,
  var configValues: Map<String, Any> = mapOf(),
  var totalBytes: Long = 0L,
  var accessToken: String? = null,

  /** The estimated peak memory in byte to run the model. */
  val estimatedPeakMemoryInBytes: Long? = null,
) {
  init {
    normalizedName = NORMALIZE_NAME_REGEX.replace(name, "_")
  }

  fun preProcess() {
    val configValues: MutableMap<String, Any> = mutableMapOf()
    for (config in this.configs) {
      configValues[config.key.label] = config.defaultValue
    }
    this.configValues = configValues
    this.totalBytes = this.sizeInBytes + this.extraDataFiles.sumOf { it.sizeInBytes }
  }

  fun getPath(context: Context, fileName: String = downloadFileName): String {
    if (imported) {
      return listOf(context.getExternalFilesDir(null)?.absolutePath ?: "", fileName)
        .joinToString(File.separator)
    }

    val baseDir =
      listOf(context.getExternalFilesDir(null)?.absolutePath ?: "", normalizedName, version)
        .joinToString(File.separator)
    return if (this.isZip && this.unzipDir.isNotEmpty()) {
      "$baseDir/${this.unzipDir}"
    } else {
      "$baseDir/$fileName"
    }
  }

  fun getIntConfigValue(key: ConfigKey, defaultValue: Int = 0): Int {
    return getTypedConfigValue(key = key, valueType = ValueType.INT, defaultValue = defaultValue)
      as Int
  }

  fun getFloatConfigValue(key: ConfigKey, defaultValue: Float = 0.0f): Float {
    return getTypedConfigValue(key = key, valueType = ValueType.FLOAT, defaultValue = defaultValue)
      as Float
  }

  fun getBooleanConfigValue(key: ConfigKey, defaultValue: Boolean = false): Boolean {
    return getTypedConfigValue(
      key = key,
      valueType = ValueType.BOOLEAN,
      defaultValue = defaultValue,
    )
      as Boolean
  }

  fun getStringConfigValue(key: ConfigKey, defaultValue: String = ""): String {
    return getTypedConfigValue(key = key, valueType = ValueType.STRING, defaultValue = defaultValue)
      as String
  }

  fun getExtraDataFile(name: String): ModelDataFile? {
    return extraDataFiles.find { it.name == name }
  }

  private fun getTypedConfigValue(key: ConfigKey, valueType: ValueType, defaultValue: Any): Any {
    return convertValueToTargetType(
      value = configValues.getOrDefault(key.label, defaultValue),
      valueType = valueType,
    )
  }
}

enum class ModelDownloadStatusType {
  NOT_DOWNLOADED,
  PARTIALLY_DOWNLOADED,
  IN_PROGRESS,
  UNZIPPING,
  SUCCEEDED,
  FAILED,
}

data class ModelDownloadStatus(
  val status: ModelDownloadStatusType,
  val totalBytes: Long = 0,
  val receivedBytes: Long = 0,
  val errorMessage: String = "",
  val bytesPerSecond: Long = 0,
  val remainingMs: Long = 0,
)

////////////////////////////////////////////////////////////////////////////////////////////////////
// Configs.

val MOBILENET_CONFIGS: List<Config> =
  listOf(
    NumberSliderConfig(
      key = ConfigKey.MAX_RESULT_COUNT,
      sliderMin = 1f,
      sliderMax = 5f,
      defaultValue = 3f,
      valueType = ValueType.INT,
    ),
    BooleanSwitchConfig(key = ConfigKey.USE_GPU, defaultValue = false),
  )

val IMAGE_GENERATION_CONFIGS: List<Config> =
  listOf(
    NumberSliderConfig(
      key = ConfigKey.ITERATIONS,
      sliderMin = 5f,
      sliderMax = 50f,
      defaultValue = 10f,
      valueType = ValueType.INT,
      needReinitialization = false,
    )
  )

const val TEXT_CLASSIFICATION_INFO =
  "Model is trained on movie reviews dataset. Type a movie review below and see the scores of positive or negative sentiment."

const val TEXT_CLASSIFICATION_LEARN_MORE_URL =
  "https://ai.google.dev/edge/mediapipe/solutions/text/text_classifier"

const val IMAGE_CLASSIFICATION_INFO = ""

const val IMAGE_CLASSIFICATION_LEARN_MORE_URL = "https://ai.google.dev/edge/litert/android"

const val IMAGE_GENERATION_INFO =
  "Powered by [MediaPipe Image Generation API](https://ai.google.dev/edge/mediapipe/solutions/vision/image_generator/android)"

val MODEL_TEXT_CLASSIFICATION_MOBILEBERT: Model =
  Model(
    name = "MobileBert",
    downloadFileName = "bert_classifier.tflite",
    url =
      "https://storage.googleapis.com/mediapipe-models/text_classifier/bert_classifier/float32/latest/bert_classifier.tflite",
    sizeInBytes = 25707538L,
    info = TEXT_CLASSIFICATION_INFO,
    learnMoreUrl = TEXT_CLASSIFICATION_LEARN_MORE_URL,
  )

val MODEL_TEXT_CLASSIFICATION_AVERAGE_WORD_EMBEDDING: Model =
  Model(
    name = "Average word embedding",
    downloadFileName = "average_word_classifier.tflite",
    url =
      "https://storage.googleapis.com/mediapipe-models/text_classifier/average_word_classifier/float32/latest/average_word_classifier.tflite",
    sizeInBytes = 775708L,
    info = TEXT_CLASSIFICATION_INFO,
  )

val MODEL_IMAGE_CLASSIFICATION_MOBILENET_V1: Model =
  Model(
    name = "Mobilenet V1",
    downloadFileName = "mobilenet_v1.tflite",
    url = "https://storage.googleapis.com/tfweb/app_gallery_models/mobilenet_v1.tflite",
    sizeInBytes = 16900760L,
    extraDataFiles =
      listOf(
        ModelDataFile(
          name = "labels",
          url =
            "https://raw.githubusercontent.com/leferrad/tensorflow-mobilenet/refs/heads/master/imagenet/labels.txt",
          downloadFileName = "mobilenet_labels_v1.txt",
          sizeInBytes = 21685L,
        )
      ),
    configs = MOBILENET_CONFIGS,
    info = IMAGE_CLASSIFICATION_INFO,
    learnMoreUrl = IMAGE_CLASSIFICATION_LEARN_MORE_URL,
  )

val MODEL_IMAGE_CLASSIFICATION_MOBILENET_V2: Model =
  Model(
    name = "Mobilenet V2",
    downloadFileName = "mobilenet_v2.tflite",
    url = "https://storage.googleapis.com/tfweb/app_gallery_models/mobilenet_v2.tflite",
    sizeInBytes = 13978596L,
    extraDataFiles =
      listOf(
        ModelDataFile(
          name = "labels",
          url =
            "https://raw.githubusercontent.com/leferrad/tensorflow-mobilenet/refs/heads/master/imagenet/labels.txt",
          downloadFileName = "mobilenet_labels_v2.txt",
          sizeInBytes = 21685L,
        )
      ),
    configs = MOBILENET_CONFIGS,
    info = IMAGE_CLASSIFICATION_INFO,
  )

val MODEL_IMAGE_GENERATION_STABLE_DIFFUSION: Model =
  Model(
    name = "Stable diffusion",
    downloadFileName = "sd15.zip",
    isZip = true,
    unzipDir = "sd15",
    url = "https://storage.googleapis.com/tfweb/app_gallery_models/sd15.zip",
    sizeInBytes = 1906219565L,
    showRunAgainButton = false,
    showBenchmarkButton = false,
    info = IMAGE_GENERATION_INFO,
    configs = IMAGE_GENERATION_CONFIGS,
    learnMoreUrl = "https://huggingface.co/litert-community",
  )

val EMPTY_MODEL: Model =
  Model(name = "empty", downloadFileName = "empty.tflite", url = "", sizeInBytes = 0L)

////////////////////////////////////////////////////////////////////////////////////////////////////
// Model collections for different tasks.

val MODELS_TEXT_CLASSIFICATION: MutableList<Model> =
  mutableListOf(
    MODEL_TEXT_CLASSIFICATION_MOBILEBERT,
    MODEL_TEXT_CLASSIFICATION_AVERAGE_WORD_EMBEDDING,
  )

val MODELS_IMAGE_CLASSIFICATION: MutableList<Model> =
  mutableListOf(MODEL_IMAGE_CLASSIFICATION_MOBILENET_V1, MODEL_IMAGE_CLASSIFICATION_MOBILENET_V2)

val MODELS_IMAGE_GENERATION: MutableList<Model> =
  mutableListOf(MODEL_IMAGE_GENERATION_STABLE_DIFFUSION)


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Model.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/ModelCatalogue.kt ---

package be.heyman.android.ai.kikko.data

import be.heyman.android.ai.kikko.data.ConfigKey

/**
 * Catalogue des mod√®les LLM et Vosk disponibles pour l'application.
 * Ces mod√®les peuvent √™tre t√©l√©charg√©s par l'utilisateur via la bo√Æte √† outils.
 * Initialement dans le package `debug`, il est d√©plac√© ici car ses informations
 * sont utilis√©es par des fonctionnalit√©s principales (ex: ToolsDialogFragment).
 */
object ModelCatalogue {

    val allModels: List<Model> = listOf(
        Model(
            name = "Gemma 3n E2B (kikko.be - zip)",
            downloadFileName = "gemma-3n-E2B-it-int4.task.zip",
            url = "https://www.kikko.be/model/gemma-3n-E2B-it-int4.task.zip",
            sizeInBytes = 2450829619,
            isZip = true,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3n E2B (.task direct)",
            downloadFileName = "gemma-3n-E2B-it-int4.task",
            url = "https://www.kikko.be/model/gemma-3n-E2B-it-int4.task",
            sizeInBytes = 3136226711,
            isZip = false,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3n E4B (kikko.be - zip)",
            downloadFileName = "gemma-3n-E4B-it-int4.task.zip",
            url = "https://www.kikko.be/model/gemma-3n-E4B-it-int4.task.zip",
            sizeInBytes = 3513918248,
            isZip = true,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3n E4B (.task direct)",
            downloadFileName = "gemma-3n-E4B-it-int4.task",
            url = "https://www.kikko.be/model/gemma-3n-E4B-it-int4.task",
            sizeInBytes = 4405655031,
            isZip = false,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3 1B (kikko.be)",
            downloadFileName = "gemma3-1B-it-int4.task.zip",
            url = "https://www.kikko.be/model/gemma3-1B-it-int4.task.zip",
            sizeInBytes = 392700000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Qwen 2.5 1.8B Chat (kikko.be)",
            downloadFileName = "Qwen2.5-1.5B-Instruct_multi-prefill-seq_q8_ekv1280.task.zip",
            url = "https://www.kikko.be/model/Qwen2.5-1.5B-Instruct_multi-prefill-seq_q8_ekv1280.task.zip",
            sizeInBytes = 1380000000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "Hammer 2.1 - 1.5B (kikko.be)",
            downloadFileName = "hammer2.1_1.5b_q8_ekv4096.task.zip",
            url = "https://www.kikko.be/model/hammer2.1_1.5b_q8_ekv4096.task.zip",
            sizeInBytes = 1380000000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "Hammer 2.1 - 0.5B (kikko.be)",
            downloadFileName = "hammer2p1_05b_.task",
            url = "https://www.kikko.be/model/hammer2p1_05b_.task",
            sizeInBytes = 1380000000,
            isZip = false,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "DeepSeek (kikko.be) Zip",
            downloadFileName = "deepseek_q8_ekv1280.task.zip",
            url = "https://www.kikko.be/model/deepseek_q8_ekv1280.task.zip",
            sizeInBytes = 1560000000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "DeepSeek (kikko.be) task",
            downloadFileName = "deepseek_q8_ekv1280.task",
            url = "https://www.kikko.be/model/deepseek_q8_ekv1280.task",
            sizeInBytes = 1860000000,
            isZip = false,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "Vosk Small French (kikko.be)",
            downloadFileName = "vosk-model-small-fr-0.22.zip",
            url = "https://www.kikko.be/model/vosk-model-small-fr-0.22.zip",
            sizeInBytes = 42233323,
            isZip = true,
            unzipDir = "vosk-model-small-fr-0.22"
        ),
        Model(
            name = "Vosk Small English (kikko.be)",
            downloadFileName = "vosk-model-small-en-us-0.15.zip",
            url = "https://www.kikko.be/model/vosk-model-small-en-us-0.15.zip",
            sizeInBytes = 41205931,
            isZip = true,
            unzipDir = "vosk-model-small-en-us-0.15"
        ),
        Model(
            name = "Vosk Small Japanese (kikko.be)",
            downloadFileName = "vosk-model-small-ja-0.22.zip",
            url = "https://www.kikko.be/model/vosk-model-small-ja-0.22.zip",
            sizeInBytes = 49704573,
            isZip = true,
            unzipDir = "vosk-model-small-ja-0.22"
        )
    )
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/ModelCatalogue.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Types.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

enum class Accelerator(val label: String) {
  CPU(label = "CPU"),
  GPU(label = "GPU"),
}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Types.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/CardDetailsDialogFragment.kt ---

package be.heyman.android.ai.kikko.deck

import android.content.Context
import android.graphics.BitmapFactory
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.royal_audience.RoyalAudienceActivity
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.chip.Chip
import java.io.File
import java.util.Locale

class CardDetailsDialogFragment : DialogFragment() {

    interface CardDetailsListener {
        fun onDeleteCard(card: KnowledgeCard)
        fun onLaunchQuiz(card: KnowledgeCard)
        fun onTranslateCard(card: KnowledgeCard)
    }

    private var listener: CardDetailsListener? = null
    private lateinit var card: KnowledgeCard

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = parentFragment as? CardDetailsListener ?: context as? CardDetailsListener
        if (listener == null) {
            android.util.Log.w("CardDetailsDialog", "$context must implement CardDetailsListener to handle actions.")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NORMAL, R.style.Theme_Kikko_FullScreenDialog)
        arguments?.let {
            @Suppress("DEPRECATION")
            card = it.getParcelable(ARG_CARD)!!
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.dialog_card_details, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val imageView: ImageView = view.findViewById(R.id.card_details_image)
        val specificNameTextView: TextView = view.findViewById(R.id.card_details_specific_name)
        val deckNameChip: Chip = view.findViewById(R.id.card_details_deck_name)
        val confidenceTextView: TextView = view.findViewById(R.id.card_details_confidence)
        val descriptionTextView: TextView = view.findViewById(R.id.card_details_description)
        val reasoningTextView: TextView = view.findViewById(R.id.card_details_reasoning)
        val statsTextView: TextView = view.findViewById(R.id.card_details_stats)
        val deleteButton: Button = view.findViewById(R.id.card_details_button_delete)
        val quizButton: Button = view.findViewById(R.id.card_details_button_quiz)
        val chatButton: Button = view.findViewById(R.id.card_details_button_chat)
        val translateButton: Button = view.findViewById(R.id.card_details_button_translate)

        val deviceLang = Locale.getDefault().language
        val translatedContent = card.translations?.get(deviceLang)

        val displayedName = card.specificName
        val displayedDescription = translatedContent?.description ?: card.description
        val displayedReasoning = translatedContent?.reasoning ?: card.reasoning
        val displayedQuiz = translatedContent?.quiz ?: card.quiz


        card.imagePath?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                val bitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                imageView.setImageBitmap(bitmap)
            }
        }

        specificNameTextView.text = displayedName
        deckNameChip.text = card.deckName
        confidenceTextView.text = getString(R.string.card_details_confidence_format, card.confidence)
        descriptionTextView.text = displayedDescription

        reasoningTextView.text = getString(
            R.string.card_details_reasoning_format,
            displayedReasoning.visualAnalysis,
            displayedReasoning.evidenceCorrelation
        )

        val statsText = card.stats?.items?.map { (key, value) ->
            "${key.replaceFirstChar { it.titlecase() }}: $value"
        }?.joinToString("\n") ?: getString(R.string.card_details_no_stats_available)
        statsTextView.text = statsText

        deleteButton.setOnClickListener {
            listener?.onDeleteCard(card)
            dismiss()
        }

        quizButton.setOnClickListener {
            listener?.onLaunchQuiz(card)
            dismiss()
        }
        // Le bouton de quiz est d√©sactiv√© via le layout et ne sera pas r√©activ√© ici
        // quizButton.isEnabled = !displayedQuiz.isNullOrEmpty()

        chatButton.setOnClickListener {
            val intent = RoyalAudienceActivity.newIntent(requireContext(), card.id)
            startActivity(intent)
            dismiss()
        }

        translateButton.setOnClickListener {
            listener?.onTranslateCard(card)
            dismiss()
        }
        // Le bouton de traduction est d√©sactiv√© via le layout et ne sera pas r√©activ√© ici.
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        private const val ARG_CARD = "card"

        fun newInstance(card: KnowledgeCard): CardDetailsDialogFragment {
            val fragment = CardDetailsDialogFragment()
            val args = Bundle()
            args.putParcelable(ARG_CARD, card)
            fragment.arguments = args
            return fragment
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/CardDetailsDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckCardAdapter.kt ---

package be.heyman.android.ai.kikko.deck

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import java.io.File

/**
 * BOURDON'S REFACTOR V3:
 * L'adaptateur utilise maintenant le layout correct `item_clash_deck_thumbnail.xml`
 * pour une pr√©sentation en grille √©l√©gante et compacte.
 *
 * @param onCardClicked Une fonction lambda appel√©e lorsqu'une carte est cliqu√©e.
 */
class DeckCardAdapter(
    private var cards: List<KnowledgeCard>,
    private val onCardClicked: (KnowledgeCard) -> Unit
) : RecyclerView.Adapter<DeckCardAdapter.CardViewHolder>() {

    /**
     * ViewHolder d√©di√© qui contient les vues pour la vignette de champion.
     */
    class CardViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        // BOURDON'S FIX: Les IDs sont maintenant ceux de `item_clash_deck_thumbnail.xml`
        val cardNameView: TextView = view.findViewById(R.id.card_thumbnail_name)
        val cardImageView: ImageView = view.findViewById(R.id.card_thumbnail_image)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CardViewHolder {
        // BOURDON'S FIX: Utilisation du nouveau layout correct.
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_clash_deck_thumbnail, parent, false)
        return CardViewHolder(view)
    }

    override fun onBindViewHolder(holder: CardViewHolder, position: Int) {
        val card = cards[position]
        holder.cardNameView.text = card.specificName

        card.imagePath?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                val myBitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                holder.cardImageView.setImageBitmap(myBitmap)
            } else {
                holder.cardImageView.setImageResource(R.drawable.ic_placeholder_card)
            }
        } ?: holder.cardImageView.setImageResource(R.drawable.ic_placeholder_card)

        holder.itemView.setOnClickListener {
            onCardClicked(card)
        }
    }

    override fun getItemCount(): Int = cards.size

    /**
     * Met √† jour la liste des cartes affich√©es par l'adaptateur et notifie le changement.
     */
    fun updateCards(newCards: List<KnowledgeCard>) {
        this.cards = newCards
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckCardAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPageFragment.kt ---

package be.heyman.android.ai.kikko.deck

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
// BOURDON'S FIX: L'import a √©t√© corrig√© pour pointer vers le package 'deck' au lieu de 'debug'.
import be.heyman.android.ai.kikko.deck.CardDetailsDialogFragment
import be.heyman.android.ai.kikko.model.KnowledgeCard

/**
 * Un Fragment qui affiche une grille de KnowledgeCards pour un seul deck.
 */
class DeckPageFragment : Fragment() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var deckCardAdapter: DeckCardAdapter
    private var cards: ArrayList<KnowledgeCard>? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // R√©cup√®re les cartes pass√©es en argument lors de la cr√©ation du fragment.
        arguments?.let {
            @Suppress("DEPRECATION")
            cards = it.getParcelableArrayList(ARG_CARDS)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate le layout pour ce fragment.
        return inflater.inflate(R.layout.fragment_deck_page, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        recyclerView = view.findViewById(R.id.deck_page_recyclerview)
        setupRecyclerView()
    }

    private fun setupRecyclerView() {
        // Initialise l'adaptateur avec la liste de cartes (ou une liste vide).
        deckCardAdapter = DeckCardAdapter(cards ?: emptyList()) { card ->
            // Affiche le dialogue des d√©tails de la carte lorsqu'une carte est cliqu√©e.
            CardDetailsDialogFragment.newInstance(card).show(parentFragmentManager, "CardDetailsDialog")
        }
        recyclerView.apply {
            // Utilise un GridLayoutManager pour afficher les cartes en grille de 2 colonnes.
            layoutManager = GridLayoutManager(context, 2)
            adapter = deckCardAdapter
        }
    }

    companion object {
        private const val ARG_CARDS = "cards_for_deck"

        /**
         * M√©thode factory pour cr√©er une nouvelle instance de ce fragment
         * avec une liste sp√©cifique de cartes.
         *
         * @param cards La liste des cartes √† afficher.
         * @return Une nouvelle instance de DeckPageFragment.
         */
        @JvmStatic
        fun newInstance(cards: List<KnowledgeCard>) =
            DeckPageFragment().apply {
                arguments = Bundle().apply {
                    // Les objets personnalis√©s doivent √™tre Parcelable pour √™tre pass√©s dans un Bundle.
                    putParcelableArrayList(ARG_CARDS, ArrayList(cards))
                }
            }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPageFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPagerAdapter.kt ---

package be.heyman.android.ai.kikko.deck

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import be.heyman.android.ai.kikko.model.KnowledgeCard

/**
 * Un adaptateur qui fournit des fragments (DeckPageFragment) pour chaque deck de cartes
 * √† un ViewPager2.
 *
 * @param fa L'activit√© h√¥te du fragment.
 * @param decks La map contenant les decks, o√π la cl√© est le nom du deck et la valeur est la liste des cartes.
 */
class DeckPagerAdapter(fa: FragmentActivity, private val decks: Map<String, List<KnowledgeCard>>) : FragmentStateAdapter(fa) {

    // Cr√©e une liste des noms de decks pour un acc√®s par indice.
    private val deckNames = decks.keys.toList()

    /**
     * Retourne le nombre total de decks (et donc de pages).
     */
    override fun getItemCount(): Int {
        return decks.size
    }

    /**
     * Cr√©e et retourne un DeckPageFragment pour la position donn√©e.
     */
    override fun createFragment(position: Int): Fragment {
        val deckName = deckNames[position]
        val cardsForDeck = decks[deckName] ?: emptyList()
        // Utilise la m√©thode factory du fragment pour lui passer la liste de cartes.
        return DeckPageFragment.newInstance(cardsForDeck)
    }

    /**
     * Retourne le titre du deck pour l'onglet √† la position donn√©e.
     */
    fun getPageTitle(position: Int): CharSequence {
        return deckNames[position]
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPagerAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerActivity.kt ---

package be.heyman.android.ai.kikko.deck

import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.view.View
import android.view.WindowInsets
import android.view.WindowInsetsController
import android.widget.LinearLayout
import android.widget.Toast
import android.widget.VideoView
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.quiz.QuizActivity
import kotlinx.coroutines.launch

class DeckViewerActivity : AppCompatActivity(), CardDetailsDialogFragment.CardDetailsListener {

    private val viewModel: DeckViewerViewModel by lazy {
        ViewModelProvider(this, ViewModelProvider.AndroidViewModelFactory(application))
            .get(DeckViewerViewModel::class.java)
    }

    private lateinit var backgroundVideoView: VideoView
    private lateinit var recyclerView: RecyclerView
    private lateinit var deckCardAdapter: DeckCardAdapter

    private lateinit var deckButtonFood: LinearLayout
    private lateinit var deckButtonPlant: LinearLayout
    private lateinit var deckButtonInsect: LinearLayout
    private lateinit var deckButtonBird: LinearLayout
    private lateinit var deckButtons: Map<String, View>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_deck_viewer)
        hideSystemUI()

        bindViews()
        setupBackgroundVideo()
        setupRecyclerView()
        setupDeckSelectionListeners()
        observeViewModel()
    }

    override fun onResume() {
        super.onResume()
        backgroundVideoView.start()
    }

    override fun onPause() {
        super.onPause()
        backgroundVideoView.stopPlayback()
    }

    private fun hideSystemUI() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            window.insetsController?.let {
                it.hide(WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars())
                it.systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
            }
        } else {
            @Suppress("DEPRECATION")
            window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_FULLSCREEN)
        }
    }

    private fun bindViews() {
        backgroundVideoView = findViewById(R.id.background_video_view)
        recyclerView = findViewById(R.id.deck_cards_recyclerview)
        deckButtonFood = findViewById(R.id.deck_button_food)
        deckButtonPlant = findViewById(R.id.deck_button_plant)
        deckButtonInsect = findViewById(R.id.deck_button_insect)
        deckButtonBird = findViewById(R.id.deck_button_bird)

        deckButtons = mapOf(
            GameConstants.MASTER_DECK_LIST[0] to deckButtonFood,
            GameConstants.MASTER_DECK_LIST[1] to deckButtonPlant,
            GameConstants.MASTER_DECK_LIST[2] to deckButtonInsect,
            GameConstants.MASTER_DECK_LIST[3] to deckButtonBird
        )
    }

    private fun setupBackgroundVideo() {
        val videoPath = "android.resource://" + packageName + "/" + R.raw.kikko_deck
        val uri = Uri.parse(videoPath)
        backgroundVideoView.setVideoURI(uri)
        backgroundVideoView.setOnPreparedListener { mediaPlayer ->
            mediaPlayer.isLooping = true
            mediaPlayer.setVolume(0f, 0f)
            mediaPlayer.start()
        }
    }

    private fun setupRecyclerView() {
        deckCardAdapter = DeckCardAdapter(emptyList()) { card ->
            CardDetailsDialogFragment.newInstance(card).show(supportFragmentManager, "CardDetailsDialog")
        }
        recyclerView.apply {
            layoutManager = GridLayoutManager(this@DeckViewerActivity, 3)
            adapter = deckCardAdapter
        }
    }

    private fun setupDeckSelectionListeners() {
        deckButtons.forEach { (deckName, buttonView) ->
            buttonView.setOnClickListener {
                viewModel.selectDeck(deckName)
            }
        }
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    if (state.isLoading) {
                        // Optionnel : G√©rer l'√©tat de chargement
                    } else {
                        deckCardAdapter.updateCards(state.filteredCards)
                        updateSelectedDeckButton(state.selectedDeck)
                    }
                }
            }
        }
    }

    private fun updateSelectedDeckButton(selectedDeckName: String) {
        deckButtons.forEach { (deckName, buttonView) ->
            if (deckName == selectedDeckName) {
                buttonView.setBackgroundColor(ContextCompat.getColor(this, R.color.kikko_gold_light))
                buttonView.alpha = 1.0f
            } else {
                buttonView.setBackgroundColor(ContextCompat.getColor(this, android.R.color.transparent))
                buttonView.alpha = 0.7f
            }
        }
    }

    override fun onDeleteCard(card: KnowledgeCard) {
        viewModel.deleteCard(card)
        Toast.makeText(this, getString(R.string.card_deleted_toast, card.specificName), Toast.LENGTH_SHORT).show()
    }

    override fun onLaunchQuiz(card: KnowledgeCard) {
        val intent = QuizActivity.newIntent(this, card)
        startActivity(intent)
    }

    override fun onTranslateCard(card: KnowledgeCard) {
        viewModel.requestTranslation(card)
        Toast.makeText(this, getString(R.string.translation_requested_toast, card.specificName), Toast.LENGTH_LONG).show()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerViewModel.kt ---

package be.heyman.android.ai.kikko.deck

import android.app.Application
import android.content.Context
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.Constraints
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import be.heyman.android.ai.kikko.worker.ForgeWorker
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

data class DeckUiState(
    val isLoading: Boolean = true,
    val allCards: Map<String, List<KnowledgeCard>> = emptyMap(),
    val selectedDeck: String = GameConstants.MASTER_DECK_LIST.first(),
    val filteredCards: List<KnowledgeCard> = emptyList()
)

class DeckViewerViewModel(application: Application) : AndroidViewModel(application) {

    private val cardDao: CardDao = (application as KikkoApplication).cardDao
    private val pollenGrainDao: PollenGrainDao = (application as KikkoApplication).pollenGrainDao
    private val workManager = WorkManager.getInstance(application)

    private val _uiState = MutableStateFlow(DeckUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadAllDecks()
    }

    fun selectDeck(deckName: String) {
        _uiState.update { currentState ->
            currentState.copy(
                selectedDeck = deckName,
                filteredCards = currentState.allCards[deckName] ?: emptyList()
            )
        }
    }

    fun deleteCard(card: KnowledgeCard) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                cardDao.delete(card)
            }
            loadAllDecks()
        }
    }

    fun requestTranslation(card: KnowledgeCard) {
        viewModelScope.launch(Dispatchers.IO) {
            val pollenGrain = pollenGrainDao.findByForgedCardId(card.id)
            if (pollenGrain != null) {
                Log.i("DeckViewerViewModel", "PollenGrain trouv√© pour la carte ${card.id}. Statut mis √† PENDING_TRANSLATION.")
                pollenGrainDao.updateStatus(pollenGrain.id, PollenStatus.PENDING_TRANSLATION)
                launchForgeWorker()
            } else {
                Log.w("DeckViewerViewModel", "Aucun PollenGrain trouv√© pour la carte ${card.id}. La traduction ne peut √™tre lanc√©e.")
            }
        }
    }

    private fun loadAllDecks() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val groupedDecks = withContext(Dispatchers.IO) {
                cardDao.getAll()
            }.groupBy { it.deckName }
            _uiState.update { currentState ->
                currentState.copy(
                    isLoading = false,
                    allCards = groupedDecks,
                    filteredCards = groupedDecks[currentState.selectedDeck] ?: emptyList()
                )
            }
        }
    }

    private fun launchForgeWorker() {
        Log.d("DeckViewerViewModel", "Lancement du ForgeWorker pour la traduction.")

        val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
        val requiresCharging = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_CHARGING, false)
        val requiresIdle = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_IDLE, false)

        val constraints = Constraints.Builder()
            .setRequiresCharging(requiresCharging)
            .setRequiresDeviceIdle(requiresIdle)
            .setRequiredNetworkType(NetworkType.CONNECTED) // La traduction n√©cessite le r√©seau
            .build()

        val forgeRequest = OneTimeWorkRequestBuilder<ForgeWorker>()
            .setConstraints(constraints)
            .build()

        workManager.beginUniqueWork(
            "PollenForgeChain",
            ExistingWorkPolicy.APPEND_OR_REPLACE,
            forgeRequest
        ).enqueue()

        Log.i("DeckViewerViewModel", "ForgeWorker mis en file d'attente pour la traduction.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/AnalysisResultAdapter.kt ---

package be.heyman.android.ai.kikko.forge

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.ModelConfiguration
import com.google.android.material.chip.Chip
import com.google.gson.Gson

// BOURDON'S FIX: La classe DiffCallback est maintenant d√©finie AVANT l'adaptateur qui l'utilise.
class AnalysisResultDiffCallback : DiffUtil.ItemCallback<AnalysisResult>() {
    override fun areItemsTheSame(oldItem: AnalysisResult, newItem: AnalysisResult): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: AnalysisResult, newItem: AnalysisResult): Boolean {
        return oldItem.status == newItem.status &&
                oldItem.rawResponse == newItem.rawResponse &&
                oldItem.streamingResponse == newItem.streamingResponse &&
                oldItem.errorMessage == newItem.errorMessage
    }
}

class AnalysisResultAdapter(
    private val onRun: (AnalysisResult) -> Unit,
    private val onCancel: (AnalysisResult) -> Unit,
    private val onRetry: (AnalysisResult) -> Unit,
    private val onViewError: (AnalysisResult) -> Unit,
    private val onValidate: (AnalysisResult) -> Unit
) : ListAdapter<AnalysisResult, AnalysisResultAdapter.ViewHolder>(AnalysisResultDiffCallback()) {

    private val gson = Gson()
    private val expandedItemIds = mutableSetOf<String>()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_analysis_result, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val task = getItem(position)
        val isExpanded = expandedItemIds.contains(task.id)
        holder.bind(task, isExpanded) {
            if (expandedItemIds.contains(task.id)) {
                expandedItemIds.remove(task.id)
            } else {
                expandedItemIds.add(task.id)
            }
            notifyItemChanged(position)
        }
    }

    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val analysisModelConfig: TextView = view.findViewById(R.id.analysis_model_config)
        val analysisStatusChip: Chip = view.findViewById(R.id.analysis_status_chip)
        val analysisRawResponse: TextView = view.findViewById(R.id.analysis_raw_response)
        val analysisErrorMessage: TextView = view.findViewById(R.id.analysis_error_message)
        val analysisRunButton: Button = view.findViewById(R.id.analysis_run_button)
        val analysisPauseButton: Button = view.findViewById(R.id.analysis_pause_button)
        val analysisCancelButton: Button = view.findViewById(R.id.analysis_cancel_button)
        val analysisRetryButton: Button = view.findViewById(R.id.analysis_retry_button)
        val analysisViewErrorButton: Button = view.findViewById(R.id.analysis_view_error_button)
        val analysisValidateButton: Button = view.findViewById(R.id.analysis_validate_button)

        val headerContainer: View = view.findViewById(R.id.analysis_header_container)
        val detailsContainer: View = view.findViewById(R.id.analysis_details_container)


        fun bind(task: AnalysisResult, isManuallyExpanded: Boolean, onHeaderClick: () -> Unit) {
            analysisStatusChip.text = task.status.name

            val title = when {
                task.status == AnalysisStatus.COMPLETED -> generateTitleFromResponse(task)
                else -> {
                    val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
                    "${config.modelName.replace(".task", "")} (${config.accelerator}, T:${config.temperature})"
                }
            }
            analysisModelConfig.text = title

            if (task.status == AnalysisStatus.RUNNING || isManuallyExpanded) {
                detailsContainer.visibility = View.VISIBLE
            } else {
                detailsContainer.visibility = View.GONE
            }
            headerContainer.setOnClickListener { onHeaderClick() }

            val showResponseText = when (task.status) {
                AnalysisStatus.RUNNING -> task.streamingResponse
                AnalysisStatus.COMPLETED -> task.rawResponse
                else -> null
            }

            if (!showResponseText.isNullOrEmpty()) {
                analysisRawResponse.visibility = View.VISIBLE
                analysisRawResponse.text = showResponseText
            } else {
                analysisRawResponse.visibility = View.GONE
            }

            analysisErrorMessage.visibility = if (task.status == AnalysisStatus.FAILED && task.errorMessage != null) {
                analysisErrorMessage.text = task.errorMessage
                View.VISIBLE
            } else {
                View.GONE
            }

            when (task.status) {
                AnalysisStatus.PENDING, AnalysisStatus.PAUSED, AnalysisStatus.CANCELLED -> showActions(run = true)
                AnalysisStatus.RUNNING -> showActions(pause = true, cancel = true)
                AnalysisStatus.FAILED -> showActions(viewError = true, retry = true)
                AnalysisStatus.COMPLETED -> {
                    showActions(validate = true)
                }
            }

            analysisRunButton.setOnClickListener { onRun(task) }
            analysisCancelButton.setOnClickListener { onCancel(task) }
            analysisRetryButton.setOnClickListener { onRetry(task) }
            analysisViewErrorButton.setOnClickListener { onViewError(task) }
            analysisValidateButton.setOnClickListener { onValidate(task) }
        }

        private fun generateTitleFromResponse(task: AnalysisResult): String {
            val rawResponse = task.rawResponse ?: return "Analyse termin√©e"
            val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
            val modelNickname = config.modelName.take(15)

            return when (task.propertyName) {
                "identification" -> {
                    try {
                        data class IdentificationTitle(val specificName: String?, val deckName: String?)
                        val cleanJson = rawResponse.substringAfter("{").substringBeforeLast("}")
                        val result = gson.fromJson("{$cleanJson}", IdentificationTitle::class.java)
                        if (!result.specificName.isNullOrBlank() && !result.deckName.isNullOrBlank()) {
                            "‚úÖ ${result.deckName}: ${result.specificName}"
                        } else { "‚ö†Ô∏è R√©sultat partiel" }
                    } catch (e: Exception) {
                        val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
                        val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
                        if (name != null && deck != null) "‚úÖ $deck: $name (via Regex)" else "‚ö†Ô∏è R√©sultat non-structur√©"
                    }
                }
                "description" -> "‚úÖ Description g√©n√©r√©e par $modelNickname"
                else -> "‚úÖ Termin√© - $modelNickname"
            }
        }

        private fun showActions(run: Boolean = false, pause: Boolean = false, cancel: Boolean = false, retry: Boolean = false, viewError: Boolean = false, validate: Boolean = false) {
            analysisRunButton.visibility = if (run) View.VISIBLE else View.GONE
            analysisPauseButton.visibility = if (pause) View.VISIBLE else View.GONE
            analysisCancelButton.visibility = if (cancel) View.VISIBLE else View.GONE
            analysisRetryButton.visibility = if (retry) View.VISIBLE else View.GONE
            analysisViewErrorButton.visibility = if (viewError) View.VISIBLE else View.GONE
            analysisValidateButton.visibility = if (validate) View.VISIBLE else View.GONE
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/AnalysisResultAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeLlmHelper.kt ---

package be.heyman.android.ai.kikko.forge

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import be.heyman.android.ai.kikko.data.Accelerator
import be.heyman.android.ai.kikko.data.MAX_IMAGE_COUNT
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.ModelConfiguration
import com.google.mediapipe.framework.image.BitmapImageBuilder
import com.google.mediapipe.tasks.genai.llminference.GraphOptions
import com.google.mediapipe.tasks.genai.llminference.LlmInference
import com.google.mediapipe.tasks.genai.llminference.LlmInferenceSession
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.resume

private const val TAG = "ForgeLlmHelper"

class ForgeLlmHelper(
    val context: Context,
) {
    private var llmInference: LlmInference? = null
    private var session: LlmInferenceSession? = null
    private var currentSessionTemperature: Float? = null
    private var currentSessionTopK: Int? = null
    private var currentSessionIsMultimodal: Boolean = false


    fun initialize(model: Model, accelerator: String, isMultimodal: Boolean): String? {
        cleanUp()
        return try {
            Log.d(TAG, "Initialisation LLM avec mod√®le: ${model.name}, acc√©l√©rateur: $accelerator, multimodal: $isMultimodal")
            val optionsBuilder = LlmInference.LlmInferenceOptions.builder()
                .setModelPath(model.url)
                .setMaxTokens(4096)
                .setPreferredBackend(
                    if (accelerator == Accelerator.GPU.label) LlmInference.Backend.GPU
                    else LlmInference.Backend.CPU
                )
                .setMaxNumImages(if (isMultimodal && model.llmSupportImage) MAX_IMAGE_COUNT else 0)

            val options = optionsBuilder.build()
            llmInference = LlmInference.createFromOptions(context, options)
            // Ne pas cr√©er de session par d√©faut. Elle sera cr√©√©e √† la demande.
            null
        } catch (e: Exception) {
            cleanUpMediapipeTaskErrorMessage(e.message ?: "Unknown error during initialization")
        }
    }

    private fun createNewSession(llmInference: LlmInference, temperature: Float, topK: Int, isMultimodal: Boolean): LlmInferenceSession? {
        return try {
            Log.d(TAG, "Cr√©ation d'une nouvelle session avec temp√©rature: $temperature, topK: $topK, multimodal: $isMultimodal")
            currentSessionTemperature = temperature
            currentSessionTopK = topK
            currentSessionIsMultimodal = isMultimodal
            val sessionOptionsBuilder = LlmInferenceSession.LlmInferenceSessionOptions.builder()
                .setTemperature(temperature)
                .setTopK(topK)
            sessionOptionsBuilder.setGraphOptions(
                GraphOptions.builder()
                    .setEnableVisionModality(isMultimodal)
                    .build()
            )
            LlmInferenceSession.createFromOptions(llmInference, sessionOptionsBuilder.build())
        } catch (e: Exception) {
            Log.e(TAG, "Failed to create new session", e)
            null
        }
    }

    fun resetSession(model: Model, isMultimodal: Boolean, temperature: Float = 0.2f, topK: Int = 40) {
        try {
            if (session != null && currentSessionTemperature == temperature && currentSessionTopK == topK && currentSessionIsMultimodal == isMultimodal) {
                Log.d(TAG, "Session d√©j√† configur√©e avec les m√™mes param√®tres. R√©utilisation.")
                return
            }
            Log.d(TAG, "R√©initialisation de la session pour mod√®le '${model.name}' avec temp: $temperature, topK: $topK, multimodal: $isMultimodal")
            session?.close()
            val inferenceEngine = llmInference ?: run {
                Log.e(TAG, "Cannot reset session, LlmInference engine is null.")
                initialize(model, Accelerator.GPU.label, isMultimodal)
                llmInference ?: return
            }
            session = createNewSession(inferenceEngine, temperature, topK, isMultimodal)
            if (session == null) {
                throw IllegalStateException("Failed to create LlmInferenceSession after reset.")
            }
            Log.d(TAG, "Session r√©initialis√©e avec succ√®s.")
        } catch(e: Exception) {
            Log.e(TAG, "Failed to reset session for '${model.name}': ${e.message}")
            cleanUp()
        }
    }

    private fun ensureSession(config: ModelConfiguration, isMultimodal: Boolean) {
        val inferenceEngine = llmInference ?: throw IllegalStateException("LlmInference engine not initialized.")
        if (session == null || currentSessionTemperature != config.temperature || currentSessionTopK != config.topK || currentSessionIsMultimodal != isMultimodal) {
            Log.d(TAG, "Configuration de session invalide ou inexistante. Cr√©ation d'une nouvelle session.")
            session?.close()
            session = createNewSession(inferenceEngine, config.temperature, config.topK, isMultimodal)
                ?: throw IllegalStateException("Failed to create new LlmInferenceSession.")
        }
    }

    fun runInference(
        prompt: String,
        images: List<Bitmap>,
        resultListener: (partialResult: String, done: Boolean) -> Unit
    ) {
        val currentSession = session ?: run {
            resultListener("Erreur: Session non initialis√©e.", true)
            return
        }
        Log.d(TAG, "--- PROMPT ENVOY√â √Ä LA REINE ---\n$prompt")
        try {
            if (prompt.trim().isNotEmpty()) {
                currentSession.addQueryChunk(prompt)
            }
            if (images.isNotEmpty()) {
                for (image in images) {
                    val mpImage = BitmapImageBuilder(image).build()
                    currentSession.addImage(mpImage)
                }
            }
            currentSession.generateResponseAsync(resultListener)
        } catch (e: Exception) {
            Log.e(TAG, "Erreur durant l'inf√©rence dans la Forge", e)
            resultListener(cleanUpMediapipeTaskErrorMessage(e.message ?: "Error during inference"), true)
        }
    }

    // BOURDON'S FIX: Restauration de la m√©thode pour les Workers
    suspend fun inferenceWithCoroutineAndConfig(prompt: String, images: List<Bitmap>, config: ModelConfiguration): String {
        ensureSession(config, images.isNotEmpty())
        return suspendCancellableCoroutine { continuation ->
            val responseBuilder = StringBuilder()
            runInference(prompt, images) { partialResult, done ->
                responseBuilder.append(partialResult)
                if (done) {
                    if (continuation.isActive) {
                        continuation.resume(responseBuilder.toString())
                    }
                }
            }
        }
    }

    fun runInferenceWithConfig(
        prompt: String,
        images: List<Bitmap>,
        config: ModelConfiguration,
        resultListener: (partialResult: String, done: Boolean) -> Unit
    ) {
        ensureSession(config, images.isNotEmpty())
        runInference(prompt, images, resultListener)
    }

    fun cleanUp() {
        session?.close()
        llmInference?.close()
        session = null
        llmInference = null
        currentSessionTemperature = null
        currentSessionTopK = null
        currentSessionIsMultimodal = false
    }
}

private fun cleanUpMediapipeTaskErrorMessage(message: String): String {
    val index = message.indexOf("=== Source Location Trace")
    if (index >= 0) {
        return message.substring(0, index).trim()
    }
    return message.trim()
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeLlmHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeMlKitHelper.kt ---

package be.heyman.android.ai.kikko.forge

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import be.heyman.android.ai.kikko.model.ImageAnalysisReport
import be.heyman.android.ai.kikko.model.OcrResult
import be.heyman.android.ai.kikko.model.SimpleDetectedObject
import be.heyman.android.ai.kikko.model.SimpleImageLabel
import be.heyman.android.ai.kikko.model.SwarmAnalysisResult
import com.google.android.gms.tasks.Tasks
import com.google.mlkit.common.model.LocalModel
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.label.ImageLabel
import com.google.mlkit.vision.label.ImageLabeler
import com.google.mlkit.vision.label.ImageLabeling
import com.google.mlkit.vision.label.custom.CustomImageLabelerOptions
import com.google.mlkit.vision.label.defaults.ImageLabelerOptions
import com.google.mlkit.vision.objects.DetectedObject
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.Closeable

/**
 * Helper pour orchestrer les analyses ML Kit sur une ou plusieurs images pour la Forge.
 * D√©plac√© depuis le package `debug` car c'est une fonctionnalit√© essentielle pour la Forge.
 * En tant qu'objet singleton, il n'a pas besoin d'injection Hilt pour son propre fonctionnement.
 */
object ForgeMlKitHelper {
    private const val TAG = "ForgeMlKitHelper"

    const val OCR = "ocr"
    const val OBJECT_DETECTION = "object_detection"
    const val DEFAULT_LABELING = "default_labeling"
    const val BIRDS_CLASSIFIER = "birds_classifier"
    const val INSECTS_CLASSIFIER = "insects_classifier"
    const val PLANTS_CLASSIFIER = "plants_classifier"
    const val FOOD_CLASSIFIER = "food_classifier"
    const val MOBILENET_V1 = "mobilenet_v1"
    const val EFFICIENTNET_LITE0 = "efficientnet_lite0"
    const val EFFICIENTNET_LITE1 = "efficientnet_lite1"
    const val EFFICIENTNET_LITE2 = "efficientnet_lite2"
    const val DEEP_OBJECT_ANALYSIS = "deep_object_analysis"

    /**
     * Ex√©cute une analyse ML Kit complexe sur une liste de bitmaps.
     * Cette fonction agr√®ge les r√©sultats de plusieurs d√©tecteurs/classifieurs.
     *
     * @param context Contexte de l'application.
     * @param images La liste des bitmaps √† analyser.
     * @param enabledModels Une map des mod√®les √† activer (ex: "ocr" -> true).
     * @param onResult Callback pour le r√©sultat agr√©g√© de l'essaim.
     */
    fun runAnalysis(
        context: Context, // Contexte n√©cessaire pour cr√©er les clients ML Kit
        images: List<Bitmap>,
        enabledModels: Map<String, Boolean>,
        onResult: (SwarmAnalysisResult) -> Unit
    ) {
        Log.d(TAG, "Lancement de l'analyse de l'essaim pour ${images.size} images. Mod√®les activ√©s: ${enabledModels.filter { it.value }.keys}")
        CoroutineScope(Dispatchers.Default).launch {
            val imageReports = mutableListOf<ImageAnalysisReport>()

            images.forEachIndexed { index, bitmap ->
                Log.d(TAG, "Analyse de l'image ${index + 1}/${images.size} de l'essaim...")
                val report = processSingleImage(context, bitmap, enabledModels)
                imageReports.add(report)
            }

            val swarmResult = SwarmAnalysisResult(reports = imageReports)
            Log.i(TAG, "Analyse compl√®te de l'essaim termin√©e.")

            withContext(Dispatchers.Main) {
                onResult(swarmResult)
            }
        }
    }

    private suspend fun processSingleImage(context: Context, bitmap: Bitmap, enabledModels: Map<String, Boolean>): ImageAnalysisReport {
        Log.d(TAG, "Traitement d'une seule image...")
        val clientsToClose = mutableListOf<Closeable>()
        var detectedObjects = emptyList<SimpleDetectedObject>()
        val classifierResults = mutableMapOf<String, List<SimpleImageLabel>>()
        var ocrText = ""

        try {
            val image = InputImage.fromBitmap(bitmap, 0)
            val tasks = mutableListOf<com.google.android.gms.tasks.Task<*>>()
            val taskNames = mutableListOf<String>()

            if (enabledModels[OCR] == true) {
                Log.d(TAG, "Ajout de la t√¢che OCR √† l'essaim.")
                // Le contexte est pass√© √† la m√©thode `getClient`
                val recognizer = TextRecognition.getClient(JapaneseTextRecognizerOptions.Builder().build())
                clientsToClose.add(recognizer)
                tasks.add(recognizer.process(image))
                taskNames.add(OCR)
            }
            if (enabledModels[OBJECT_DETECTION] == true) {
                Log.d(TAG, "Ajout de la t√¢che de D√©tection d'Objets √† l'essaim.")
                val options = ObjectDetectorOptions.Builder().setDetectorMode(ObjectDetectorOptions.SINGLE_IMAGE_MODE).enableMultipleObjects().enableClassification().build()
                // Le contexte est pass√© √† la m√©thode `getClient`
                val detector = ObjectDetection.getClient(options)
                clientsToClose.add(detector)
                tasks.add(detector.process(image))
                taskNames.add(OBJECT_DETECTION)
            }
            if (enabledModels[DEFAULT_LABELING] == true) {
                Log.d(TAG, "Ajout de la t√¢che de Labellisation par D√©faut √† l'essaim.")
                // Le contexte est pass√© √† la m√©thode `getClient`
                val labeler = ImageLabeling.getClient(ImageLabelerOptions.DEFAULT_OPTIONS)
                clientsToClose.add(labeler)
                tasks.add(labeler.process(image))
                taskNames.add("Labels (D√©faut)")
            }

            // Les fonctions `addCustomClassifierTask` prennent d√©j√† le contexte.
            addCustomClassifierTask(context, enabledModels, BIRDS_CLASSIFIER, "aiy-tflite-vision-classifier-birds-v1-v3.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, INSECTS_CLASSIFIER, "aiy-tflite-vision-classifier-insects-v1-v3.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, PLANTS_CLASSIFIER, "aiy-tflite-vision-classifier-plants-v1-v3.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, FOOD_CLASSIFIER, "aiy-tflite-vision-classifier-food-v1-v1.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, MOBILENET_V1, "mobilenet_v1_1.0_224_quantized_1_metadata_1.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, EFFICIENTNET_LITE0, "efficientnet_lite0.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, EFFICIENTNET_LITE1, "efficientnet_lite1_int8_2.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, EFFICIENTNET_LITE2, "efficientnet_lite2_int8_2.tflite", image, tasks, taskNames, clientsToClose)


            if (tasks.isNotEmpty()) {
                val results = Tasks.await(Tasks.whenAllSuccess<Any>(tasks))
                Log.i(TAG, "${results.size} t√¢ches ML Kit termin√©es avec succ√®s.")

                results.forEachIndexed { index, result ->
                    val taskName = taskNames[index]
                    when (result) {
                        is Text -> ocrText = result.text
                        is List<*> -> {
                            if (result.all { it is DetectedObject }) {
                                detectedObjects = (result as List<DetectedObject>).map { obj ->
                                    SimpleDetectedObject(labels = obj.labels.map { SimpleImageLabel(it.text, it.confidence) })
                                }
                            } else if (result.all { it is ImageLabel }) {
                                classifierResults[taskName] = (result as List<ImageLabel>).map { SimpleImageLabel(it.text, it.confidence) }
                            }
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "L'une des t√¢ches ML a √©chou√© en mode complexe", e)
        } finally {
            Log.d(TAG, "Nettoyage de ${clientsToClose.size} clients ML Kit.")
            clientsToClose.forEach { it.close() }
        }

        // BOURDON'S FIX: On encapsule le String OCR dans l'objet OcrResult attendu par le mod√®le de donn√©es.
        return ImageAnalysisReport(detectedObjects, classifierResults, OcrResult(fullText = ocrText))
    }

    private fun addCustomClassifierTask(
        context: Context, // Contexte ajout√© ici pour cr√©er les clients
        enabledModels: Map<String, Boolean>,
        modelKey: String,
        assetPath: String,
        image: InputImage,
        tasks: MutableList<com.google.android.gms.tasks.Task<*>>,
        taskNames: MutableList<String>,
        clientsToClose: MutableList<Closeable>
    ) {
        if (enabledModels[modelKey] == true) {
            Log.d(TAG, "Ajout de la t√¢che du classifieur personnalis√© '$modelKey' √† l'essaim.")
            val localModel = LocalModel.Builder().setAssetFilePath(assetPath).build()
            val options = CustomImageLabelerOptions.Builder(localModel).setConfidenceThreshold(0.1f).build()
            // Le contexte est pass√© √† la m√©thode `getClient`
            val labeler = ImageLabeling.getClient(options)
            clientsToClose.add(labeler)
            tasks.add(labeler.process(image))
            taskNames.add(modelKey.replace("_classifier", "").replaceFirstChar { it.titlecase() })
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeMlKitHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgePromptGenerator.kt ---

package be.heyman.android.ai.kikko.forge

import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.prompt.PromptManager
import com.google.gson.Gson
import java.util.Locale

object ForgePromptGenerator {

    // BOURDON'S ADDITION: Un GSON local pour la s√©rialisation des propositions.
    private val gson = Gson()

    /**
     * BOURDON'S FINAL REFACTOR: Le g√©n√©rateur r√©cup√®re le prompt brut (maintenant en dur
     * dans le PromptManager) et effectue lui-m√™me le formatage.
     */
    fun generateIdentificationTournamentPrompt(swarmReportJson: String): String {
        val rawPrompt = PromptManager.getPrompt("forge_identification")
        // Note: Le '$' dans %1$s est crucial pour √©viter les ambigu√Øt√©s de formatage.
        return String.format(rawPrompt, swarmReportJson)
    }

    /**
     * BOURDON'S FINAL REFACTOR: La logique de formatage est de retour dans le g√©n√©rateur.
     */
    fun generatePropertyForgePrompt(
        propertyName: String,
        deckName: String,
        specificName: String,
        swarmReportJson: String,
        existingDescription: String?,
        dependencyDataJson: String? = null
    ): String {

        if (propertyName == "description") {
            // NOTE: Ceci est un prompt qui a √©t√© abandonn√©, mais je le garde pour la compatibilit√©.
            // Le syst√®me de forge actuel n'utilise plus ce chemin.
            val rawPrompt = PromptManager.getPrompt("forge_description_multimodal")
            return String.format(
                rawPrompt,
                specificName,
                deckName,
                swarmReportJson
            )
        }

        // NOTE: Ce prompt est √©galement obsol√®te et n'est plus appel√© par le worker monolithique.
        val rawPrompt = PromptManager.getPrompt("forge_property_base")
        val formattedDescription = if (existingDescription != null) "\n[NATIVE DESCRIPTION]:\n$existingDescription" else ""
        val formattedDependency = if (dependencyDataJson != null) "\n[DEPENDENCY DATA (PREVIOUSLY FORGED)]:\n$dependencyDataJson" else ""

        return String.format(
            rawPrompt,
            deckName,
            specificName,
            propertyName,
            swarmReportJson,
            formattedDescription,
            formattedDependency
        )
    }

    /**
     * BOURDON'S ADDITION: La nouvelle m√©thode pour forger le prompt de l'Arbitre.
     * Elle prend les r√©sultats d'un tournoi, les s√©rialise en JSON et les injecte dans le
     * prompt 'forge_judgment_arbiter'.
     *
     * @param propertyName Le nom de la propri√©t√© jug√©e (ex: "description").
     * @param proposals La liste des t√¢ches 'AnalysisResult' termin√©es √† soumettre √† l'Arbitre.
     * @return Le prompt complet et format√© pour l'inf√©rence de l'Arbitre.
     */
    fun generateJudgmentPrompt(propertyName: String, proposals: List<AnalysisResult>): String {
        val rawPrompt = PromptManager.getPrompt("forge_judgment_arbiter")
        val proposalsJson = gson.toJson(proposals)
        return String.format(rawPrompt, propertyName, proposalsJson)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgePromptGenerator.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeRepository.kt ---

package be.heyman.android.ai.kikko.forge

import android.util.Log
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.AnalysisResultDao
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository pour le flux de travail de la Forge.
 * Agit comme une fa√ßade pour les diff√©rents DAOs li√©s au processus de forge.
 * C'est la seule source de v√©rit√© pour le ForgeWorkshopViewModel.
 */
@Singleton
class ForgeRepository @Inject constructor(
    private val pollenGrainDao: PollenGrainDao,
    private val cardDao: CardDao,
    private val analysisResultDao: AnalysisResultDao
) {
    private val gson = Gson()
    private val stringListType = object : TypeToken<List<String>>() {}.type

    /**
     * R√©cup√®re tous les grains de pollen qui ne sont pas encore compl√®tement forg√©s.
     */
    suspend fun getGrainsForWorkshop(): List<PollenGrain> {
        // Retourne tous les grains sauf ceux qui sont FORGED ou en ERROR.
        val allGrains = pollenGrainDao.getByStatus(PollenStatus.RAW) +
                pollenGrainDao.getByStatus(PollenStatus.IDENTIFYING) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_DESCRIPTION) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_STATS) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_QUIZ) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_TRANSLATION)
        return allGrains.distinctBy { it.id }.sortedByDescending { it.timestamp }
    }

    /**
     * R√©cup√®re la KnowledgeCard associ√©e √† un PollenGrain.
     */
    suspend fun getCardForGrain(grain: PollenGrain): KnowledgeCard? {
        return grain.forgedCardId?.let { cardDao.getCardById(it) }
    }

    /**
     * R√©cup√®re tous les r√©sultats d'analyse pour une propri√©t√© sp√©cifique d'un grain.
     */
    suspend fun getAnalysisResults(pollenGrainId: String, propertyName: String): List<AnalysisResult> {
        return analysisResultDao.getByPollenGrainIdAndProperty(pollenGrainId, propertyName)
    }

    /**
     * BOURDON'S FIX: Nouvelle m√©thode pour ins√©rer une seule t√¢che.
     * C'est une correction n√©cessaire pour la logique du ViewModel.
     */
    suspend fun insertAnalysisResult(result: AnalysisResult) {
        analysisResultDao.insert(result)
    }


    /**
     * Cr√©e et ins√®re dans la base de donn√©es les t√¢ches d'analyse pour un "tournoi".
     * @return La liste des t√¢ches cr√©√©es.
     */
    suspend fun createAnalysisTasksForProperty(pollenGrainId: String, propertyName: String, models: List<String>, accelerator: String): List<AnalysisResult> {
        val tasks = mutableListOf<AnalysisResult>()
        // BOURDON'S FIX: Le d√©cret de 2 configurations par Reine est appliqu√© ici.
        val configs = listOf(
            Pair(0.2f, 40), // Factuel
            Pair(0.9f, 80)  // Cr√©atif
        )

        models.forEach { modelName ->
            configs.forEach { (temp, topK) ->
                val modelConfig = ModelConfiguration(modelName, accelerator, temp, topK)
                val task = AnalysisResult(
                    pollenGrainId = pollenGrainId,
                    propertyName = propertyName,
                    modelConfigJson = gson.toJson(modelConfig),
                    status = AnalysisStatus.PENDING
                )
                analysisResultDao.insert(task)
                tasks.add(task)
            }
        }
        return tasks
    }

    /**
     * BOURDON'S FIX: Nouvelle m√©thode pour purger les r√©sultats d'une comp√©tition avant de la relancer.
     */
    suspend fun clearAnalysisResultsForProperty(pollenGrainId: String, propertyName: String) {
        analysisResultDao.deleteByPollenGrainIdAndProperty(pollenGrainId, propertyName)
    }

    /**
     * Met √† jour une t√¢che d'analyse (typiquement apr√®s son ex√©cution).
     */
    suspend fun updateAnalysisResult(result: AnalysisResult) {
        analysisResultDao.update(result)
    }

    /**
     * Met √† jour le statut d'un grain de pollen.
     */
    suspend fun updatePollenStatus(pollenGrainId: String, newStatus: PollenStatus) {
        pollenGrainDao.updateStatus(pollenGrainId, newStatus)
    }

    /**
     * Met √† jour une propri√©t√© sp√©cifique de la carte de connaissance.
     * Cette fonction est compl√®te et g√®re les diff√©rents types de propri√©t√©s.
     */
    suspend fun updateCardProperty(cardId: Long, propertyName: String, value: String) {
        val card = cardDao.getCardById(cardId) ?: return

        val updatedCard = when {
            propertyName == "description" -> card.copy(description = value)
            propertyName == "biological.scientificName" -> card.copy(scientificName = value)
            propertyName == "biological.vernacularName" -> card.copy(vernacularName = value)
            propertyName == "ingredients" -> card.copy(ingredients = gson.fromJson(value, stringListType))
            propertyName == "allergens" -> card.copy(allergens = gson.fromJson(value, stringListType))
            propertyName.startsWith("stats.") -> {
                val statKey = propertyName.substringAfter("stats.")
                val newStatsItems = card.stats?.items?.toMutableMap() ?: mutableMapOf()
                newStatsItems[statKey] = value
                card.copy(stats = CardStats(title = "Statistics", items = newStatsItems))
            }
            else -> {
                Log.w("ForgeRepository", "Tentative de mise √† jour d'une propri√©t√© inconnue: '$propertyName'")
                card // Ne rien faire si la propri√©t√© est inconnue
            }
        }

        if (updatedCard != card) {
            cardDao.update(updatedCard)
        }
    }

    /**
     * BOURDON'S FIX: Nouvelle fonction pour orchestrer une suppression compl√®te.
     * Supprime le grain, sa carte associ√©e, ses fichiers images et ses r√©sultats d'analyse (via cascade).
     */
    suspend fun deletePollenGrainAndAssociatedData(grain: PollenGrain) {
        // 1. Supprimer la carte associ√©e, si elle existe.
        grain.forgedCardId?.let { cardId ->
            cardDao.getCardById(cardId)?.let { card ->
                cardDao.delete(card)
                Log.d("ForgeRepository", "Carte associ√©e (ID: $cardId) supprim√©e.")
            }
        }

        // 2. Supprimer les fichiers image physiques.
        grain.pollenImagePaths.forEach { path ->
            try {
                val file = File(path)
                if (file.exists()) {
                    if (file.delete()) {
                        Log.d("ForgeRepository", "Fichier image supprim√© : $path")
                    } else {
                        Log.w("ForgeRepository", "√âchec de la suppression du fichier image : $path")
                    }
                }
            } catch (e: Exception) {
                Log.e("ForgeRepository", "Erreur lors de la suppression du fichier image : $path", e)
            }
        }

        // 3. Supprimer le grain de pollen.
        // La suppression en cascade dans la DB s'occupera des AnalysisResults.
        pollenGrainDao.delete(grain)
        Log.d("ForgeRepository", "Grain de pollen (ID: ${grain.id}) et ses donn√©es associ√©es supprim√©s.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeRepository.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---

package be.heyman.android.ai.kikko.forge

import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.content.ContextCompat
import androidx.core.view.isVisible
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.PollenStatus
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.card.MaterialCardView
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import kotlinx.coroutines.launch
import java.io.File

class ForgeWorkshopActivity : AppCompatActivity() {

    private val viewModel: ForgeWorkshopViewModel by viewModels {
        ViewModelProvider.AndroidViewModelFactory.getInstance(application)
    }

    private val TAG = "ForgeWorkshopActivity"

    // Vues statiques
    private lateinit var statusMessage: TextView
    private lateinit var progressBar: ProgressBar
    private lateinit var pollenGrainsRecyclerView: RecyclerView
    private lateinit var workshopContent: View
    private lateinit var grainIdLabel: TextView
    private lateinit var workshopSelectedImage: ImageView
    private lateinit var workshopSelectedName: TextView
    private lateinit var workshopSelectedDeck: TextView
    private lateinit var propertiesContainer: LinearLayout
    private lateinit var workshopDeleteGrainButton: Button
    private lateinit var filterRawButton: LinearLayout
    private lateinit var filterFoodButton: LinearLayout
    private lateinit var filterPlantButton: LinearLayout
    private lateinit var filterInsectButton: LinearLayout
    private lateinit var filterBirdButton: LinearLayout
    private lateinit var filterButtons: Map<String, View>

    // Adaptateurs et √©tat de l'UI
    private lateinit var grainAdapter: PollenGrainAdapter
    private val propertyAdapters = mutableMapOf<String, AnalysisResultAdapter>()
    private val expandedPropertySections = mutableSetOf<String>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_forge_workshop)
        Log.d(TAG, "[CYCLE DE VIE] onCreate: Initialisation de l'Atelier.")

        bindViews()
        setupStaticAdapters()
        setupStaticListeners()
        observeUiState()
    }

    private fun bindViews() {
        Log.d(TAG, "Liaison des vues de l'Atelier...")
        statusMessage = findViewById(R.id.workshop_status_message)
        progressBar = findViewById(R.id.workshop_progress_bar)
        pollenGrainsRecyclerView = findViewById(R.id.workshop_grains_recyclerview)
        workshopContent = findViewById(R.id.workshop_detail_container)
        grainIdLabel = findViewById(R.id.grain_id_label)
        workshopSelectedImage = findViewById(R.id.workshop_selected_image)
        workshopSelectedName = findViewById(R.id.workshop_selected_name)
        workshopSelectedDeck = findViewById(R.id.workshop_selected_deck)
        propertiesContainer = findViewById(R.id.workshop_properties_container)
        workshopDeleteGrainButton = findViewById(R.id.workshop_delete_grain_button)
        filterRawButton = findViewById(R.id.filter_button_raw)
        filterFoodButton = findViewById(R.id.filter_button_food)
        filterPlantButton = findViewById(R.id.filter_button_plant)
        filterInsectButton = findViewById(R.id.filter_button_insect)
        filterBirdButton = findViewById(R.id.filter_button_bird)
        filterButtons = mapOf(
            ForgeWorkshopViewModel.FILTER_RAW to filterRawButton,
            GameConstants.MASTER_DECK_LIST[0] to filterFoodButton,
            GameConstants.MASTER_DECK_LIST[1] to filterPlantButton,
            GameConstants.MASTER_DECK_LIST[2] to filterInsectButton,
            GameConstants.MASTER_DECK_LIST[3] to filterBirdButton
        )
        Log.d(TAG, "Toutes les vues ont √©t√© li√©es avec succ√®s.")
    }

    private fun setupStaticAdapters() {
        grainAdapter = PollenGrainAdapter(emptyList(), null) { grain ->
            viewModel.selectGrain(grain)
        }
        pollenGrainsRecyclerView.layoutManager =
            LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)
        pollenGrainsRecyclerView.adapter = grainAdapter
    }

    private fun setupStaticListeners() {
        Log.d(TAG, "Configuration des listeners statiques.")
        workshopDeleteGrainButton.setOnClickListener {
            Log.d(TAG, "Bouton de suppression du grain cliqu√©.")
            MaterialAlertDialogBuilder(this)
                .setTitle(R.string.workshop_delete_grain_dialog_title)
                .setMessage(R.string.workshop_delete_grain_dialog_message)
                .setNegativeButton(R.string.dialog_cancel, null)
                .setPositiveButton(R.string.workshop_button_delete) { _, _ ->
                    Log.i(TAG, "Confirmation de la suppression. Appel au ViewModel.")
                    viewModel.deleteSelectedGrain()
                }
                .show()
        }
        filterButtons.forEach { (filterType, button) ->
            button.setOnClickListener {
                Log.d(TAG, "Bouton de filtre '$filterType' cliqu√©.")
                viewModel.setFilter(filterType)
            }
        }
    }

    private fun observeUiState() {
        lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                Log.v(TAG, "[UI UPDATE] Nouvel √©tat UI. Filtre: ${state.activeFilter}, Jugement: ${state.judgmentState::class.simpleName}")
                progressBar.isVisible = state.isLoading
                statusMessage.text = state.statusMessage

                grainAdapter.updateGrainsAndSelection(state.workshopGrains, state.selectedGrain?.id)

                if (state.selectedGrain != null) {
                    workshopContent.isVisible = true
                    grainIdLabel.text = getString(R.string.workshop_grain_id_format, state.selectedGrain.id.substring(0, 8))

                    if (state.selectedCard != null) {
                        workshopSelectedName.text = state.selectedCard.specificName
                        workshopSelectedDeck.text = getString(R.string.workshop_deck_format, state.selectedCard.deckName)
                        state.selectedCard.imagePath?.let { path ->
                            File(path).takeIf { it.exists() }?.let { workshopSelectedImage.setImageBitmap(BitmapFactory.decodeFile(it.absolutePath)) }
                                ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                        } ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                    } else {
                        workshopSelectedName.text = getString(R.string.workshop_raw_pollen_title)
                        workshopSelectedDeck.text = getString(R.string.workshop_deck_unknown)
                        state.selectedGrain.pollenImagePaths.firstOrNull()?.let { path ->
                            File(path).takeIf { it.exists() }?.let { workshopSelectedImage.setImageBitmap(BitmapFactory.decodeFile(it.absolutePath)) }
                                ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                        } ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                    }

                    populatePropertiesContainer(state)

                } else {
                    workshopContent.isVisible = false
                }

                state.analysisResults.forEach { (propertyName, results) ->
                    propertyAdapters[propertyName]?.submitList(results)
                }

                updateFilterButtonsVisualState(state.activeFilter)
                handleJudgmentState(state.judgmentState)
            }
        }
    }

    private fun handleJudgmentState(judgmentState: JudgmentState) {
        val existingDialog = supportFragmentManager.findFragmentByTag(JudgmentDialogFragment.TAG) as? JudgmentDialogFragment
        if (judgmentState is JudgmentState.None) {
            existingDialog?.dismiss()
            return
        }
        if (existingDialog == null) {
            JudgmentDialogFragment.newInstance().show(supportFragmentManager, JudgmentDialogFragment.TAG)
        }
    }

    private fun updateFilterButtonsVisualState(activeFilter: String) {
        val activeColor = ContextCompat.getColor(this, R.color.kikko_gold_light)
        val inactiveColor = ContextCompat.getColor(this, android.R.color.transparent)
        filterButtons.forEach { (filterType, buttonView) ->
            if (filterType == activeFilter) {
                buttonView.setBackgroundColor(activeColor)
                buttonView.alpha = 1.0f
            } else {
                buttonView.setBackgroundColor(inactiveColor)
                buttonView.alpha = 0.7f
            }
        }
    }

    private fun populatePropertiesContainer(state: ForgeWorkshopUiState) {
        propertiesContainer.removeAllViews()
        propertyAdapters.clear()
        val grain = state.selectedGrain ?: return
        val card = state.selectedCard
        val isAwaitingValidation = grain.status == PollenStatus.AWAITING_VALIDATION || grain.status == PollenStatus.IDENTIFYING || grain.status == PollenStatus.RAW

        addPropertySection("identification", state, isAwaitingValidation)

        if(card != null && card.deckName != "Unknown") {
            val properties = viewModel.getPropertiesForDeck(card.deckName)
            properties.forEach { propertyName ->
                addPropertySection(propertyName, state, isAwaitingValidation)
            }
        }
    }

    private fun addPropertySection(propertyName: String, state: ForgeWorkshopUiState, isAwaitingValidation: Boolean) {
        val view = LayoutInflater.from(this).inflate(R.layout.item_property_refinement, propertiesContainer, false)

        val headerView = view.findViewById<ConstraintLayout>(R.id.property_refinement_header)
        val titleView = view.findViewById<TextView>(R.id.property_refinement_title)
        val resultCountView = view.findViewById<TextView>(R.id.property_refinement_result_count)
        val expandIcon = view.findViewById<ImageView>(R.id.property_refinement_expand_icon)
        val contentContainer = view.findViewById<LinearLayout>(R.id.property_refinement_content)
        val launchButton = view.findViewById<Button>(R.id.property_refinement_launch_button)
        val judgmentButton = view.findViewById<Button>(R.id.property_refinement_launch_judgment_button)
        val recyclerView = view.findViewById<RecyclerView>(R.id.property_refinement_results_recyclerview)
        val summaryCard = view.findViewById<MaterialCardView>(R.id.property_refinement_summary_card)
        val summaryContainer = view.findViewById<LinearLayout>(R.id.property_refinement_summary_container)

        titleView.text = getTitleForProperty(propertyName)
        val isExpanded = expandedPropertySections.contains(propertyName)
        contentContainer.isVisible = isExpanded
        expandIcon.rotation = if (isExpanded) 180f else 0f
        val allResults = state.analysisResults[propertyName] ?: emptyList()
        val completedResultsCount = allResults.count { it.status == AnalysisStatus.COMPLETED }
        resultCountView.text = if (completedResultsCount > 0) getString(R.string.workshop_results_count, completedResultsCount) else ""
        resultCountView.isVisible = completedResultsCount > 0

        headerView.setOnClickListener {
            if (expandedPropertySections.contains(propertyName)) {
                expandedPropertySections.remove(propertyName)
                contentContainer.isVisible = false
                expandIcon.animate().rotation(0f).start()
            } else {
                expandedPropertySections.add(propertyName)
                contentContainer.isVisible = true
                expandIcon.animate().rotation(180f).start()
            }
        }

        // --- BOURDON'S REFACTORED INTELLIGENT BUTTON LOGIC (v2) ---
        var isLaunchButtonEnabled = true
        var disabledReasonResId: Int? = null
        if (isAwaitingValidation && propertyName != "identification") {
            isLaunchButtonEnabled = false; disabledReasonResId = R.string.workshop_validate_identification_first
        } else if (propertyName == "allergens" && state.selectedCard?.ingredients == null) {
            isLaunchButtonEnabled = false; disabledReasonResId = R.string.workshop_forge_ingredients_first
        }

        val isCompetitionRunning = allResults.any { it.status == AnalysisStatus.PENDING || it.status == AnalysisStatus.RUNNING }
        val hasCompletedResults = allResults.any { it.status == AnalysisStatus.COMPLETED }

        if (isCompetitionRunning) {
            launchButton.setText(R.string.workshop_competition_in_progress)
            isLaunchButtonEnabled = false
        } else if (allResults.isEmpty()) {
            launchButton.setText(R.string.workshop_launch_competition)
            launchButton.setOnClickListener { viewModel.createAnalysisTournament(propertyName) }
        } else {
            launchButton.setText(R.string.workshop_relaunch_competition)
            launchButton.setOnClickListener {
                MaterialAlertDialogBuilder(this)
                    .setTitle(R.string.dialog_relaunch_title).setMessage(R.string.dialog_relaunch_message)
                    .setNegativeButton(R.string.dialog_cancel, null)
                    .setPositiveButton(R.string.dialog_relaunch_confirm) { _, _ -> viewModel.relaunchAnalysisTournament(propertyName) }
                    .show()
            }
        }

        if (disabledReasonResId != null) launchButton.text = getString(disabledReasonResId)
        launchButton.isEnabled = isLaunchButtonEnabled

        // BOURDON'S CRITICAL FIX: Le bouton de jugement appara√Æt d√®s qu'il y a au moins un r√©sultat.
        judgmentButton.isVisible = hasCompletedResults && isLaunchButtonEnabled
        judgmentButton.setOnClickListener {
            viewModel.launchFinalJudgment(propertyName)
        }
        // --- END OF REFACTORED LOGIC ---

        val summary = state.competitionSummaries[propertyName]
        if (summary != null && summary.items.isNotEmpty()) {
            summaryCard.isVisible = true
            summaryContainer.removeAllViews()
            summary.items.forEach { summaryItem ->
                val summaryItemView = LayoutInflater.from(this).inflate(R.layout.item_competition_summary, summaryContainer, false)
                val summaryTextView = summaryItemView.findViewById<TextView>(R.id.summary_response_text)
                val summaryValidateButton = summaryItemView.findViewById<Button>(R.id.summary_validate_button)
                summaryTextView.text = getString(R.string.workshop_summary_proposal_format, summaryItem.voteCount, summaryItem.response)
                summaryValidateButton.setOnClickListener { viewModel.validateFromSummary(summaryItem) }
                summaryContainer.addView(summaryItemView)
            }
        } else {
            summaryCard.isVisible = false
        }

        val adapter = AnalysisResultAdapter(
            onRun = { viewModel.runAnalysisTask(it) },
            onCancel = { viewModel.cancelAnalysisTask(it) },
            onRetry = { viewModel.retryAnalysisTask(it) },
            onViewError = { task -> showErrorDialog(task.errorMessage ?: getString(R.string.error_unknown)) },
            onValidate = { task ->
                if (task.propertyName == "identification") viewModel.validateAndCreateCardFromIdentification(task)
                else viewModel.validateProperty(task)
            }
        )
        recyclerView.layoutManager = LinearLayoutManager(this)
        recyclerView.adapter = adapter
        propertyAdapters[propertyName] = adapter
        propertiesContainer.addView(view)
    }

    private fun getTitleForProperty(propertyName: String): String {
        val propertyTitleResId = when (propertyName) {
            "identification" -> R.string.property_title_identification
            "description" -> R.string.property_title_description
            "ingredients" -> R.string.property_title_ingredients
            "allergens" -> R.string.property_title_allergens
            "stats.energy" -> R.string.property_title_energy
            "biological.scientificName" -> R.string.property_title_scientific_name
            "biological.vernacularName" -> R.string.property_title_vernacular_name
            "stats.floweringPeriod" -> R.string.property_title_flowering
            "stats.diet" -> R.string.property_title_diet
            "stats.wingspan" -> R.string.property_title_wingspan
            else -> 0
        }
        return if (propertyTitleResId != 0) {
            getString(R.string.workshop_refinement_title_format, getString(propertyTitleResId))
        } else {
            getString(R.string.workshop_refinement_title_format, propertyName.replaceFirstChar { it.titlecase() })
        }
    }

    private fun showErrorDialog(message: String) {
        MaterialAlertDialogBuilder(this)
            .setTitle(R.string.dialog_error_details_title)
            .setMessage(message)
            .setPositiveButton(R.string.dialog_ok, null)
            .show()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---
package be.heyman.android.ai.kikko.forge

import android.app.Application
import android.content.Context
import android.graphics.BitmapFactory
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.concurrent.CancellationException
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

// BOURDON'S ADDITION: Data classes pour le r√©sum√© de la comp√©tition
data class CompetitionSummaryItem(
    val response: String,
    val voteCount: Int,
    val firstValidTask: AnalysisResult // On garde une t√¢che source pour la validation
)

data class CompetitionSummary(
    val propertyName: String,
    val items: List<CompetitionSummaryItem>
)

// BOURDON'S ADDITION: Machine d'√©tats pour le processus de Jugement Final.
sealed class JudgmentState {
    data object None : JudgmentState()
    data class InProgress(val propertyName: String, val prompt: String, val streamingResponse: String = "") : JudgmentState()
    data class Complete(val propertyName: String, val arbiterReasoning: String, val winningProposal: AnalysisResult) : JudgmentState()
    data class Failed(val propertyName: String, val error: String) : JudgmentState()
}

data class ForgeWorkshopUiState(
    val isLoading: Boolean = true,
    val workshopGrains: List<PollenGrain> = emptyList(),
    val selectedGrain: PollenGrain? = null,
    val selectedCard: KnowledgeCard? = null,
    val analysisResults: Map<String, List<AnalysisResult>> = emptyMap(),
    val competitionSummaries: Map<String, CompetitionSummary> = emptyMap(),
    val judgmentState: JudgmentState = JudgmentState.None, // BOURDON'S ADDITION: Le nouvel √©tat de jugement.
    val statusMessage: String? = null,
    val activeFilter: String = ForgeWorkshopViewModel.FILTER_RAW
)

class ForgeWorkshopViewModel(application: Application) : AndroidViewModel(application) {

    private val forgeRepository: ForgeRepository = (application as KikkoApplication).forgeRepository
    private val llmHelper: ForgeLlmHelper = (application as KikkoApplication).forgeLlmHelper
    private val pollenGrainDao: PollenGrainDao = (application as KikkoApplication).pollenGrainDao

    private val TAG = "KikkoForgeTrace"
    private val _uiState = MutableStateFlow(ForgeWorkshopUiState())
    val uiState = _uiState.asStateFlow()
    private val gson = Gson()

    private var competitionJob: Job? = null
    private var judgmentJob: Job? = null

    private var allWorkshopItems = listOf<Pair<PollenGrain, KnowledgeCard?>>()

    private val deckProperties = mapOf(
        "Food" to listOf("description", "ingredients", "allergens", "stats.energy"),
        "Plant" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.floweringPeriod"),
        "Insect" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.diet"),
        "Bird" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.wingspan")
    )

    private data class IdentificationResultData(
        val reasoning: Reasoning,
        val deckName: String,
        val specificName: String,
        val confidence: Float
    )

    companion object {
        const val FILTER_ALL = "ALL"
        const val FILTER_RAW = "RAW"
    }

    init {
        Log.d(TAG, "ViewModel initialis√©. Lancement du chargement initial des grains de pollen.")
        viewModelScope.launch {
            _uiState.update { it.copy(statusMessage = getString(R.string.workshop_loading_grains)) }
            loadWorkshopGrains()
        }
    }

    fun getPropertiesForDeck(deckName: String?): List<String> {
        val normalizedDeckName = deckName
            ?.trim()
            ?.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
            ?.removeSuffix("s")
        val properties = deckProperties[normalizedDeckName] ?: emptyList()
        return properties
    }


    fun selectGrain(grain: PollenGrain) {
        viewModelScope.launch {
            competitionJob?.cancel()
            judgmentJob?.cancel()
            Log.i(TAG, "[SELECT] S√©lection du grain ID: ${grain.id} | Statut: ${grain.status} | CardID li√©: ${grain.forgedCardId}")

            val card = allWorkshopItems.find { it.first.id == grain.id }?.second

            val newStatusMessage = if (grain.status == PollenStatus.AWAITING_VALIDATION || grain.status == PollenStatus.IDENTIFYING) {
                getString(R.string.workshop_awaiting_validation)
            } else {
                getString(R.string.workshop_ready_to_refine)
            }

            _uiState.update { it.copy(
                selectedGrain = grain,
                selectedCard = card,
                analysisResults = emptyMap(),
                competitionSummaries = emptyMap(),
                judgmentState = JudgmentState.None,
                statusMessage = newStatusMessage
            ) }

            if (card != null) {
                Log.d(TAG, "[SELECT] Carte charg√©e depuis la cache - ID: ${card.id}, Nom: '${card.specificName}', Deck: '${card.deckName}'")
            } else {
                Log.w(TAG, "[SELECT] Aucune carte n'a pu √™tre charg√©e pour ce grain.")
            }

            refreshAnalysisResults(grain.id, "identification")
            if (card?.deckName != "Unknown") {
                val properties = getPropertiesForDeck(card?.deckName)
                properties.forEach { propertyName ->
                    refreshAnalysisResults(grain.id, propertyName)
                }
            }
        }
    }

    fun setFilter(filterType: String) {
        viewModelScope.launch {
            if (_uiState.value.activeFilter == filterType) return@launch
            _uiState.update { it.copy(activeFilter = filterType) }
            updateFilteredGrains()
        }
    }

    private fun updateFilteredGrains() {
        val currentFilter = _uiState.value.activeFilter
        Log.d(TAG, "[FILTER] Application du filtre: $currentFilter")

        val filteredItems = when (currentFilter) {
            FILTER_RAW -> allWorkshopItems.filter { (grain, _) ->
                grain.status == PollenStatus.RAW ||
                        grain.status == PollenStatus.IDENTIFYING ||
                        grain.status == PollenStatus.AWAITING_VALIDATION ||
                        grain.status == PollenStatus.ERROR
            }
            else -> allWorkshopItems.filter { (_, card) -> card?.deckName == currentFilter }
        }

        val filteredGrains = filteredItems.map { it.first }
        _uiState.update { it.copy(workshopGrains = filteredGrains) }

        val selectedGrainStillVisible = filteredGrains.any { it.id == _uiState.value.selectedGrain?.id }
        if (!selectedGrainStillVisible) {
            val newGrainToSelect = filteredGrains.firstOrNull()
            if (newGrainToSelect != null) {
                selectGrain(newGrainToSelect)
            } else {
                _uiState.update { it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_in_deck)) }
            }
        }
    }


    fun createAnalysisTournament(propertyName: String) {
        val grain = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_preparing_competition, propertyName)) }

            val modelsToCompete = withContext(Dispatchers.IO) {
                val modelsDir = File(getApplication<Application>().filesDir, "imported_models")
                if (modelsDir.exists() && modelsDir.isDirectory) {
                    modelsDir.listFiles { _, name -> name.endsWith(".task") }?.map { it.name } ?: emptyList()
                } else {
                    emptyList()
                }
            }

            if (modelsToCompete.isEmpty()) {
                _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_no_queens_installed)) }
                return@launch
            }
            Log.i(TAG, "[COMPETITION] Reines en comp√©tition: ${modelsToCompete.joinToString()}")

            val accelerator = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                .getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU") ?: "GPU"

            val tasks = forgeRepository.createAnalysisTasksForProperty(grain.id, propertyName, modelsToCompete, accelerator)
            Log.i(TAG, "[COMPETITION] Cr√©ation de ${tasks.size} t√¢ches pour la propri√©t√© '$propertyName'.")

            refreshAnalysisResults(grain.id, propertyName)
            val message = getApplication<Application>().resources.getQuantityString(R.plurals.workshop_tasks_ready, tasks.size, tasks.size)
            _uiState.update { it.copy(isLoading = false, statusMessage = message) }

            launchCompetitionExecution(propertyName)
        }
    }

    fun relaunchAnalysisTournament(propertyName: String) {
        val grain = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, statusMessage = "Clearing old results for '$propertyName'...") }
            forgeRepository.clearAnalysisResultsForProperty(grain.id, propertyName)
            refreshAnalysisResults(grain.id, propertyName)
            createAnalysisTournament(propertyName)
        }
    }


    fun validateFromSummary(summaryItem: CompetitionSummaryItem) {
        Log.i(TAG, "[VALIDATE-SUMMARY] Validation demand√©e pour la r√©ponse '${summaryItem.response}' avec ${summaryItem.voteCount} votes.")
        validateProperty(summaryItem.firstValidTask)
    }

    fun validateAndCreateCardFromIdentification(task: AnalysisResult) {
        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch

            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_identification)) }
            }

            try {
                var resultData = parseIntelligentJson<IdentificationResultData>(rawResponse)

                if (resultData == null) {
                    val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
                    val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value

                    if (name != null && deck != null) {
                        resultData = IdentificationResultData(
                            specificName = name, deckName = deck,
                            reasoning = Reasoning(getString(R.string.fallback_reasoning_visual), getString(R.string.fallback_reasoning_correlation)),
                            confidence = 0.5f
                        )
                    } else {
                        throw IOException(getString(R.string.error_validation_parsing_failed))
                    }
                }

                var cardId = grain.forgedCardId
                if (cardId == null) {
                    val newCard = KnowledgeCard(
                        specificName = resultData.specificName, deckName = resultData.deckName,
                        imagePath = grain.pollenImagePaths.firstOrNull(), confidence = resultData.confidence,
                        reasoning = resultData.reasoning, description = null, stats = null, quiz = null, translations = null,
                        scientificName = null, vernacularName = null, allergens = null, ingredients = null
                    )
                    cardId = (getApplication<Application>().applicationContext as KikkoApplication).cardDao.insert(newCard)
                    pollenGrainDao.updateForgingResult(grain.id, grain.status, cardId)
                } else {
                    (getApplication<Application>().applicationContext as KikkoApplication).cardDao.updateIdentification(
                        cardId = cardId, specificName = resultData.specificName, deckName = resultData.deckName,
                        reasoning = resultData.reasoning, confidence = resultData.confidence
                    )
                }

                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_DESCRIPTION)

                withContext(Dispatchers.Main) {
                    loadWorkshopGrains()
                }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-ID] √âchec critique du processus de validation.", e)
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message ?: getString(R.string.error_unknown))) }
                }
            }
        }
    }

    fun validateProperty(task: AnalysisResult) {
        if (task.propertyName == "identification") {
            validateAndCreateCardFromIdentification(task)
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val cardId = grain.forgedCardId ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch
            Log.i(TAG, "[VALIDATE-PROP] Validation de la propri√©t√© '${task.propertyName}' avec la r√©ponse de la t√¢che ${task.id}.")


            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_property, task.propertyName)) }
            }

            try {
                val propertyJson = parseIntelligentJson<JsonObject>(rawResponse)
                    ?: throw IOException(getString(R.string.error_json_malformed))

                val valueElement = propertyJson.get(task.propertyName)
                    ?: throw IOException(getString(R.string.error_json_key_missing, task.propertyName))

                val valueAsString = if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)

                forgeRepository.updateCardProperty(cardId, task.propertyName, valueAsString)

                val nextStatus = getNextStatus(grain.status)
                pollenGrainDao.updateStatus(grain.id, nextStatus)

                withContext(Dispatchers.Main) {
                    loadWorkshopGrains()
                }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-PROP] √âchec de la validation pour la propri√©t√© '${task.propertyName}'.", e)
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message ?: getString(R.string.error_unknown))) }
                }
            }
        }
    }

    private fun getNextStatus(currentStatus: PollenStatus): PollenStatus {
        return when (currentStatus) {
            PollenStatus.PENDING_DESCRIPTION -> PollenStatus.PENDING_STATS
            PollenStatus.PENDING_STATS -> PollenStatus.PENDING_QUIZ
            PollenStatus.PENDING_QUIZ -> PollenStatus.PENDING_TRANSLATION
            PollenStatus.PENDING_TRANSLATION -> PollenStatus.FORGED
            else -> currentStatus
        }
    }

    // BOURDON'S REFORGE V2: L'Orchestrateur Royal.
    private fun launchCompetitionExecution(propertyName: String, singleTaskToRun: AnalysisResult? = null) {
        competitionJob?.cancel()
        competitionJob = viewModelScope.launch(Dispatchers.IO) {
            val tasksToRun = singleTaskToRun?.let { listOf(it) }
                ?: _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.PENDING }
                ?: emptyList()

            if (tasksToRun.isEmpty()) {
                Log.w(TAG, "[ORCHESTRATOR] Lancement demand√© pour '$propertyName', mais aucune t√¢che en attente trouv√©e.")
                return@launch
            }

            // Regrouper les t√¢ches par Reine (nom du mod√®le).
            val tasksByQueen = tasksToRun.groupBy {
                gson.fromJson(it.modelConfigJson, ModelConfiguration::class.java).modelName
            }
            Log.i(TAG, "[ORCHESTRATOR] Lancement pour ${tasksToRun.size} t√¢ches, r√©parties sur ${tasksByQueen.size} Reine(s).")

            for ((modelName, tasksForQueen) in tasksByQueen) {
                Log.i(TAG, "[ORCHESTRATOR] Convocation de la Reine '$modelName' pour ${tasksForQueen.size} t√¢che(s).")
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) {
                    Log.e(TAG, "[ORCHESTRATOR] √âchec : Fichier de la Reine IA '$modelName' introuvable.")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Model file not found") }
                    continue // Passe √† la Reine suivante
                }

                val isMultimodal = tasksForQueen.any { it.propertyName == "identification" || it.propertyName == "description" }
                val queenModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = modelName.contains("gemma-3n", ignoreCase = true))
                val accelerator = gson.fromJson(tasksForQueen.first().modelConfigJson, ModelConfiguration::class.java).accelerator

                val initError = llmHelper.initialize(queenModel, accelerator, isMultimodal)
                if (initError != null) {
                    Log.e(TAG, "[ORCHESTRATOR] √âchec de l'initialisation de la Reine '$modelName': $initError")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Initialization failed: $initError") }
                    continue
                }

                try {
                    for (task in tasksForQueen) {
                        val success = runSingleTask(task)
                        if (!success) {
                            Log.w(TAG, "[ORCHESTRATOR] La t√¢che ${task.id.substring(0,4)} a √©chou√©. La Reine '$modelName' continue avec la t√¢che suivante.")
                        }
                    }
                } finally {
                    Log.i(TAG, "[ORCHESTRATOR] La Reine '$modelName' a termin√© son service. Nettoyage des ressources.")
                    llmHelper.cleanUp()
                }
            }
            Log.i(TAG, "[ORCHESTRATOR] Toutes les Reines ont termin√© leur service pour la propri√©t√© '$propertyName'.")
        }
    }

    private suspend fun runSingleTask(task: AnalysisResult): Boolean {
        return try {
            withContext(Dispatchers.Main) { updateTaskStatusInUi(task.id, task.propertyName) { it.copy(status = AnalysisStatus.RUNNING, streamingResponse = "") } }

            val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
            val isMultimodalTask = task.propertyName == "identification" || task.propertyName == "description"
            val parentGrain = _uiState.value.selectedGrain ?: throw IllegalStateException("Parent pollen grain not found")
            val swarmReportJson = parentGrain.swarmAnalysisReportJson ?: throw IOException("Swarm report missing")
            val images = if (isMultimodalTask) parentGrain.pollenImagePaths.mapNotNull { BitmapFactory.decodeFile(it) } else emptyList()

            val prompt = when(task.propertyName) {
                "identification" -> ForgePromptGenerator.generateIdentificationTournamentPrompt(swarmReportJson)
                else -> {
                    val card = cardDao.getCardById(parentGrain.forgedCardId ?: -1) ?: throw IllegalStateException("Card not found for refinement")
                    // Note: La logique de d√©pendance (ex: allerg√®nes) est simplifi√©e ici pour la clart√©.
                    // Une impl√©mentation compl√®te la g√©rerait ici.
                    ForgePromptGenerator.generatePropertyForgePrompt(
                        propertyName = task.propertyName, deckName = card.deckName, specificName = card.specificName,
                        swarmReportJson = swarmReportJson, existingDescription = card.description, dependencyDataJson = null
                    )
                }
            }

            llmHelper.resetSession(Model(name=config.modelName, url="", downloadFileName="", sizeInBytes=0), isMultimodalTask, config.temperature, config.topK)

            val fullResponse = suspendCoroutine<String> { continuation ->
                val responseBuilder = StringBuilder()
                llmHelper.runInference(prompt, images) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    viewModelScope.launch(Dispatchers.Main) { updateTaskStatusInUi(task.id, task.propertyName) { it.copy(streamingResponse = responseBuilder.toString()) } }
                    if (done && continuation.isActive) continuation.resume(responseBuilder.toString())
                }
            }

            val updatedTask = task.copy(status = AnalysisStatus.COMPLETED, rawResponse = fullResponse, streamingResponse = null)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) { refreshAnalysisResults(task.pollenGrainId, task.propertyName) }
            true
        } catch (e: Exception) {
            if (e is CancellationException) {
                Log.i(TAG, "[TASK-CANCEL] T√¢che ${task.id.substring(0,4)} annul√©e.")
                updateTaskStatusInDb(task.id, task.pollenGrainId, task.propertyName, AnalysisStatus.CANCELLED)
            } else {
                Log.e(TAG, "[TASK-FAIL] √âchec T√¢che ${task.id.substring(0,4)}", e)
                updateTaskStatusInDb(task.id, task.pollenGrainId, task.propertyName, AnalysisStatus.FAILED, e.message)
            }
            false
        }
    }

    fun launchFinalJudgment(propertyName: String) {
        judgmentJob?.cancel()
        val proposals = _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.COMPLETED }
        if (proposals.isNullOrEmpty()) {
            viewModelScope.launch { _uiState.update { it.copy(statusMessage = "Aucune proposition valide √† juger.") } }
            return
        }

        judgmentJob = viewModelScope.launch(Dispatchers.IO) {
            val prompt = ForgePromptGenerator.generateJudgmentPrompt(propertyName, proposals)
            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(judgmentState = JudgmentState.InProgress(propertyName, prompt)) }
            }

            try {
                val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                val modelName = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null) ?: throw IOException("Aucune Reine s√©lectionn√©e pour √™tre l'Arbitre.")
                val accelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) throw IOException("Fichier de la Reine Arbitre introuvable.")
                val arbiterModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0)
                val config = ModelConfiguration(modelName, accelerator, 0.1f, 1)

                val initError = llmHelper.initialize(arbiterModel, accelerator, false)
                if(initError != null) throw RuntimeException("√âchec de l'initialisation de l'Arbitre: $initError")

                val responseBuilder = StringBuilder()
                llmHelper.runInferenceWithConfig(prompt, emptyList(), config) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    viewModelScope.launch(Dispatchers.Main) {
                        _uiState.update {
                            val currentState = it.judgmentState
                            if(currentState is JudgmentState.InProgress) {
                                it.copy(judgmentState = currentState.copy(streamingResponse = responseBuilder.toString()))
                            } else it
                        }
                    }

                    if (done) {
                        val arbiterResponse = parseArbiterResponse(responseBuilder.toString(), proposals)
                        viewModelScope.launch(Dispatchers.Main) {
                            if (arbiterResponse != null) {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Complete(propertyName, arbiterResponse.first, arbiterResponse.second)) }
                            } else {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, "Impossible de parser le verdict de l'Arbitre.")) }
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, e.message ?: "Erreur inconnue de l'Arbitre."))}
                }
            }
        }
    }

    private data class ArbiterVerdict(val arbiterReasoning: String, val bestProposal: JsonObject)

    private fun parseArbiterResponse(rawResponse: String, originalProposals: List<AnalysisResult>): Pair<String, AnalysisResult>? {
        Log.d(TAG, "[ARBITER-PARSE] Tentative de parsing du verdict de l'Arbitre.")
        val verdict = parseIntelligentJson<ArbiterVerdict>(rawResponse)
        if (verdict == null) {
            Log.e(TAG, "[ARBITER-PARSE] √âCHEC. Le verdict de l'Arbitre est malform√© ou vide.")
            return null
        }

        Log.d(TAG, "[ARBITER-PARSE] Verdict pars√© avec succ√®s. Recherche de la proposition gagnante...")
        val winningProposal = originalProposals.find {
            it.rawResponse?.let { originalRaw ->
                try {
                    val originalJsonObj = parseIntelligentJson<JsonObject>(originalRaw)
                    originalJsonObj != null && originalJsonObj == verdict.bestProposal
                } catch (e: Exception) {
                    false
                }
            } ?: false
        }

        return if (winningProposal != null) {
            Log.i(TAG, "[ARBITER-PARSE] SUCC√àS. Proposition gagnante trouv√©e (T√¢che ID: ${winningProposal.id.substring(0,4)}).")
            Pair(verdict.arbiterReasoning, winningProposal)
        } else {
            Log.e(TAG, "[ARBITER-PARSE] √âCHEC. Aucune proposition originale ne correspond au verdict de l'Arbitre.")
            null
        }
    }

    fun confirmJudgment() {
        val currentState = _uiState.value.judgmentState
        if (currentState is JudgmentState.Complete) {
            validateProperty(currentState.winningProposal)
            dismissJudgment()
        }
    }

    fun dismissJudgment() {
        _uiState.update { it.copy(judgmentState = JudgmentState.None) }
    }

    fun cancelCompetition(propertyName: String) {
        competitionJob?.cancel()
        Log.i(TAG, "[AUTO-FORGE] Comp√©tition pour '$propertyName' annul√©e par l'utilisateur.")
    }

    fun retryAnalysisTask(task: AnalysisResult) {
        launchCompetitionExecution(task.propertyName, singleTaskToRun = task)
    }

    fun deleteSelectedGrain() {
        val grainToDelete = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                forgeRepository.deletePollenGrainAndAssociatedData(grainToDelete)
            }
            loadWorkshopGrains()
        }
    }

    private suspend fun updateTaskStatusInDb(taskId: String, grainId: String, propertyName: String, newStatus: AnalysisStatus, errorMessage: String? = null) {
        val currentTask = forgeRepository.getAnalysisResults(grainId, propertyName).find { it.id == taskId }
        if (currentTask != null) {
            val updatedTask = currentTask.copy(status = newStatus, errorMessage = errorMessage)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) {
                refreshAnalysisResults(grainId, propertyName)
            }
        }
    }

    private fun updateTaskStatusInUi(taskId: String, propertyName: String, updateAction: (AnalysisResult) -> AnalysisResult) {
        _uiState.update { currentState ->
            val newMap = currentState.analysisResults.toMutableMap()
            val propertyTasks = newMap[propertyName]?.toMutableList()
            val taskIndex = propertyTasks?.indexOfFirst { it.id == taskId }

            if (propertyTasks != null && taskIndex != null && taskIndex != -1) {
                propertyTasks[taskIndex] = updateAction(propertyTasks[taskIndex])
                newMap[propertyName] = propertyTasks
                currentState.copy(analysisResults = newMap)
            } else {
                currentState
            }
        }
    }

    private suspend fun loadWorkshopGrains() {
        _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_loading_grains)) }

        val grains = forgeRepository.getGrainsForWorkshop() + pollenGrainDao.getByStatus(PollenStatus.AWAITING_VALIDATION) + pollenGrainDao.getByStatus(PollenStatus.ERROR)
        val items = grains.distinctBy { it.id }.sortedByDescending { it.timestamp }.map { grain ->
            val card = forgeRepository.getCardForGrain(grain)
            Pair(grain, card)
        }
        allWorkshopItems = items

        _uiState.update { it.copy(isLoading = false) }
        updateFilteredGrains()

        val grainToSelect = _uiState.value.workshopGrains.firstOrNull()
        if (grainToSelect != null) {
            selectGrain(grainToSelect)
        } else {
            _uiState.update { it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_to_forge)) }
        }
    }

    private suspend fun refreshAnalysisResults(pollenGrainId: String, propertyName: String) {
        val results = forgeRepository.getAnalysisResults(pollenGrainId, propertyName)

        _uiState.update { currentState ->
            val newAnalysisMap = currentState.analysisResults.toMutableMap().apply { this[propertyName] = results }
            val newSummariesMap = currentState.competitionSummaries.toMutableMap()

            val hasCompletedTasks = results.any { it.status == AnalysisStatus.COMPLETED }
            if (hasCompletedTasks) {
                Log.d(TAG, "[SUMMARY] Au moins une t√¢che pour '$propertyName' est termin√©e. Calcul du r√©sum√©.")
                val summary = createCompetitionSummary(propertyName, results)
                if (summary.items.isNotEmpty()) {
                    newSummariesMap[propertyName] = summary
                } else {
                    newSummariesMap.remove(propertyName)
                }
            } else {
                newSummariesMap.remove(propertyName)
            }
            currentState.copy(analysisResults = newAnalysisMap, competitionSummaries = newSummariesMap)
        }
    }

    private fun createCompetitionSummary(propertyName: String, results: List<AnalysisResult>): CompetitionSummary {
        val completedTasks = results.filter { it.status == AnalysisStatus.COMPLETED && !it.rawResponse.isNullOrBlank() }
        if (completedTasks.isEmpty()) return CompetitionSummary(propertyName, emptyList())

        val responseGroups = completedTasks.groupBy { task ->
            extractValueFromResponse(task.rawResponse!!, propertyName)
        }.filterKeys { it.isNotBlank() }

        val summaryItems = responseGroups.map { (response, tasks) ->
            CompetitionSummaryItem(response = response, voteCount = tasks.size, firstValidTask = tasks.first())
        }.sortedByDescending { it.voteCount }
        Log.d(TAG, "[SUMMARY] Cr√©ation du r√©sum√© pour '$propertyName': ${summaryItems.size} proposition(s) unique(s) trouv√©e(s).")
        return CompetitionSummary(propertyName, summaryItems)
    }

    private fun extractValueFromResponse(rawResponse: String, propertyName: String): String {
        try {
            val propertyJson = parseIntelligentJson<JsonObject>(rawResponse)
            if (propertyJson != null) {
                return when (propertyName) {
                    "identification" -> {
                        val name = propertyJson.get("specificName")?.asString ?: ""
                        val deck = propertyJson.get("deckName")?.asString ?: ""
                        if (name.isNotBlank() && deck.isNotBlank()) "$deck: $name" else ""
                    }
                    else -> {
                        val valueElement = propertyJson.get(propertyName)
                        if (valueElement != null) {
                            if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)
                        } else ""
                    }
                }
            }
        } catch (e: Exception) {
            Log.w(TAG, "[PARSER] Le parsing JSON a √©chou√© pour '$propertyName', tentative de fallback. Erreur: ${e.message}")
        }

        if (propertyName == "identification") {
            val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
            val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
            if (name != null && deck != null) {
                Log.i(TAG, "[EXTRACT-REGEX] Fallback r√©ussi pour identification: '$deck: $name'")
                return "$deck: $name"
            }
        }
        return ""
    }


    private inline fun <reified T> parseIntelligentJson(rawString: String): T? {
        val firstBrace = rawString.indexOf('{')
        if (firstBrace == -1) return null

        var braceCount = 0
        var lastBrace = -1
        for (i in firstBrace until rawString.length) {
            when (rawString[i]) {
                '{' -> braceCount++
                '}' -> braceCount--
            }
            if (braceCount == 0) {
                lastBrace = i
                break
            }
        }

        if (lastBrace == -1) return null
        val jsonSubstring = rawString.substring(firstBrace, lastBrace + 1)
        Log.d(TAG, "[PARSER] JSON isol√© pour l'analyse: $jsonSubstring")

        return try {
            val type = object : TypeToken<T>() {}.type
            gson.fromJson(jsonSubstring, type)
        } catch (e: JsonSyntaxException) {
            Log.e(TAG, "[PARSER] Erreur de syntaxe Gson pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        } catch (e: Exception) {
            Log.e(TAG, "[PARSER] Erreur inattendue lors du parsing pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        }
    }

    private fun getString(resId: Int, vararg formatArgs: Any): String {
        return getApplication<Application>().getString(resId, *formatArgs)
    }

    override fun onCleared() {
        super.onCleared()
        competitionJob?.cancel()
        judgmentJob?.cancel()
        llmHelper.cleanUp()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/JudgmentDialogFragment.kt ---

package be.heyman.android.ai.kikko.forge

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.core.view.isVisible
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.AnalysisStatus
import com.google.android.material.card.MaterialCardView
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

class JudgmentDialogFragment : DialogFragment() {

    private val viewModel: ForgeWorkshopViewModel by activityViewModels()

    private lateinit var streamingResponseTextView: TextView
    private lateinit var promptContentTextView: TextView
    private lateinit var evidenceContentTextView: TextView
    private lateinit var confirmButton: Button
    private lateinit var overrideButton: Button
    // BOURDON'S ADDITION: Vues pour l'avertissement de sagesse.
    private lateinit var judgmentWarningCard: MaterialCardView
    private lateinit var judgmentWarningText: TextView


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NORMAL, R.style.Theme_Kikko_FullScreenDialog)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.dialog_judgment, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle(R.string.judgment_dialog_title)

        bindViews(view)
        setupListeners()
        observeViewModel()
    }

    private fun bindViews(view: View) {
        streamingResponseTextView = view.findViewById(R.id.judgment_streaming_response)
        promptContentTextView = view.findViewById(R.id.judgment_prompt_content)
        evidenceContentTextView = view.findViewById(R.id.judgment_evidence_content)
        confirmButton = view.findViewById(R.id.judgment_button_confirm)
        overrideButton = view.findViewById(R.id.judgment_button_override)
        // BOURDON'S ADDITION: Liaison des nouvelles vues.
        judgmentWarningCard = view.findViewById(R.id.judgment_warning_card)
        judgmentWarningText = view.findViewById(R.id.judgment_warning_text)
    }

    private fun setupListeners() {
        confirmButton.setOnClickListener {
            viewModel.confirmJudgment()
        }
        overrideButton.setOnClickListener {
            viewModel.dismissJudgment()
        }
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collectLatest { state ->
                when (val judgment = state.judgmentState) {
                    is JudgmentState.InProgress -> {
                        promptContentTextView.text = judgment.prompt
                        streamingResponseTextView.text = judgment.streamingResponse
                        evidenceContentTextView.text = "L'Arbitre d√©lib√®re..."
                        confirmButton.isEnabled = false
                        overrideButton.text = getString(R.string.dialog_cancel)
                        checkCompetitionStatus(state, judgment.propertyName)
                    }
                    is JudgmentState.Complete -> {
                        val winningProposalText = "Proposition Gagnante (par ${judgment.winningProposal.modelConfigJson}):\n${judgment.winningProposal.rawResponse}"
                        streamingResponseTextView.text = "${judgment.arbiterReasoning}\n\n$winningProposalText"
                        confirmButton.isEnabled = true
                        overrideButton.text = getString(R.string.judgment_button_override)
                        checkCompetitionStatus(state, judgment.propertyName)
                    }
                    is JudgmentState.Failed -> {
                        streamingResponseTextView.text = "Erreur du Jugement : ${judgment.error}"
                        confirmButton.isEnabled = false
                        overrideButton.text = getString(R.string.dialog_cancel)
                        judgmentWarningCard.isVisible = false
                    }
                    JudgmentState.None -> {
                        // L'activit√© g√®re la fermeture.
                    }
                }
            }
        }
    }

    // BOURDON'S ADDITION: Nouvelle fonction pour afficher l'avertissement.
    private fun checkCompetitionStatus(state: ForgeWorkshopUiState, propertyName: String) {
        val allTasks = state.analysisResults[propertyName] ?: emptyList()
        if (allTasks.isEmpty()) {
            judgmentWarningCard.isVisible = false
            return
        }

        val totalTasks = allTasks.size
        val finishedTasks = allTasks.count { it.status in listOf(AnalysisStatus.COMPLETED, AnalysisStatus.FAILED, AnalysisStatus.CANCELLED) }

        if (finishedTasks < totalTasks) {
            judgmentWarningText.text = getString(R.string.judgment_warning_in_progress, finishedTasks, totalTasks)
            judgmentWarningCard.isVisible = true
        } else {
            judgmentWarningCard.isVisible = false
        }
    }

    companion object {
        const val TAG = "JudgmentDialogFragment"
        fun newInstance(): JudgmentDialogFragment {
            return JudgmentDialogFragment()
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/JudgmentDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenGrainAdapter.kt ---

package be.heyman.android.ai.kikko.forge

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.PollenGrain
import com.google.android.material.chip.Chip
import java.io.File

/**
 * Adaptateur pour afficher la liste horizontale des PollenGrains dans l'Atelier de la Forge.
 * G√®re l'affichage de l'aper√ßu et l'√©tat de s√©lection.
 */
class PollenGrainAdapter(
    private var grains: List<PollenGrain>,
    private var selectedCardId: String?,
    private val onClick: (PollenGrain) -> Unit
) : RecyclerView.Adapter<PollenGrainAdapter.ViewHolder>() {

    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.pollen_preview_image)
        val statusChip: Chip = view.findViewById(R.id.pollen_preview_status_chip)
        val nameTextView: TextView = view.findViewById(R.id.pollen_preview_name)
        val selectionBorder: View = view.findViewById(R.id.pollen_preview_selection_border)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_pollen_grain_preview, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val grain = grains[position]

        // Affiche le nom s'il existe, sinon l'ID court.
        holder.nameTextView.text = grain.forgedCardId?.toString() ?: "Pollen #${grain.id.substring(0, 4)}"
        holder.statusChip.text = grain.status.name

        // Affiche la premi√®re image du grain.
        grain.pollenImagePaths.firstOrNull()?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                holder.imageView.setImageBitmap(BitmapFactory.decodeFile(imgFile.absolutePath))
            } else {
                holder.imageView.setImageResource(R.drawable.ic_placeholder_card)
            }
        } ?: holder.imageView.setImageResource(R.drawable.ic_placeholder_card)

        // G√®re la visibilit√© de la bordure de s√©lection.
        holder.selectionBorder.visibility = if (grain.id == selectedCardId) View.VISIBLE else View.GONE

        holder.itemView.setOnClickListener { onClick(grain) }
    }

    override fun getItemCount() = grains.size

    /**
     * Met √† jour la liste des grains et l'ID de la s√©lection, puis rafra√Æchit l'affichage.
     */
    fun updateGrainsAndSelection(newGrains: List<PollenGrain>, newSelectedCardId: String?) {
        this.grains = newGrains
        this.selectedCardId = newSelectedCardId
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenGrainAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenPreviewAdapter.kt ---

package be.heyman.android.ai.kikko.forge

import android.graphics.Bitmap
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.ImageView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R

/**
 * Un adaptateur pour le RecyclerView qui affiche une pr√©visualisation horizontale
 * des images (pollen) s√©lectionn√©es par l'utilisateur.
 *
 * @param pollenImages La liste mutable des bitmaps √† afficher.
 * @param onRemoveClick Une fonction lambda appel√©e lorsqu'un utilisateur clique sur le bouton de suppression
 * d'une image, passant l'index de l'image √† supprimer.
 */
class PollenPreviewAdapter(
    private val pollenImages: MutableList<Bitmap>,
    private val onRemoveClick: (Int) -> Unit
) : RecyclerView.Adapter<PollenPreviewAdapter.PollenViewHolder>() {

    /**
     * ViewHolder qui contient les vues pour un seul item de pr√©visualisation de pollen.
     */
    inner class PollenViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.pollen_preview_imageview)
       /* val removeButton//: ImageButton = view.findViewById(R.id.pollen_remove_button)

        init {
            removeButton.setOnClickListener {
                // S'assure que la position est valide avant de d√©clencher le callback
                val position = adapterPosition
                if (position != RecyclerView.NO_POSITION) {
                    onRemoveClick(position)
                }
            }
        }

        */
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PollenViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_pollen_preview, parent, false)
        return PollenViewHolder(view)
    }

    override fun onBindViewHolder(holder: PollenViewHolder, position: Int) {
        val bitmap = pollenImages[position]
        holder.imageView.setImageBitmap(bitmap)
    }

    override fun getItemCount(): Int = pollenImages.size

    /**
     * Met √† jour la liste des images affich√©es par l'adaptateur.
     * @param newImages La nouvelle liste de bitmaps.
     */
    fun updateImages(newImages: List<Bitmap>) {
        pollenImages.clear()
        pollenImages.addAll(newImages)
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenPreviewAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PromptGenerator.kt ---

package be.heyman.android.ai.kikko.forge

import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.QuizQuestion
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.model.TranslatedContent
import be.heyman.android.ai.kikko.prompt.PromptManager
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.IOException
import java.util.Locale

/**
 * BOURDON'S REFORGE (v4.0): Ce g√©n√©rateur est maintenant un H√âRAUT.
 * Il ne cr√©e plus de prompts lui-m√™me, mais r√©cup√®re les d√©crets officiels du
 * PromptManager et les formate avec les donn√©es sp√©cifiques √† la mission.
 * L'ancien code de g√©n√©ration de prompt a √©t√© supprim√© et remplac√© par des
 * appels √† String.format.
 */
object PromptGenerator {

    // --- LOGIQUE SP√âCIFIQUE √Ä LA FORGE (NE SONT PAS DES PROMPTS) ---

    // Stats attendues par deck pour le prompt de g√©n√©ration de stats.
    private val deckStats = mapOf(
        "Bird" to listOf("Wingspan (cm)", "Average Weight (g)", "Lifespan (years)", "Clutch Size (eggs)"),
        "Insect" to listOf("Average Length (mm)", "Lifespan (days)", "Number of Legs", "Flying Speed (km/h)"),
        "Plant" to listOf("Maximum Height (m)", "Flowering Period (months)", "Lifespan (years)", "Minimum Temperature (¬∞C)"),
        "Food" to listOf("Energy (kcal per 100g)", "Protein (g per 100g)")
    )

    // Liste des allerg√®nes majeurs pour le prompt de g√©n√©ration de stats.
    private val majorAllergensList = listOf(
        "Cereals containing gluten", "Crustaceans", "Eggs", "Fish", "Peanuts",
        "Soybeans", "Milk", "Nuts", "Celery", "Mustard", "Sesame seeds",
        "Sulphur dioxide and sulphites", "Lupin", "Molluscs"
    )
    // --- FIN DE LA LOGIQUE SP√âCIFIQUE ---


    fun generateIdentificationPrompt(swarmReportJson: String): String {
        val rawPrompt = PromptManager.getPrompt("forge_identification")
        return String.format(rawPrompt, swarmReportJson)
    }

    fun generateNarrationDescriptionPrompt(subject: String, deckName: String, locale: Locale): String {
        val rawPrompt = PromptManager.getPrompt("forge_description")
        val languageName = when (locale.language) {
            "fr" -> "French"
            "ja" -> "Japanese"
            else -> "English"
        }
        val lowerSubject = subject.lowercase(locale)
        return String.format(rawPrompt, deckName, lowerSubject, languageName)
    }

    fun generateStatsExtractionPrompt(specificName: String, deckName: String, ocrText: String, description: String): String {
        val statsToFind = deckStats[deckName]
        if (statsToFind == null && deckName != "Food") return "" // Pas de stats pour les decks non-Food/non-biologiques d√©finis
        val statsString = statsToFind?.joinToString(", ") ?: ""
        val lowerSpecificName = specificName.lowercase(Locale.getDefault())

        val allergenContext = if (deckName == "Food") {
            """
            Additionally, you MUST identify all allergens from the `[ALLERGEN_LIST]`.
            [ALLERGEN_LIST]: [${majorAllergensList.joinToString(", ")}]
            Finally, you MUST extract the list of ingredients.
            """
        } else ""

        val exampleOutput = when (deckName) {
            "Food" -> """{"stats": {"Energy (kcal per 100g)": "520", "Protein (g per 100g)": "5.8"}, "allergens": ["Milk", "Soybeans"], "ingredients": ["Wheat flour", "Sugar"]}"""
            "Bird" -> """{"stats": {"Wingspan (cm)": "22.0", "Lifespan (years)": "2.0"}, "scientificName": "...", "vernacularName": "..."}"""
            "Insect" -> """{"stats": {"Average Length (mm)": "15.0", "Lifespan (days)": "30.0"}, "scientificName": "...", "vernacularName": "..."}"""
            "Plant" -> """{"stats": {"Maximum Height (m)": "0.6", "Flowering Period (months)": "3.0"}, "scientificName": "...", "vernacularName": "..."}"""
            else -> "{}"
        }

        val rawPrompt = PromptManager.getPrompt("forge_stats")
        return String.format(rawPrompt, lowerSpecificName, statsString, allergenContext, exampleOutput, ocrText, description)
    }

    fun generateQuizPrompt(subject: String, description: String, stats: CardStats?, locale: Locale): String {
        val rawPrompt = PromptManager.getPrompt("forge_quiz")
        val statsJson = if (stats != null) Gson().toJson(stats.items) else "{}"
        val languageName = when (locale.language) {
            "fr" -> "French"
            "ja" -> "Japanese"
            else -> "English"
        }
        return String.format(rawPrompt, languageName, description, statsJson)
    }

    fun generateFullCardTranslationPrompt(originalContentJson: String, targetLanguageName: String): String {
        val rawPrompt = PromptManager.getPrompt("forge_translation")
        return String.format(rawPrompt, targetLanguageName, originalContentJson)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PromptGenerator.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/StreamingJsonParser.kt ---

package be.heyman.android.ai.kikko.forge

import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import be.heyman.android.ai.kikko.model.IdentificationResult

/**
 * Un analyseur JSON intelligent et tol√©rant aux pannes, con√ßu pour interpr√©ter
 * la sortie parfois imparfaite des LLMs en streaming.
 */
class StreamingJsonParser {

    private var buffer = ""
    private val gson = Gson()

    /**
     * Contient le r√©sultat partiel ou complet d'une analyse JSON en streaming.
     */
    data class ParsedResult(
        val specificName: String = "",
        val deckName: String = "",
        val reasoning: Map<String, String> = emptyMap(),
        val confidence: Float = 0.0f,
        val isComplete: Boolean = false
    )

    fun process(chunk: String): ParsedResult {
        buffer += chunk

        // Tentative 1: Essayer de parser le JSON le plus complet possible.
        val firstBrace = buffer.indexOf('{')
        val lastBrace = buffer.lastIndexOf('}')

        if (firstBrace != -1 && lastBrace > firstBrace) {
            val potentialJson = buffer.substring(firstBrace, lastBrace + 1)
            try {
                // Essai avec Gson, le plus strict
                val result: IdentificationResult = gson.fromJson(potentialJson, IdentificationResult::class.java)
                if (result.specificName.isNotBlank() && result.deckName.isNotBlank()) {
                    return ParsedResult(
                        specificName = result.specificName,
                        deckName = result.deckName,
                        reasoning = mapOf(
                            "visualAnalysis" to result.reasoning.visualAnalysis,
                            "evidenceCorrelation" to result.reasoning.evidenceCorrelation
                        ),
                        confidence = result.confidence,
                        isComplete = true
                    )
                }
            } catch (e: JsonSyntaxException) {
                // Le JSON est malform√©. On passe √† la tentative 2.
            }
        }

        // Tentative 2: Extraction manuelle des champs cl√©s, tol√©rante aux erreurs.
        val specificName = extractStringValue("specificName")
        val deckName = extractStringValue("deckName")

        val isPotentiallyComplete = specificName.isNotBlank() && deckName.isNotBlank() && buffer.contains("confidence")

        return ParsedResult(
            specificName = specificName,
            deckName = deckName,
            isComplete = isPotentiallyComplete
        )
    }

    private fun extractStringValue(key: String): String {
        val keyPattern = "\"$key\"\\s*:\\s*\"(.*?)\""
        val regex = keyPattern.toRegex()
        val match = regex.find(buffer)
        return match?.groups?.get(1)?.value ?: ""
    }

    fun reset() {
        buffer = ""
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/StreamingJsonParser.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/SwarmAnalysisData.kt ---

package be.heyman.android.ai.kikko.forge

/**
 * Contient le r√©sultat complet d'une analyse d'essaim sur plusieurs images.
 * @param reports La liste des rapports d'analyse pour chaque image.
 */
data class SwarmAnalysisResult(
    val reports: List<ImageAnalysisReport>
)

/**
 * Contient le rapport d'analyse d'une seule image par les Abeilles Sp√©cialistes.
 * @param detectedObjects La liste des objets d√©tect√©s.
 * @param globalClassifierResults Une map des r√©sultats des classifieurs, o√π la cl√© est le nom du classifieur.
 * @param ocrText Le texte brut reconnu par l'OCR.
 */
data class ImageAnalysisReport(
    val detectedObjects: List<SimpleDetectedObject>,
    val globalClassifierResults: Map<String, List<SimpleImageLabel>>,
    val ocrText: String
)

/**
 * Une repr√©sentation simplifi√©e d'un objet d√©tect√© par ML Kit.
 * @param labels La liste des labels associ√©s √† cet objet.
 */
data class SimpleDetectedObject(
    val labels: List<SimpleImageLabel>
)

/**
 * Une repr√©sentation simplifi√©e d'un label d'image (pour les objets ou les classifieurs).
 * @param text Le nom du label (ex: "Cat", "Eiffel Tower").
 * @param confidence Le score de confiance de la d√©tection (entre 0.0 et 1.0).
 */
data class SimpleImageLabel(
    val text: String,
    val confidence: Float
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/SwarmAnalysisData.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/AnalysisResult.kt ---

package be.heyman.android.ai.kikko.model

import android.os.Parcelable
import kotlinx.parcelize.Parcelize
import java.util.UUID

/**
 * D√©finit les √©tats possibles pour une seule t√¢che d'analyse
 * lanc√©e depuis l'Atelier de la Forge.
 * BOURDON'S REFORGE: Ajout des √©tats pour un contr√¥le granulaire des t√¢ches.
 */
enum class AnalysisStatus {
    PENDING,   // La t√¢che est en file d'attente, pr√™te √† √™tre lanc√©e.
    RUNNING,   // La t√¢che est en cours d'ex√©cution.
    PAUSED,    // La t√¢che a √©t√© mise en pause par l'utilisateur.
    CANCELLED, // La t√¢che a √©t√© annul√©e par l'utilisateur.
    COMPLETED, // La t√¢che s'est termin√©e avec succ√®s.
    FAILED     // La t√¢che a √©chou√©.
}

/**
 * Encapsule la configuration exacte d'un mod√®le IA pour une t√¢che d'analyse.
 * Permet de diff√©rencier les r√©sultats d'un tournoi.
 */
@Parcelize
data class ModelConfiguration(
    val modelName: String,
    val accelerator: String,
    val temperature: Float,
    val topK: Int
) : Parcelable

/**
 * Repr√©sente une seule t√¢che d'analyse (et son r√©sultat) lanc√©e sur une propri√©t√©
 * d'un PollenGrain. Cet objet sera stock√© dans une nouvelle table de la base de donn√©es.
 *
 * @param id Identifiant unique de la t√¢che d'analyse.
 * @param pollenGrainId L'ID du PollenGrain parent auquel cette t√¢che est associ√©e.
 * @param propertyName Le nom de la propri√©t√© analys√©e (ex: "description", "stats.lifespan").
 * @param modelConfigJson La configuration du mod√®le IA utilis√©e, s√©rialis√©e en JSON.
 * @param rawResponse La r√©ponse brute compl√®te retourn√©e par le mod√®le IA une fois la t√¢che termin√©e.
 * @param streamingResponse Le contenu partiel re√ßu en temps r√©el (non persist√©).
 * @param status L'√©tat actuel de cette t√¢che d'analyse.
 * @param timestamp L'horodatage de la cr√©ation de cette t√¢che.
 * @param errorMessage Un message d'erreur si la t√¢che a √©chou√©.
 */
@Parcelize
data class AnalysisResult(
    val id: String = UUID.randomUUID().toString(),
    val pollenGrainId: String,
    val propertyName: String,
    val modelConfigJson: String,
    var rawResponse: String? = null,
    // BOURDON'S ADDITION: Champ pour le texte en streaming.
    // Il est transient car il ne vit que dans l'UI et n'est pas sauvegard√© en base de donn√©es.
    @Transient var streamingResponse: String? = null,
    var status: AnalysisStatus = AnalysisStatus.PENDING,
    val timestamp: Long = System.currentTimeMillis(),
    var errorMessage: String? = null
) : Parcelable

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/AnalysisResult.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/IdentificationResult.kt ---

package be.heyman.android.ai.kikko.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
// BOURDON'S FIX: Import explicite de la classe Reasoning de haut niveau
import be.heyman.android.ai.kikko.model.Reasoning

/**
 * Repr√©sente le r√©sultat structur√© du premier prompt de la cha√Æne multimodale.
 * Contient l'identification de base et le raisonnement de l'IA.
 */
@Serializable
data class IdentificationResult(
    // BOURDON'S FIX: On s'assure que ce champ utilise la classe de haut niveau
    // be.heyman.android.ai.kikko.model.Reasoning, et non une classe imbriqu√©e.
    @SerialName("reasoning")
    val reasoning: Reasoning,

    @SerialName("deckName")
    val deckName: String,

    @SerialName("specificName")
    val specificName: String,

    @SerialName("confidence")
    val confidence: Float
)
// L'ancienne classe imbriqu√©e "Reasoning" a √©t√© supprim√©e d'ici.

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/IdentificationResult.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/KnowledgeCard.kt ---

package be.heyman.android.ai.kikko.model

import android.os.Parcelable
import com.google.gson.annotations.SerializedName
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.Serializable

/**
 * Contient tous les champs traduisibles pour une langue sp√©cifique.
 */
@Serializable
@Parcelize
data class TranslatedContent(
    val description: String?,
    val reasoning: Reasoning?,
    val quiz: List<QuizQuestion>?
) : Parcelable


/**
 * Repr√©sente une seule pi√®ce de connaissance.
 * BOURDON'S REFORGE (v3.0): Le mod√®le est simplifi√© pour le concours,
 * avec des champs sp√©cifiques aux decks biologiques et des stats flexibles.
 */
@Serializable
@Parcelize
data class KnowledgeCard(
    val id: Long = 0,
    val specificName: String,
    val deckName: String,
    val imagePath: String?,
    val confidence: Float,
    // Contenu original (g√©n√©r√© par l'IA)
    val reasoning: Reasoning,
    val description: String?,
    val stats: CardStats?,
    val quiz: List<QuizQuestion>?,
    // Nouveaux champs pour les decks biologiques - BOURDON'S FIX
    val scientificName: String? = null,
    val vernacularName: String? = null,
    // Nouveaux champs pour le deck Food - BOURDON'S FIX
    val allergens: List<String>? = null,
    val ingredients: List<String>? = null,
    // Contenu traduit
    val translations: Map<String, TranslatedContent>? = null
) : Parcelable

@Serializable
@Parcelize
data class Reasoning(
    val visualAnalysis: String,
    val evidenceCorrelation: String
) : Parcelable

@Serializable
@Parcelize
data class CardStats(
    val title: String,
    // La map `items` est flexible pour contenir diff√©rentes stats selon le deck
    // Ex: {"Energy": "520 kcal", "Allergens": "Peanuts, Gluten"} pour Food
    // Ex: {"Wingspan": "110 cm", "Diet": "Carnivore"} pour Bird
    val items: Map<String, String>
) : Parcelable

@Serializable
@Parcelize
data class QuizQuestion(
    @SerializedName("q")
    val question: String,
    @SerializedName("o")
    val options: List<String>,
    @SerializedName("c")
    val correctAnswerIndex: Int,
    val explanation: String?
) : Parcelable

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/KnowledgeCard.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenGrain.kt ---

package be.heyman.android.ai.kikko.model

import android.os.Parcelable
import kotlinx.parcelize.Parcelize
import java.util.UUID

/**
 * Repr√©sente une session de r√©colte de "pollen" compl√®te.
 * C'est un POKO (Plain Old Kotlin Object) utilis√© comme mod√®le de donn√©es
 * pour la persistance en SQL pur.
 *
 * @property id Identifiant unique de la session de r√©colte (UUID).
 * @property timestamp Horodatage de la fin de la capture.
 * @property status L'√©tat actuel du grain dans le cycle de vie de la Forge.
 * @property userIntent L'intention vocale ou textuelle de l'utilisateur lors de la capture.
 * @property pollenImagePaths Les chemins d'acc√®s vers les fichiers images sources de la capture. S√©rialis√© en JSON.
 * @property swarmAnalysisReportJson Le rapport JSON brut complet de l'analyse par les Abeilles Sp√©cialistes.
 * @property forgedCardId L'ID de la KnowledgeCard r√©sultante une fois la Forge termin√©e.
 */
@Parcelize
data class PollenGrain(
    val id: String = UUID.randomUUID().toString(),
    val timestamp: Long = System.currentTimeMillis(),
    var status: PollenStatus = PollenStatus.RAW, // 'var' pour pouvoir le mettre √† jour
    val userIntent: String?,
    val pollenImagePaths: List<String>,
    val swarmAnalysisReportJson: String?,
    var forgedCardId: Long? = null // 'var' pour pouvoir le mettre √† jour
) : Parcelable

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenGrain.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenStatus.kt ---

package be.heyman.android.ai.kikko.model

/**
 * D√©finit les diff√©rents √©tats possibles pour un PollenGrain dans son cycle de vie,
 * de sa capture brute √† sa transformation finale en Miel (KnowledgeCard).
 * Chaque √©tat repr√©sente une √©tape dans la cha√Æne de production de notre WorkManager.
 *
 * BOURDON'S REFORGE V6.0: Introduction d'un nouvel √©tat pour la validation manuelle.
 */
enum class PollenStatus {
    /**
     * Le grain de pollen vient d'√™tre captur√© et est pr√™t pour la Forge.
     */
    RAW,

    /**
     * √âtape 1 : Le grain est en cours de pr√©-identification par la Reine IA en arri√®re-plan.
     */
    IDENTIFYING,

    /**
     * NOUVEL √âTAT: Le grain a une identification pr√©liminaire et attend la validation
     * du Ma√Ætre Forgeron dans l'Atelier. C'est le point d'entr√©e pour le raffinage manuel.
     */
    AWAITING_VALIDATION,

    /**
     * En attente de l'√âtape 2 : La g√©n√©ration de la description narrative.
     */
    PENDING_DESCRIPTION,

    /**
     * En attente de l'√âtape 3 : L'extraction des statistiques.
     */
    PENDING_STATS,

    /**
     * En attente de l'√âtape 4 : La cr√©ation du quiz.
     */
    PENDING_QUIZ,

    /**
     * En attente de l'√âtape 5 : La traduction du contenu.
     */
    PENDING_TRANSLATION,

    /**
     * Le processus de Forge est termin√© avec succ√®s. La KnowledgeCard est compl√®te.
     */
    FORGED,

    /**
     * Une erreur est survenue √† l'une des √©tapes de la Forge.
     */
    ERROR
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenStatus.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/SwarmAnalysisData.kt ---

package be.heyman.android.ai.kikko.model

import com.google.gson.annotations.SerializedName

/**
 * Contient le r√©sultat complet d'une analyse d'essaim sur plusieurs images.
 */
data class SwarmAnalysisResult(
    val reports: List<ImageAnalysisReport>?
)

/**
 * BOURDON'S ROBUSTNESS FIX V3:
 * - Structure de donn√©es align√©e sur le JSON r√©el de PollenForge.
 * - Toutes les collections et propri√©t√©s potentiellement manquantes sont nullables.
 */
data class ImageAnalysisReport(
    @SerializedName("object_detection_results")
    val detectedObjects: List<SimpleDetectedObject>?,

    @SerializedName("global_classification_results")
    val globalClassifierResults: Map<String, List<SimpleImageLabel>?>?,

    @SerializedName("ocr_results")
    val ocrResults: OcrResult?
) {
    val ocrText: String
        get() = ocrResults?.fullText ?: ""
}

data class OcrResult(
    @SerializedName("full_text")
    val fullText: String?
)

data class SimpleDetectedObject(
    val labels: List<SimpleImageLabel>
)

data class SimpleImageLabel(
    // BOURDON'S FIX: Rendu nullable pour emp√™cher les crashs de Gson/Kotlin.
    val text: String?,
    val confidence: Float
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/SwarmAnalysisData.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/AnalysisResultDao.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.util.Log
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * DAO (Data Access Object) pour l'entit√© AnalysisResult.
 * G√®re toutes les interactions avec la table "analysis_results".
 */
class AnalysisResultDao(context: Context) {

    private val dbHelper = DatabaseHelper.getInstance(context) // BOURDON'S FIX: Assure l'initialisation correcte du singleton
    private val gson = Gson()

    /**
     * Ins√®re un nouveau r√©sultat d'analyse (ou une t√¢che) dans la base de donn√©es.
     * @param result L'objet AnalysisResult √† ins√©rer.
     */
    suspend fun insert(result: AnalysisResult) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_AR_ID, result.id) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_POLLEN_ID, result.pollenGrainId) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_PROPERTY_NAME, result.propertyName) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_MODEL_CONFIG_JSON, result.modelConfigJson) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_RAW_RESPONSE, result.rawResponse) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_STATUS, result.status.name) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_TIMESTAMP, result.timestamp) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_ERROR_MESSAGE, result.errorMessage) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        }
        db.insert(DatabaseHelper.TABLE_ANALYSIS_RESULTS, null, values) // BOURDON'S FIX: R√©f√©rences qualifi√©es
    }

    /**
     * Met √† jour un r√©sultat d'analyse existant.
     * @param result L'objet AnalysisResult avec les nouvelles donn√©es.
     */
    suspend fun update(result: AnalysisResult) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_AR_RAW_RESPONSE, result.rawResponse) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_STATUS, result.status.name) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_AR_ERROR_MESSAGE, result.errorMessage) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        }
        db.update(
            DatabaseHelper.TABLE_ANALYSIS_RESULTS, // BOURDON'S FIX: R√©f√©rences qualifi√©es
            values,
            "${DatabaseHelper.COLUMN_AR_ID} = ?", // BOURDON'S FIX: R√©f√©rences qualifi√©es
            arrayOf(result.id)
        )
    }

    /**
     * R√©cup√®re tous les r√©sultats d'analyse pour un PollenGrain et une propri√©t√© sp√©cifiques.
     * @param pollenGrainId L'ID du PollenGrain parent.
     * @param propertyName Le nom de la propri√©t√© (ex: "description").
     * @return Une liste d'AnalysisResults.
     */
    suspend fun getByPollenGrainIdAndProperty(pollenGrainId: String, propertyName: String): List<AnalysisResult> = withContext(Dispatchers.IO) {
        val results = mutableListOf<AnalysisResult>()
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_ANALYSIS_RESULTS, // BOURDON'S FIX: R√©f√©rences qualifi√©es
            null, // Toutes les colonnes
            "${DatabaseHelper.COLUMN_AR_POLLEN_ID} = ? AND ${DatabaseHelper.COLUMN_AR_PROPERTY_NAME} = ?", // BOURDON'S FIX: R√©f√©rences qualifi√©es
            arrayOf(pollenGrainId, propertyName),
            null, null, "${DatabaseHelper.COLUMN_AR_TIMESTAMP} ASC" // BOURDON'S FIX: R√©f√©rences qualifi√©es
        )
        cursor.use {
            while (it.moveToNext()) {
                results.add(cursorToAnalysisResult(it))
            }
        }
        return@withContext results
    }

    /**
     * BOURDON'S FIX: Supprime tous les r√©sultats d'analyse pour une propri√©t√© sp√©cifique d'un grain.
     * C'est la m√©thode n√©cessaire pour la fonctionnalit√© de "relance".
     */
    suspend fun deleteByPollenGrainIdAndProperty(pollenGrainId: String, propertyName: String) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val deletedRows = db.delete(
            DatabaseHelper.TABLE_ANALYSIS_RESULTS,
            "${DatabaseHelper.COLUMN_AR_POLLEN_ID} = ? AND ${DatabaseHelper.COLUMN_AR_PROPERTY_NAME} = ?",
            arrayOf(pollenGrainId, propertyName)
        )
        Log.i("AnalysisResultDao", "$deletedRows r√©sultats d'analyse supprim√©s pour le grain $pollenGrainId et la propri√©t√© $propertyName.")
    }


    /**
     * Supprime TOUTES les entr√©es de la table analysis_results. Action irr√©versible.
     */
    suspend fun nuke() = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(DatabaseHelper.TABLE_ANALYSIS_RESULTS, null, null) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        Log.w("AnalysisResultDao", "NUKE: La table analysis_results a √©t√© enti√®rement vid√©e.")
    }

    /**
     * Helper pour convertir une ligne de curseur en un objet AnalysisResult.
     */
    private fun cursorToAnalysisResult(cursor: Cursor): AnalysisResult {
        fun getStringOrNull(columnName: String): String? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getString(colIndex) else null
        }

        return AnalysisResult(
            id = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_ID)), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            pollenGrainId = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_POLLEN_ID)), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            propertyName = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_PROPERTY_NAME)), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            modelConfigJson = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_MODEL_CONFIG_JSON)), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            rawResponse = getStringOrNull(DatabaseHelper.COLUMN_AR_RAW_RESPONSE), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            status = AnalysisStatus.valueOf(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_STATUS))), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            timestamp = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_TIMESTAMP)), // BOURDON'S FIX: R√©f√©rences qualifi√©es
            errorMessage = getStringOrNull(DatabaseHelper.COLUMN_AR_ERROR_MESSAGE) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/AnalysisResultDao.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/CardDao.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.util.Log
import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.QuizQuestion
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.model.TranslatedContent
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/**
 * DAO (Data Access Object) for the KnowledgeCard entity.
 * BOURDON'S REFORGE (v6.0): Added a surgical update method for validation.
 */
class CardDao(context: Context) {
    private val dbHelper = DatabaseHelper.getInstance(context)
    private val gson = Gson()
    private val TAG = "KikkoForgeTrace" // BOURDON'S LOGGING: TAG unifi√©

    private val quizListType = object : TypeToken<List<QuizQuestion>>() {}.type
    private val statsType = object : TypeToken<CardStats>() {}.type
    private val reasoningType = object : TypeToken<Reasoning>() {}.type
    private val translationsType = object : TypeToken<Map<String, TranslatedContent>>() {}.type
    private val stringListType = object : TypeToken<List<String>>() {}.type

    suspend fun insert(card: KnowledgeCard): Long = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME, card.specificName)
            put(DatabaseHelper.COLUMN_CARD_DECK_NAME, card.deckName)
            put(DatabaseHelper.COLUMN_CARD_IMAGE_PATH, card.imagePath)
            put(DatabaseHelper.COLUMN_CARD_CONFIDENCE, card.confidence)
            put(DatabaseHelper.COLUMN_CARD_DESCRIPTION, card.description)
            put(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME, card.scientificName)
            put(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME, card.vernacularName)
            put(DatabaseHelper.COLUMN_CARD_REASONING_JSON, gson.toJson(card.reasoning))
            put(DatabaseHelper.COLUMN_CARD_STATS_JSON, gson.toJson(card.stats))
            put(DatabaseHelper.COLUMN_CARD_QUIZ_JSON, gson.toJson(card.quiz))
            put(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON, gson.toJson(card.translations))
            put(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON, gson.toJson(card.allergens, stringListType))
            put(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON, gson.toJson(card.ingredients, stringListType))
        }
        val id = db.insert(DatabaseHelper.TABLE_CARDS, null, values)
        Log.i(TAG, "[DAO-INSERT] Carte ins√©r√©e avec ID: $id. Nom: '${card.specificName}', Deck: '${card.deckName}'")
        return@withContext id
    }

    suspend fun getAll(): List<KnowledgeCard> = withContext(Dispatchers.IO) {
        val cards = mutableListOf<KnowledgeCard>()
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_CARDS, null, null, null, null, null,
            "${DatabaseHelper.COLUMN_CARD_ID} DESC"
        )
        cursor.use {
            while (it.moveToNext()) {
                cards.add(cursorToKnowledgeCard(it))
            }
        }
        return@withContext cards
    }

    suspend fun getCardById(id: Long): KnowledgeCard? = withContext(Dispatchers.IO) {
        var card: KnowledgeCard? = null
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_CARDS, null, "${DatabaseHelper.COLUMN_CARD_ID} = ?",
            arrayOf(id.toString()), null, null, null
        )
        cursor.use {
            if (it.moveToFirst()) {
                card = cursorToKnowledgeCard(it)
            }
        }
        return@withContext card
    }

    suspend fun update(card: KnowledgeCard) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME, card.specificName)
            put(DatabaseHelper.COLUMN_CARD_DECK_NAME, card.deckName)
            put(DatabaseHelper.COLUMN_CARD_IMAGE_PATH, card.imagePath)
            put(DatabaseHelper.COLUMN_CARD_CONFIDENCE, card.confidence)
            put(DatabaseHelper.COLUMN_CARD_DESCRIPTION, card.description)
            put(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME, card.scientificName)
            put(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME, card.vernacularName)
            put(DatabaseHelper.COLUMN_CARD_REASONING_JSON, gson.toJson(card.reasoning))
            put(DatabaseHelper.COLUMN_CARD_STATS_JSON, gson.toJson(card.stats))
            put(DatabaseHelper.COLUMN_CARD_QUIZ_JSON, gson.toJson(card.quiz))
            put(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON, gson.toJson(card.translations))
            put(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON, gson.toJson(card.allergens, stringListType))
            put(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON, gson.toJson(card.ingredients, stringListType))
        }
        val rows = db.update(
            DatabaseHelper.TABLE_CARDS, values,
            "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(card.id.toString())
        )
        Log.i(TAG, "[DAO-UPDATE] ${rows} ligne(s) mise(s) √† jour pour la carte ID ${card.id}.")
    }

    suspend fun updateIdentification(cardId: Long, specificName: String?, deckName: String?, reasoning: Reasoning, confidence: Float) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        Log.d(TAG, "[DAO-UPDATE-ID] Ordre re√ßu pour Carte ID $cardId: Nom='$specificName', Deck='$deckName'")
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME, specificName)
            put(DatabaseHelper.COLUMN_CARD_DECK_NAME, deckName)
            put(DatabaseHelper.COLUMN_CARD_REASONING_JSON, gson.toJson(reasoning, reasoningType))
            put(DatabaseHelper.COLUMN_CARD_CONFIDENCE, confidence)
        }
        val rows = db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
        Log.i(TAG, "[DAO-UPDATE-ID] ${rows} ligne(s) mise(s) √† jour pour la carte ID $cardId. L'op√©ration a-t-elle r√©ussi ? (rows > 0)")
    }

    suspend fun updateDescription(cardId: Long, description: String?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_DESCRIPTION, description)
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateStats(cardId: Long, stats: CardStats?, allergens: List<String>?, ingredients: List<String>?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_STATS_JSON, gson.toJson(stats))
            put(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON, gson.toJson(allergens, stringListType))
            put(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON, gson.toJson(ingredients, stringListType))
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateScientificAndVernacularNames(cardId: Long, scientificName: String?, vernacularName: String?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME, scientificName)
            put(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME, vernacularName)
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateQuiz(cardId: Long, quiz: List<QuizQuestion>?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_QUIZ_JSON, gson.toJson(quiz))
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateTranslations(cardId: Long, translations: Map<String, TranslatedContent>?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON, gson.toJson(translations))
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun delete(card: KnowledgeCard) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(
            DatabaseHelper.TABLE_CARDS,
            "${DatabaseHelper.COLUMN_CARD_ID} = ?",
            arrayOf(card.id.toString())
        )
    }

    suspend fun nuke() = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(DatabaseHelper.TABLE_CARDS, null, null)
        Log.w("CardDao", "NUKE: La table knowledge_cards a √©t√© enti√®rement vid√©e.")
    }

    private fun cursorToKnowledgeCard(cursor: Cursor): KnowledgeCard {
        fun getStringOrNull(columnName: String): String? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getString(colIndex) else null
        }
        fun getLongOrNull(columnName: String): Long? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getLong(colIndex) else null
        }

        val specificNameRaw = getStringOrNull(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME)
        val deckNameRaw = getStringOrNull(DatabaseHelper.COLUMN_CARD_DECK_NAME)
        val cardId = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_CARD_ID))
        Log.d(TAG, "[DAO-READ] Lecture Carte ID $cardId: Nom='${specificNameRaw}', Deck='${deckNameRaw}'")

        val specificName = specificNameRaw ?: "Erreur de Nom"
        val deckName = deckNameRaw ?: "Erreur de Deck"

        return KnowledgeCard(
            id = cardId,
            specificName = specificName,
            deckName = deckName,
            imagePath = getStringOrNull(DatabaseHelper.COLUMN_CARD_IMAGE_PATH),
            confidence = cursor.getFloat(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_CARD_CONFIDENCE)),
            description = getStringOrNull(DatabaseHelper.COLUMN_CARD_DESCRIPTION),
            scientificName = getStringOrNull(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME),
            vernacularName = getStringOrNull(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME),
            reasoning = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_REASONING_JSON), reasoningType) ?: Reasoning("N/A","N/A"),
            stats = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_STATS_JSON), statsType),
            quiz = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_QUIZ_JSON), quizListType),
            translations = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON), translationsType),
            allergens = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON), stringListType),
            ingredients = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON), stringListType)
        )
    }
    fun getAllCardsFlow(): Flow<List<KnowledgeCard>> {
        return flow {
            emit(getAll())
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/CardDao.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/DatabaseHelper.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.util.Log

class DatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {

    companion object {
        private const val DATABASE_NAME = "kikko.db"
        // BOURDON'S REFORGE: Version incr√©ment√©e √† 7 pour refl√©ter le nouveau sch√©ma de carte.
        private const val DATABASE_VERSION = 7 // BOURDON'S FIX: Incr√©mentation de la version

        // --- Table "knowledge_cards" Definition ---
        const val TABLE_CARDS = "knowledge_cards"
        const val COLUMN_CARD_ID = "id"
        const val COLUMN_CARD_SPECIFIC_NAME = "specificName"
        const val COLUMN_CARD_DECK_NAME = "deckName"
        const val COLUMN_CARD_IMAGE_PATH = "imagePath"
        const val COLUMN_CARD_CONFIDENCE = "confidence"
        const val COLUMN_CARD_DESCRIPTION = "description"
        const val COLUMN_CARD_REASONING_JSON = "reasoning"
        const val COLUMN_CARD_STATS_JSON = "stats"
        const val COLUMN_CARD_QUIZ_JSON = "quiz"
        const val COLUMN_CARD_TRANSLATIONS_JSON = "translations"
        // BOURDON'S REFORGE: Ajout des nouveaux champs pour les decks biologiques.
        const val COLUMN_CARD_SCIENTIFIC_NAME = "scientificName"
        const val COLUMN_CARD_VERNACULAR_NAME = "vernacularName"
        // BOURDON'S FIX: NOUVEAUX CHAMPS ALLERGENS ET INGREDIENTS
        const val COLUMN_CARD_ALLERGENS_JSON = "allergens"
        const val COLUMN_CARD_INGREDIENTS_JSON = "ingredients"


        private const val TABLE_CARDS_CREATE =
            "CREATE TABLE $TABLE_CARDS (" +
                    "$COLUMN_CARD_ID INTEGER PRIMARY KEY AUTOINCREMENT, " +
                    "$COLUMN_CARD_SPECIFIC_NAME TEXT, " +
                    "$COLUMN_CARD_DECK_NAME TEXT, " +
                    "$COLUMN_CARD_IMAGE_PATH TEXT, " +
                    "$COLUMN_CARD_CONFIDENCE REAL, " +
                    "$COLUMN_CARD_DESCRIPTION TEXT, " +
                    // BOURDON'S REFORGE: Ajout des nouvelles colonnes au sch√©ma.
                    "$COLUMN_CARD_SCIENTIFIC_NAME TEXT, " +
                    "$COLUMN_CARD_VERNACULAR_NAME TEXT, " +
                    "$COLUMN_CARD_REASONING_JSON TEXT, " +
                    "$COLUMN_CARD_STATS_JSON TEXT, " +
                    "$COLUMN_CARD_QUIZ_JSON TEXT, " +
                    "$COLUMN_CARD_TRANSLATIONS_JSON TEXT, " +
                    // BOURDON'S FIX: Ajout des nouvelles colonnes √† la clause CREATE TABLE.
                    "$COLUMN_CARD_ALLERGENS_JSON TEXT, " +
                    "$COLUMN_CARD_INGREDIENTS_JSON TEXT);"

        // --- Table "pollen_grains" Definition (inchang√©e) ---
        const val TABLE_POLLEN_GRAINS = "pollen_grains"
        const val COLUMN_POLLEN_ID = "id"
        const val COLUMN_POLLEN_TIMESTAMP = "timestamp"
        const val COLUMN_POLLEN_STATUS = "status"
        const val COLUMN_POLLEN_USER_INTENT = "user_intent"
        const val COLUMN_POLLEN_IMAGE_PATHS_JSON = "image_paths_json"
        const val COLUMN_POLLEN_SWARM_REPORT_JSON = "swarm_report_json"
        const val COLUMN_POLLEN_FORGED_CARD_ID = "forged_card_id"

        private const val TABLE_POLLEN_CREATE =
            "CREATE TABLE $TABLE_POLLEN_GRAINS (" +
                    "$COLUMN_POLLEN_ID TEXT PRIMARY KEY NOT NULL, " +
                    "$COLUMN_POLLEN_TIMESTAMP INTEGER NOT NULL, " +
                    "$COLUMN_POLLEN_STATUS TEXT NOT NULL, " +
                    "$COLUMN_POLLEN_USER_INTENT TEXT, " +
                    "$COLUMN_POLLEN_IMAGE_PATHS_JSON TEXT NOT NULL, " +
                    "$COLUMN_POLLEN_SWARM_REPORT_JSON TEXT, " +
                    "$COLUMN_POLLEN_FORGED_CARD_ID INTEGER, " +
                    "FOREIGN KEY($COLUMN_POLLEN_FORGED_CARD_ID) REFERENCES $TABLE_CARDS($COLUMN_CARD_ID));"

        // --- Table "analysis_results" Definition (inchang√©e) ---
        const val TABLE_ANALYSIS_RESULTS = "analysis_results"
        const val COLUMN_AR_ID = "id"
        const val COLUMN_AR_POLLEN_ID = "pollen_grain_id"
        const val COLUMN_AR_PROPERTY_NAME = "property_name"
        const val COLUMN_AR_MODEL_CONFIG_JSON = "model_config_json"
        const val COLUMN_AR_RAW_RESPONSE = "raw_response"
        const val COLUMN_AR_STATUS = "status"
        const val COLUMN_AR_TIMESTAMP = "timestamp"
        const val COLUMN_AR_ERROR_MESSAGE = "error_message"

        private const val TABLE_ANALYSIS_RESULTS_CREATE =
            "CREATE TABLE $TABLE_ANALYSIS_RESULTS (" +
                    "$COLUMN_AR_ID TEXT PRIMARY KEY NOT NULL, " +
                    "$COLUMN_AR_POLLEN_ID TEXT NOT NULL, " +
                    "$COLUMN_AR_PROPERTY_NAME TEXT NOT NULL, " +
                    "$COLUMN_AR_MODEL_CONFIG_JSON TEXT NOT NULL, " +
                    "$COLUMN_AR_RAW_RESPONSE TEXT, " +
                    "$COLUMN_AR_STATUS TEXT NOT NULL, " +
                    "$COLUMN_AR_TIMESTAMP INTEGER NOT NULL, " +
                    "$COLUMN_AR_ERROR_MESSAGE TEXT, " +
                    "FOREIGN KEY($COLUMN_AR_POLLEN_ID) REFERENCES $TABLE_POLLEN_GRAINS($COLUMN_POLLEN_ID) ON DELETE CASCADE);"


        @Volatile
        private var INSTANCE: DatabaseHelper? = null

        fun getInstance(context: Context): DatabaseHelper {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: DatabaseHelper(context.applicationContext).also { INSTANCE = it }
            }
        }
    }

    override fun onCreate(db: SQLiteDatabase?) {
        Log.i("DatabaseHelper", "Cr√©ation des tables de la base de donn√©es (v$DATABASE_VERSION)...")
        db?.execSQL(TABLE_CARDS_CREATE)
        db?.execSQL(TABLE_POLLEN_CREATE)
        db?.execSQL(TABLE_ANALYSIS_RESULTS_CREATE)
    }

    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
        Log.w("DatabaseHelper", "Mise √† jour de la base de donn√©es de la version $oldVersion √† $newVersion, les anciennes donn√©es seront d√©truites.")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_ANALYSIS_RESULTS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_POLLEN_GRAINS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_CARDS")
        onCreate(db)
    }

    override fun onDowngrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
        Log.w("DatabaseHelper", "Retour en arri√®re de la BDD de v$oldVersion √† v$newVersion. Purge compl√®te des donn√©es...")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_ANALYSIS_RESULTS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_POLLEN_GRAINS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_CARDS")
        onCreate(db)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/DatabaseHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/PollenGrainDao.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.util.Log
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * DAO (Data Access Object) pour l'entit√© PollenGrain.
 * G√®re toutes les interactions avec la table "pollen_grains" en utilisant des requ√™tes SQL pures.
 */
class PollenGrainDao(context: Context) {

    private val dbHelper = DatabaseHelper.getInstance(context) // BOURDON'S FIX: Assure l'initialisation correcte du singleton
    private val gson = Gson()
    private val stringListType = object : TypeToken<List<String>>() {}.type

    /**
     * Ins√®re un nouveau PollenGrain dans la base de donn√©es.
     * @param pollenGrain L'objet √† ins√©rer.
     */
    suspend fun insert(pollenGrain: PollenGrain) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_POLLEN_ID, pollenGrain.id) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_TIMESTAMP, pollenGrain.timestamp) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_STATUS, pollenGrain.status.name) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_USER_INTENT, pollenGrain.userIntent) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_IMAGE_PATHS_JSON, gson.toJson(pollenGrain.pollenImagePaths, stringListType)) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_SWARM_REPORT_JSON, pollenGrain.swarmAnalysisReportJson) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID, pollenGrain.forgedCardId) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        }
        db.insert(DatabaseHelper.TABLE_POLLEN_GRAINS, null, values) // BOURDON'S FIX: R√©f√©rences qualifi√©es
    }

    /**
     * Met √† jour le statut et l'ID de la carte forg√©e d'un PollenGrain.
     * Utilis√© √† la fin d'une √©tape de forge r√©ussie.
     * @param pollenId L'ID du grain √† mettre √† jour.
     * @param newStatus Le nouveau statut du grain.
     * @param forgedCardId L'ID de la KnowledgeCard nouvellement cr√©√©e.
     */
    suspend fun updateForgingResult(pollenId: String, newStatus: PollenStatus, forgedCardId: Long?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_POLLEN_STATUS, newStatus.name) // BOURDON'S FIX: R√©f√©rences qualifi√©es
            put(DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID, forgedCardId) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        }
        db.update(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: R√©f√©rences qualifi√©es
            values,
            "${DatabaseHelper.COLUMN_POLLEN_ID} = ?", // BOURDON'S FIX: R√©f√©rences qualifi√©es
            arrayOf(pollenId)
        )
    }

    /**
     * Met √† jour uniquement le statut d'un PollenGrain.
     * C'est une m√©thode optimis√©e pour les workers.
     * @param pollenId L'ID du grain √† mettre √† jour.
     * @param newStatus Le nouveau statut √† appliquer.
     */
    suspend fun updateStatus(pollenId: String, newStatus: PollenStatus) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_POLLEN_STATUS, newStatus.name) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        }
        db.update(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: R√©f√©rences qualifi√©es
            values,
            "${DatabaseHelper.COLUMN_POLLEN_ID} = ?", // BOURDON'S FIX: R√©f√©rences qualifi√©es
            arrayOf(pollenId)
        )
    }

    /**
     * BOURDON'S FIX: Nouvelle m√©thode de suppression pour un grain sp√©cifique.
     * @param pollenGrain Le grain √† supprimer de la base de donn√©es.
     */
    suspend fun delete(pollenGrain: PollenGrain) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(
            DatabaseHelper.TABLE_POLLEN_GRAINS,
            "${DatabaseHelper.COLUMN_POLLEN_ID} = ?",
            arrayOf(pollenGrain.id)
        )
        Log.d("PollenGrainDao", "PollenGrain (ID: ${pollenGrain.id}) supprim√© de la base de donn√©es.")
    }


    /**
     * R√©cup√®re tous les PollenGrains ayant un statut sp√©cifique.
     * @param status Le statut √† rechercher.
     * @return Une liste de PollenGrains correspondants.
     */
    suspend fun getByStatus(status: PollenStatus): List<PollenGrain> = withContext(Dispatchers.IO) {
        val grains = mutableListOf<PollenGrain>()
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: R√©f√©rences qualifi√©es
            null, // Toutes les colonnes
            "${DatabaseHelper.COLUMN_POLLEN_STATUS} = ?", // BOURDON'S FIX: R√©f√©rences qualifi√©es
            arrayOf(status.name),
            null, null, "${DatabaseHelper.COLUMN_POLLEN_TIMESTAMP} ASC" // BOURDON'S FIX: R√©f√©rences qualifi√©es
        )
        cursor.use {
            while (it.moveToNext()) {
                grains.add(cursorToPollenGrain(it))
            }
        }
        return@withContext grains
    }

    /**
     * NOUVEAU: R√©cup√®re un PollenGrain par l'ID de la carte qu'il a forg√©e.
     * @param cardId L'ID de la KnowledgeCard.
     * @return Le PollenGrain correspondant ou null si non trouv√©.
     */
    suspend fun findByForgedCardId(cardId: Long): PollenGrain? = withContext(Dispatchers.IO) {
        var grain: PollenGrain? = null
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: R√©f√©rences qualifi√©es
            null,
            "${DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID} = ?", // BOURDON'S FIX: R√©f√©rences qualifi√©es
            arrayOf(cardId.toString()),
            null, null, null, "1"
        )
        cursor.use {
            if (it.moveToFirst()) {
                grain = cursorToPollenGrain(it)
            }
        }
        return@withContext grain
    }

    /**
     * Compte le nombre de grains pour chaque statut.
     * C'est la fonction cl√© pour alimenter les cocardes de l'interface.
     * @return Une map associant chaque PollenStatus √† son nombre d'occurrences.
     */
    suspend fun countByStatus(): Map<PollenStatus, Int> = withContext(Dispatchers.IO) {
        val counts = PollenStatus.values().associateWith { 0 }.toMutableMap()
        val db = dbHelper.readableDatabase
        val query = "SELECT ${DatabaseHelper.COLUMN_POLLEN_STATUS}, COUNT(*) FROM ${DatabaseHelper.TABLE_POLLEN_GRAINS} GROUP BY ${DatabaseHelper.COLUMN_POLLEN_STATUS}" // BOURDON'S FIX: R√©f√©rences qualifi√©es
        val cursor = db.rawQuery(query, null)
        cursor.use {
            while (it.moveToNext()) {
                try {
                    val status = PollenStatus.valueOf(it.getString(it.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_STATUS))) // BOURDON'S FIX: getColumnIndexOrThrow
                    val count = it.getInt(it.getColumnIndexOrThrow("COUNT(*)")) // BOURDON'S FIX: getColumnIndexOrThrow
                    counts[status] = count
                } catch (e: IllegalArgumentException) {
                    // Ignore les statuts inconnus dans la base de donn√©es
                }
            }
        }
        return@withContext counts
    }

    suspend fun getDebugSummary(): String = withContext(Dispatchers.IO) {
        val db = dbHelper.readableDatabase
        val cursor = db.query(DatabaseHelper.TABLE_POLLEN_GRAINS, null, null, null, null, null, "${DatabaseHelper.COLUMN_POLLEN_TIMESTAMP} DESC") // BOURDON'S FIX: R√©f√©rences qualifi√©es
        val summary = StringBuilder()
        summary.append("--- D√©but du Rapport de la R√©serve de Pollen ---\n")
        summary.append("Total de Grains: ${cursor.count}\n")
        cursor.use {
            while (it.moveToNext()) {
                val grain = cursorToPollenGrain(it)
                summary.append("  - ID: ${grain.id.substring(0, 8)}... | Status: ${grain.status} | CardID: ${grain.forgedCardId ?: "N/A"}\n")
            }
        }
        summary.append("--- Fin du Rapport ---")
        return@withContext summary.toString()
    }

    /**
     * Supprime TOUTES les entr√©es de la table pollen_grains. Action irr√©versible.
     */
    suspend fun nuke() = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(DatabaseHelper.TABLE_POLLEN_GRAINS, null, null) // BOURDON'S FIX: R√©f√©rences qualifi√©es
        Log.w("PollenGrainDao", "NUKE: La table pollen_grains a √©t√© enti√®rement vid√©e.")
    }

    /**
     * Helper pour convertir une ligne de curseur en un objet PollenGrain.
     */
    private fun cursorToPollenGrain(cursor: Cursor): PollenGrain {
        fun getStringOrNull(columnName: String): String? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getString(colIndex) else null
        }
        fun getLongOrNull(columnName: String): Long? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getLong(colIndex) else null
        }


        return PollenGrain(
            id = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_ID)), // BOURDON'S FIX: getColumnIndexOrThrow
            timestamp = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_TIMESTAMP)), // BOURDON'S FIX: getColumnIndexOrThrow
            status = PollenStatus.valueOf(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_STATUS))), // BOURDON'S FIX: getColumnIndexOrThrow
            userIntent = getStringOrNull(DatabaseHelper.COLUMN_POLLEN_USER_INTENT), // BOURDON'S FIX: getColumnIndexOrThrow
            pollenImagePaths = gson.fromJson(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_IMAGE_PATHS_JSON)), stringListType), // BOURDON'S FIX: getColumnIndexOrThrow
            swarmAnalysisReportJson = getStringOrNull(DatabaseHelper.COLUMN_POLLEN_SWARM_REPORT_JSON), // BOURDON'S FIX: getColumnIndexOrThrow
            forgedCardId = getLongOrNull(DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID) // BOURDON'S FIX: getColumnIndexOrThrow
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/PollenGrainDao.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---

package be.heyman.android.ai.kikko.pollen

import android.Manifest
import android.annotation.SuppressLint
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageFormat
import android.graphics.Matrix
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.CompoundButton
import android.widget.TextView
import android.widget.Toast
import android.widget.ToggleButton
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.ImageProxy
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.TtsService
import kotlinx.coroutines.launch
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

@SuppressLint("ClickableViewAccessibility")
class ForgeLiveActivity : AppCompatActivity(), CompoundButton.OnCheckedChangeListener {

    private val viewModel: ForgeLiveViewModel by lazy {
        ViewModelProvider(this, ViewModelProvider.AndroidViewModelFactory(application)).get(ForgeLiveViewModel::class.java)
    }

    // BOURDON'S LOGGING: TAG pour cette activit√©.
    private val TAG = "ForgeLiveActivity"

    // Vues
    private lateinit var previewView: PreviewView
    private lateinit var facingSwitch: ToggleButton
    // Vues de dialogue
    private lateinit var bourdonDialogueContainer: View
    private lateinit var bourdonMessageTextView: TextView
    // BOURDON'S REFACTOR: Suppression des vues li√©es √† l'intention.
    // private lateinit var pollenStartCaptureButton: Button
    // private lateinit var intentChoiceContainer: View
    // private lateinit var recordVoiceButton: ImageButton
    // private lateinit var pollenSkipIntentButton: Button
    // Vues de capture
    private lateinit var pollenRecyclerView: RecyclerView
    private lateinit var pollenAdapter: PollenPreviewAdapter
    private lateinit var captureButtonContainer: View
    private lateinit var captureButton: Button
    private lateinit var finishHarvestButton: Button
    // Vues de choix final
    private lateinit var finalChoiceContainer: View
    private lateinit var restartHarvestButton: Button
    private lateinit var sendToHiveButton: Button

    // Utilitaires
    private lateinit var cameraExecutor: ExecutorService
    private var cameraProvider: ProcessCameraProvider? = null
    private var imageCapture: ImageCapture? = null
    private var lensFacing = CameraSelector.LENS_FACING_BACK
    private lateinit var yuvToRgbConverter: YuvToRgbConverter
    private lateinit var pollenForge: PollenForge

    // BOURDON'S REFACTOR: Le launcher de permission micro est maintenant obsol√®te.
    private val requestCameraPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
        if (isGranted) {
            Log.i(TAG, "Permission cam√©ra accord√©e. Initialisation.")
            setupCamera()
        } else {
            Toast.makeText(this, "Permission cam√©ra refus√©e. Impossible de continuer.", Toast.LENGTH_LONG).show()
            finish()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_forge_live)
        Log.d(TAG, "[CYCLE DE VIE] onCreate")

        yuvToRgbConverter = YuvToRgbConverter(this)
        cameraExecutor = Executors.newSingleThreadExecutor()
        pollenForge = PollenForge(this)

        TtsService.initialize(this)

        bindViews()
        setupRecyclerView()
        setupListeners()
        checkCameraPermissionAndSetup()
        observeViewModel()
    }

    private fun bindViews() {
        Log.d(TAG, "Liaison des vues...")
        previewView = findViewById(R.id.live_preview_view)
        facingSwitch = findViewById(R.id.facing_switch)
        bourdonDialogueContainer = findViewById(R.id.bourdon_dialogue_container)
        bourdonMessageTextView = findViewById(R.id.bourdon_message_textview)
        // BOURDON'S REFACTOR: Les vues pour l'intention ne sont plus li√©es.
        pollenRecyclerView = findViewById(R.id.captured_pollen_recyclerview)
        captureButtonContainer = findViewById(R.id.capture_button_container)
        captureButton = findViewById(R.id.capture_and_forge_button)
        finishHarvestButton = findViewById(R.id.finish_harvest_button)
        finalChoiceContainer = findViewById(R.id.final_choice_container)
        restartHarvestButton = findViewById(R.id.restart_harvest_button)
        sendToHiveButton = findViewById(R.id.send_to_hive_button)
        Log.d(TAG, "Vues li√©es avec succ√®s.")
    }

    private fun setupRecyclerView() {
        // BOURDON'S REFACTOR: La logique de l'adapter reste la m√™me, mais son nom a √©t√© corrig√© dans d'autres fichiers.
        pollenAdapter = PollenPreviewAdapter(emptyList()) { pollenCapture ->
            val report = pollenCapture.report
            val jsonReport = pollenCapture.jsonReport
            if (pollenCapture.status == PollenAnalysisStatus.DONE && report != null && jsonReport != null) {
                val textReport = generateTextReport(report)
                SpecialistReportDialogFragment.newInstance(getString(R.string.specialist_report_dialog_title), textReport, jsonReport)
                    .show(supportFragmentManager, "SpecialistReportDialog")
            }
        }
        pollenRecyclerView.apply {
            layoutManager = LinearLayoutManager(this@ForgeLiveActivity, LinearLayoutManager.HORIZONTAL, false)
            adapter = pollenAdapter
        }
    }

    private fun setupListeners() {
        Log.d(TAG, "Configuration des listeners...")
        facingSwitch.setOnCheckedChangeListener(this)

        // BOURDON'S REFACTOR: Suppression des listeners pour les boutons d'intention.
        // pollenStartCaptureButton.setOnClickListener { viewModel.onStartCaptureRequested() }
        captureButton.setOnClickListener { takePhoto() }
        finishHarvestButton.setOnClickListener { viewModel.onStopHarvesting() }
        restartHarvestButton.setOnClickListener { viewModel.onRestartHarvest() }
        sendToHiveButton.setOnClickListener { viewModel.onSendToHive() }
        Log.d(TAG, "Listeners configur√©s.")
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    viewModel.uiState.collect { state ->
                        Log.d(TAG, "[UI UPDATE] Nouvel √©tat re√ßu: ${state.currentStep}")
                        updateUiForState(state)
                    }
                }
                launch {
                    viewModel.navigationEvent.collect {
                        Log.i(TAG, "[NAVIGATION] √âv√©nement de navigation re√ßu. Fermeture de l'activit√©.")
                        Toast.makeText(this@ForgeLiveActivity, R.string.pollen_save_toast, Toast.LENGTH_SHORT).show()
                        finish()
                    }
                }
            }
        }
    }

    private fun updateUiForState(state: ForgeLiveUiState) {
        if (state.bourdonMessage != null) {
            bourdonDialogueContainer.visibility = View.VISIBLE
            bourdonMessageTextView.text = state.bourdonMessage
            // BOURDON'S REFACTOR: TTS utilise la locale du syst√®me.
            TtsService.speak(state.bourdonMessage, Locale.getDefault()) {
                runOnUiThread { viewModel.onBourdonFinishedSpeaking() }
            }
        } else {
            bourdonDialogueContainer.visibility = View.GONE
        }

        // BOURDON'S REFACTOR: Visibilit√© simplifi√©e.
        captureButtonContainer.visibility = if (state.currentStep == HarvestStep.USER_CAPTURING_POLLEN) View.VISIBLE else View.GONE
        finalChoiceContainer.visibility = if (state.currentStep == HarvestStep.AWAITING_FINAL_CHOICE || state.currentStep == HarvestStep.SAVING || state.currentStep == HarvestStep.SAVED) View.VISIBLE else View.GONE

        if (state.currentStep == HarvestStep.USER_CAPTURING_POLLEN) {
            finishHarvestButton.visibility = if (state.canFinishHarvest) View.VISIBLE else View.GONE
            captureButton.isEnabled = state.capturedPollen.size < 4
            captureButton.text = if (state.capturedPollen.size >= 4) {
                getString(R.string.pollen_capture_button_full)
            } else {
                getString(R.string.pollen_capture_button_format, state.capturedPollen.size)
            }
        }

        if (state.currentStep == HarvestStep.AWAITING_FINAL_CHOICE || state.currentStep == HarvestStep.SAVING || state.currentStep == HarvestStep.SAVED) {
            val isSaving = state.currentStep == HarvestStep.SAVING
            restartHarvestButton.isEnabled = !isSaving
            sendToHiveButton.isEnabled = !isSaving
        }

        pollenAdapter.updatePollen(state.capturedPollen)
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "[CYCLE DE VIE] onResume")
        bindCameraUseCases()
        viewModel.startInteraction()
    }

    private fun takePhoto() {
        val imageCapture = this.imageCapture ?: return
        if (viewModel.uiState.value.capturedPollen.size >= 4) return
        captureButton.isEnabled = false
        Log.i(TAG, "D√©clenchement de la capture photo.")

        imageCapture.takePicture(
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageCapturedCallback() {
                @SuppressLint("UnsafeOptInUsageError")
                override fun onCaptureSuccess(image: ImageProxy) {
                    Log.d(TAG, "Capture r√©ussie. Rotation: ${image.imageInfo.rotationDegrees} degr√©s.")
                    val rotationDegrees = image.imageInfo.rotationDegrees
                    val bitmap = imageProxyToBitmap(image)
                    image.close()

                    if (bitmap != null) {
                        val rotatedBitmap = rotateBitmap(bitmap, rotationDegrees.toFloat())
                        viewModel.startPollenAnalysis(rotatedBitmap, pollenForge)
                    } else {
                        Log.e(TAG, "√âchec de la conversion de ImageProxy en Bitmap.")
                        Toast.makeText(this@ForgeLiveActivity, R.string.pollen_capture_error_toast, Toast.LENGTH_SHORT).show()
                        captureButton.isEnabled = true
                    }
                }
                override fun onError(exception: ImageCaptureException) {
                    Log.e(TAG, "√âchec de la capture d'image : ", exception)
                    Toast.makeText(this@ForgeLiveActivity, R.string.pollen_capture_failed_toast, Toast.LENGTH_SHORT).show()
                    captureButton.isEnabled = true
                }
            }
        )
    }

    private fun checkCameraPermissionAndSetup() {
        when {
            ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED -> {
                Log.d(TAG, "Permission cam√©ra d√©j√† accord√©e.")
                setupCamera()
            }
            else -> {
                Log.d(TAG, "Demande de la permission cam√©ra.")
                requestCameraPermissionLauncher.launch(Manifest.permission.CAMERA)
            }
        }
    }

    private fun setupCamera() {
        Log.d(TAG, "Configuration de la cam√©ra...")
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            cameraProvider = cameraProviderFuture.get()
            bindCameraUseCases()
        }, ContextCompat.getMainExecutor(this))
    }

    @SuppressLint("UnsafeOptInUsageError")
    private fun bindCameraUseCases() {
        val cameraProvider = cameraProvider ?: return
        Log.d(TAG, "Liaison des cas d'usage de la cam√©ra.")
        cameraProvider.unbindAll()
        val cameraSelector = CameraSelector.Builder().requireLensFacing(lensFacing).build()
        val preview = Preview.Builder().build().also { it.setSurfaceProvider(previewView.surfaceProvider) }
        imageCapture = ImageCapture.Builder().setTargetResolution(android.util.Size(1920, 1080)).build()
        try {
            cameraProvider.bindToLifecycle(this, cameraSelector, preview, imageCapture)
            Log.d(TAG, "Cas d'usage li√©s avec succ√®s.")
        } catch (e: Exception) {
            Log.e(TAG, "La liaison des cas d'usage a √©chou√©", e)
        }
    }

    private fun rotateBitmap(source: Bitmap, angle: Float): Bitmap {
        if (angle == 0f) return source
        val matrix = Matrix()
        matrix.postRotate(angle)
        return Bitmap.createBitmap(source, 0, 0, source.width, source.height, matrix, true)
    }

    @SuppressLint("UnsafeOptInUsageError")
    private fun imageProxyToBitmap(image: ImageProxy): Bitmap? {
        return when (image.format) {
            ImageFormat.YUV_420_888 -> {
                val bitmap = Bitmap.createBitmap(image.width, image.height, Bitmap.Config.ARGB_8888)
                yuvToRgbConverter.yuvToRgb(image.image!!, bitmap)
                bitmap
            }
            ImageFormat.JPEG -> {
                val buffer = image.planes[0].buffer
                val bytes = ByteArray(buffer.remaining())
                buffer.get(bytes)
                BitmapFactory.decodeByteArray(bytes, 0, bytes.size)
            }
            else -> null
        }
    }

    override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {
        lensFacing = if (isChecked) CameraSelector.LENS_FACING_FRONT else CameraSelector.LENS_FACING_BACK
        Log.d(TAG, "Changement de cam√©ra vers: ${if (isChecked) "AVANT" else "ARRI√àRE"}")
        bindCameraUseCases()
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "[CYCLE DE VIE] onPause")
        cameraProvider?.unbindAll()
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "[CYCLE DE VIE] onDestroy")
        cameraExecutor.shutdown()
        TtsService.shutdown()
    }

    private fun generateTextReport(report: PollenAnalysis): String {
        val sb = StringBuilder()
        sb.append(getString(R.string.specialist_report_global_title)).append("\n")
        if (report.globalAnalysis.isEmpty()) {
            sb.append(getString(R.string.specialist_report_no_global)).append("\n")
        } else {
            report.globalAnalysis.forEach { specialistReport ->
                sb.append(getString(R.string.specialist_report_specialist_opinion, specialistReport.specialistName)).append("\n")
                specialistReport.results.take(3).forEach { result ->
                    sb.append(getString(R.string.specialist_report_item, result.label, result.confidence * 100)).append("\n")
                }
            }
        }
        sb.append("\n").append(getString(R.string.specialist_report_objects_title, report.analyzedObjects.size)).append("\n")
        if (report.analyzedObjects.isEmpty()) {
            sb.append(getString(R.string.specialist_report_no_objects)).append("\n")
        } else {
            report.analyzedObjects.forEachIndexed { index, analyzedObject ->
                val mainLabel = analyzedObject.detectedObject.labels.firstOrNull()
                sb.append(getString(R.string.specialist_report_object_item, index + 1, mainLabel?.text ?: getString(R.string.specialist_report_unknown_object), (mainLabel?.confidence ?: 0f) * 100)).append("\n")
                analyzedObject.specialistReports.forEach { specialistReport ->
                    sb.append(getString(R.string.specialist_report_object_specialist_item, specialistReport.specialistName, specialistReport.results.firstOrNull()?.label ?: "N/A")).append("\n")
                }
            }
        }
        return sb.toString()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---

package be.heyman.android.ai.kikko.pollen

import android.app.Application
import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.Constraints
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.model.PollenGrain as DbPollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
// BOURDON'S FIX: La r√©f√©rence √† l'ancien IdentificationWorker est supprim√©e.
// import be.heyman.android.ai.kikko.worker.IdentificationWorker
// BOURDON'S FIX: La nouvelle r√©f√©rence pointe vers le worker unifi√©.
import be.heyman.android.ai.kikko.worker.ForgeWorker
import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.UUID

enum class HarvestStep {
    IDLE,
    BOURDON_INTRO,
    USER_CAPTURING_POLLEN,
    AWAITING_FINAL_CHOICE,
    SAVING,
    SAVED
}

data class ForgeLiveUiState(
    val currentStep: HarvestStep = HarvestStep.IDLE,
    val userIntent: String = "",
    val capturedPollen: List<PollenCapture> = emptyList(),
    val bourdonMessage: String? = null,
    val canFinishHarvest: Boolean = false
)

class ForgeLiveViewModel(application: Application) : AndroidViewModel(application) {

    private val TAG = "ForgeLiveViewModel"

    private val _uiState = MutableStateFlow(ForgeLiveUiState())
    val uiState = _uiState.asStateFlow()

    private val _navigationEvent = MutableSharedFlow<Unit>()
    val navigationEvent = _navigationEvent.asSharedFlow()

    private val pollenGrainDao = PollenGrainDao(application)
    private val gson = Gson()
    private val workManager = WorkManager.getInstance(application)


    fun startInteraction() {
        if (_uiState.value.currentStep != HarvestStep.IDLE) return
        Log.d(TAG, "[FLUX] D√©marrage de l'interaction. Passage √† BOURDON_INTRO.")
        _uiState.update {
            it.copy(
                currentStep = HarvestStep.BOURDON_INTRO,
                bourdonMessage = getApplication<Application>().getString(R.string.bourdon_welcome_capture)
            )
        }
    }

    fun onBourdonFinishedSpeaking() {
        _uiState.update {
            val nextStep = when (it.currentStep) {
                HarvestStep.BOURDON_INTRO -> HarvestStep.USER_CAPTURING_POLLEN
                else -> it.currentStep
            }
            Log.d(TAG, "[FLUX] Le Bourdon a fini de parler. Passage √† l'√©tat: $nextStep")
            it.copy(currentStep = nextStep, bourdonMessage = null)
        }
    }

    fun startPollenAnalysis(bitmap: Bitmap, pollenForge: PollenForge) {
        if (_uiState.value.capturedPollen.size >= 4) {
            Log.w(TAG, "[ANALYSE] Tentative de capture alors que le maximum (4) est atteint. Ignor√©.")
            return
        }

        val newCapture = PollenCapture(bitmap = bitmap)
        _uiState.update { it.copy(capturedPollen = it.capturedPollen + newCapture) }
        Log.i(TAG, "[ANALYSE] Nouvelle capture ajout√©e (ID: ${newCapture.id}). Lancement de l'analyse par la PollenForge.")

        viewModelScope.launch {
            val (report, jsonReport) = pollenForge.processImage(bitmap)
            Log.i(TAG, "[ANALYSE] Analyse termin√©e pour la capture ID: ${newCapture.id}.")

            _uiState.update { currentState ->
                val updatedList = currentState.capturedPollen.map { capture ->
                    if (capture.id == newCapture.id) {
                        capture.copy(status = PollenAnalysisStatus.DONE, report = report, jsonReport = jsonReport)
                    } else {
                        capture
                    }
                }

                val canFinish = updatedList.isNotEmpty()
                val shouldStopCapture = updatedList.size >= 4 && currentState.currentStep == HarvestStep.USER_CAPTURING_POLLEN

                if (shouldStopCapture) {
                    Log.d(TAG, "[FLUX] Maximum de captures atteint. Passage √† AWAITING_FINAL_CHOICE.")
                    currentState.copy(
                        capturedPollen = updatedList,
                        currentStep = HarvestStep.AWAITING_FINAL_CHOICE,
                        bourdonMessage = getApplication<Application>().getString(R.string.bourdon_harvest_complete),
                        canFinishHarvest = canFinish
                    )
                } else {
                    currentState.copy(
                        capturedPollen = updatedList,
                        canFinishHarvest = canFinish
                    )
                }
            }
        }
    }

    fun onStopHarvesting() {
        Log.d(TAG, "[FLUX] L'utilisateur a termin√© la r√©colte manuellement. Passage √† AWAITING_FINAL_CHOICE.")
        _uiState.update {
            it.copy(
                currentStep = HarvestStep.AWAITING_FINAL_CHOICE,
                bourdonMessage = getApplication<Application>().getString(R.string.bourdon_harvest_complete_alt)
            )
        }
    }

    fun onRestartHarvest() {
        Log.i(TAG, "[FLUX] R√©initialisation de la session de r√©colte.")
        _uiState.value = ForgeLiveUiState()
        startInteraction()
    }

    fun onSendToHive() {
        val currentState = _uiState.value
        if (currentState.capturedPollen.isEmpty() || currentState.currentStep == HarvestStep.SAVING) return

        viewModelScope.launch {
            Log.d(TAG, "[FLUX] Envoi du pollen √† la Ruche. Passage √† SAVING.")
            _uiState.update { it.copy(currentStep = HarvestStep.SAVING, bourdonMessage = getApplication<Application>().getString(R.string.bourdon_save_pollen)) }

            val savedImagePaths = savePollenImages(currentState.capturedPollen)

            if (savedImagePaths.isEmpty()) {
                Log.e(TAG, "[FLUX] Erreur critique lors de la sauvegarde des images. Le processus est interrompu.")
                _uiState.update { it.copy(currentStep = HarvestStep.AWAITING_FINAL_CHOICE, bourdonMessage = getApplication<Application>().getString(R.string.bourdon_save_error)) }
                return@launch
            }

            val aggregatedReport = aggregateJsonReports(currentState.capturedPollen)

            val pollenToSave = DbPollenGrain(
                userIntent = null,
                pollenImagePaths = savedImagePaths,
                swarmAnalysisReportJson = aggregatedReport,
                status = PollenStatus.RAW
            )

            Log.i(TAG, "CONTENU DU RAPPORT JSON SAUVEGARD√â :\n$aggregatedReport")

            pollenGrainDao.insert(pollenToSave)
            Log.i(TAG, "Nouveau PollenGrain (ID: ${pollenToSave.id}) ins√©r√© dans la base de donn√©es.")

            // BOURDON'S FIX: Appel √† la nouvelle fonction qui utilise le bon worker.
            launchForgeWorker()

            _uiState.update { it.copy(currentStep = HarvestStep.SAVED, bourdonMessage = getApplication<Application>().getString(R.string.bourdon_save_success)) }

            kotlinx.coroutines.delay(2000)
            _navigationEvent.emit(Unit)
        }
    }

    // BOURDON'S FIX: La fonction est renomm√©e et corrig√©e pour utiliser ForgeWorker.
    private fun launchForgeWorker() {
        Log.d(TAG, "Lancement du ForgeWorker.")

        val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
        val requiresCharging = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_CHARGING, false)
        val requiresIdle = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_IDLE, false)

        val constraints = Constraints.Builder()
            .setRequiresCharging(requiresCharging)
            .setRequiresDeviceIdle(requiresIdle)
            .build()

        val forgeRequest = OneTimeWorkRequestBuilder<ForgeWorker>()
            .setConstraints(constraints)
            .build()

        workManager.beginUniqueWork(
            "PollenForgeChain",
            ExistingWorkPolicy.APPEND_OR_REPLACE,
            forgeRequest
        ).enqueue()

        Log.i(TAG, "ForgeWorker mis en file d'attente avec succ√®s.")
    }

    private suspend fun savePollenImages(captures: List<PollenCapture>): List<String> = withContext(Dispatchers.IO) {
        val imagePaths = mutableListOf<String>()
        val pollenDir = File(getApplication<Application>().filesDir, "pollen_captures")
        if (!pollenDir.exists()) pollenDir.mkdirs()
        Log.d(TAG, "Sauvegarde de ${captures.size} images dans le r√©pertoire: ${pollenDir.absolutePath}")

        captures.forEach { capture ->
            val fileName = "pollen_${UUID.randomUUID()}.png"
            val file = File(pollenDir, fileName)
            try {
                FileOutputStream(file).use { out ->
                    capture.bitmap.compress(Bitmap.CompressFormat.PNG, 90, out)
                    imagePaths.add(file.absolutePath)
                }
            } catch (e: IOException) {
                Log.e("ForgeLiveViewModel", "Erreur lors de la sauvegarde de l'image du pollen: ${file.absolutePath}", e)
                return@withContext emptyList<String>()
            }
        }
        Log.i(TAG, "${imagePaths.size} images sauvegard√©es avec succ√®s.")
        return@withContext imagePaths
    }

    private fun aggregateJsonReports(captures: List<PollenCapture>): String {
        val allReports = captures.mapNotNull { capture ->
            capture.jsonReport?.let { gson.fromJson(it, Map::class.java) }
        }
        return gson.toJson(mapOf("reports" to allReports))
    }

    fun reset() {
        Log.i(TAG, "ViewModel r√©initialis√© √† son √©tat initial.")
        _uiState.value = ForgeLiveUiState()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/LivePollenHarvester.kt ---

package be.heyman.android.ai.kikko.pollen

import android.annotation.SuppressLint
import androidx.camera.core.ImageProxy
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import java.util.concurrent.atomic.AtomicInteger

/**
 * Chef d'orchestre qui g√®re la synchronisation de plusieurs processeurs.
 */
class LivePollenHarvester {

    private val scoutBees = mutableListOf<VisionProcessorBase<*>>()
    private var isShutdown = false

    var isTextRecognitionEnabled = false
    var isBarcodeScanningEnabled = false
    var isObjectDetectionEnabled = false

    @Synchronized
    fun addScoutBee(bee: VisionProcessorBase<*>) {
        scoutBees.add(bee)
    }

    @SuppressLint("UnsafeOptInUsageError")
    @Synchronized
    fun processImageProxy(
        imageProxy: ImageProxy,
        graphicOverlay: GraphicOverlay,
        onAllWorkDone: () -> Unit
    ) {
        if (isShutdown) {
            imageProxy.close()
            return
        }

        val activeProcessors = mutableListOf<VisionProcessorBase<*>>()
        if (isTextRecognitionEnabled) {
            scoutBees.filterIsInstance<PollenTextRecognitionProcessor>().firstOrNull()?.let { activeProcessors.add(it) }
        }
        if (isBarcodeScanningEnabled) {
            scoutBees.filterIsInstance<PollenBarcodeScannerProcessor>().firstOrNull()?.let { activeProcessors.add(it) }
        }
        if (isObjectDetectionEnabled) {
            scoutBees.filterIsInstance<PollenObjectDetectorProcessor>().firstOrNull()?.let { activeProcessors.add(it) }
        }

        if (activeProcessors.isEmpty()) {
            imageProxy.close()
            onAllWorkDone()
            return
        }

        val remainingTasks = AtomicInteger(activeProcessors.size)
        val onFinished = {
            if (remainingTasks.decrementAndGet() == 0) {
                imageProxy.close()
                onAllWorkDone()
            }
        }

        graphicOverlay.clear()

        activeProcessors.forEach { processor ->
            processor.processImageProxy(imageProxy, graphicOverlay, onFinished)
        }
    }

    @Synchronized
    fun stop() {
        isShutdown = true
        scoutBees.forEach { it.stop() }
        scoutBees.clear()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/LivePollenHarvester.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenAnalysisStatus.kt ---

package be.heyman.android.ai.kikko.pollen

/**
 * D√©finit les diff√©rents √©tats possibles pour l'analyse d'un grain de pollen
 * pendant la phase de capture en direct.
 */
enum class PollenAnalysisStatus {
    /**
     * L'analyse par les Abeilles Sp√©cialistes est en cours.
     */
    PROCESSING,

    /**
     * L'analyse est termin√©e avec succ√®s et un rapport est disponible.
     */
    DONE,

    /**
     * Une erreur est survenue durant l'analyse.
     */
    ERROR
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenAnalysisStatus.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.barcode.common.Barcode

class PollenBarcodeGraphic(
    overlay: GraphicOverlay,
    private val barcode: Barcode?
) : GraphicOverlay.Graphic(overlay) {

    private var rectPaint: Paint = Paint().apply {
        color = BOX_COLOR
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
    }

    private var barcodePaint: Paint = Paint().apply {
        color = TEXT_COLOR
        textSize = TEXT_SIZE
    }

    override fun draw(canvas: Canvas) {
        if (barcode == null || barcode.boundingBox == null) return

        val rect = RectF(barcode.boundingBox)

        // BOURDON'S FIX: Utilisation de overlay.translateX et overlay.translateY
        val mappedRect = RectF(
            overlay.translateX(rect.left),
            overlay.translateY(rect.top),
            overlay.translateX(rect.right),
            overlay.translateY(rect.bottom)
        )
        canvas.drawRect(mappedRect, rectPaint)

        barcode.rawValue?.let {
            canvas.drawText(it, mappedRect.left, mappedRect.bottom + TEXT_SIZE, barcodePaint)
        }
    }

    companion object {
        private const val BOX_COLOR = Color.CYAN
        private const val TEXT_COLOR = Color.CYAN
        private const val STROKE_WIDTH = 5.0f
        private const val TEXT_SIZE = 40.0f
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeScannerProcessor.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import com.google.android.gms.tasks.Task
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage

/**
 * Processeur sp√©cialis√© dans la d√©tection de codes-barres.
 */
class PollenBarcodeScannerProcessor(context: Context) : VisionProcessorBase<List<Barcode>>(context) {

    private val barcodeScanner: BarcodeScanner

    init {
        val options = BarcodeScannerOptions.Builder()
            .setBarcodeFormats(
                Barcode.FORMAT_QR_CODE,
                Barcode.FORMAT_AZTEC,
                Barcode.FORMAT_EAN_13,
                Barcode.FORMAT_UPC_A
            )
            .build()
        barcodeScanner = BarcodeScanning.getClient(options)
    }

    override fun stop() {
        super.stop()
        barcodeScanner.close()
    }

    override fun detectInImage(image: InputImage): Task<List<Barcode>> {
        return barcodeScanner.process(image)
    }

    override fun onSuccess(results: List<Barcode>, graphicOverlay: GraphicOverlay) {
        if (results.isEmpty()) {
            return
        }
        for (barcode in results) {
            graphicOverlay.add(PollenBarcodeGraphic(graphicOverlay, barcode))
        }
    }

    override fun onFailure(e: Exception) {
        Log.e(TAG, "La d√©tection de code-barres a √©chou√©.", e)
    }

    companion object {
        private const val TAG = "BarcodeScannerProc"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeScannerProcessor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenCapture.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Bitmap
import java.util.UUID

/**
 * Repr√©sente un grain de pollen individuel pendant la phase de capture en direct.
 * C'est un objet de l'interface utilisateur (UI model) qui contient le bitmap pour
 * l'affichage et les r√©sultats d'analyse en temps r√©el.
 *
 * Cet objet est √©ph√©m√®re et sera transform√© en un 'PollenGrain' persistant
 * (du package model) au moment de la sauvegarde.
 *
 * @param id Un identifiant unique pour suivre le grain dans l'UI.
 * @param bitmap L'image captur√©e, utilis√©e pour l'affichage et l'analyse.
 * @param status L'√©tat actuel de l'analyse pour ce grain.
 * @param report Le rapport d'analyse structur√© une fois l'analyse termin√©e.
 * @param jsonReport Le rapport d'analyse complet en format JSON.
 */
data class PollenCapture(
    val id: String = UUID.randomUUID().toString(),
    val bitmap: Bitmap,
    var status: PollenAnalysisStatus = PollenAnalysisStatus.PROCESSING,
    var report: PollenAnalysis? = null,
    var jsonReport: String? = null
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenCapture.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenForge.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import com.google.gson.GsonBuilder
import com.google.mlkit.common.model.LocalModel
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.label.ImageLabel
import com.google.mlkit.vision.label.ImageLabeler
import com.google.mlkit.vision.label.ImageLabeling
import com.google.mlkit.vision.label.custom.CustomImageLabelerOptions
import com.google.mlkit.vision.label.defaults.ImageLabelerOptions
import com.google.mlkit.vision.objects.DetectedObject
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.tasks.await
import java.io.Closeable

/**
 * Orchestre une analyse multi-niveaux avec une escouade compl√®te de classifieurs sp√©cialis√©s,
 * un OCR et un scanner de codes-barres.
 * BOURDON'S REFACTOR: Cette version est maintenant robuste et charge les mod√®les s√©quentiellement.
 */
class PollenForge(private val context: Context) {

    private val TAG = "PollenForge"

    private val specialistModelPaths = mapOf(
        "D√©faut ML Kit" to "DEFAULT", // Cas sp√©cial pour le mod√®le par d√©faut
        "Labeler Objet" to "object_labeler.tflite",
        "Plantes" to "aiy-tflite-vision-classifier-plants-v1-v3.tflite",
        "Insectes" to "aiy-tflite-vision-classifier-insects-v1-v3.tflite",
        "Oiseaux" to "aiy-tflite-vision-classifier-birds-v1-v3.tflite",
        "Nourriture" to "aiy-tflite-vision-classifier-food-v1-v1.tflite",
        "EfficientNet-L0" to "efficientnet_lite0.tflite",
        "EfficientNet-L1" to "efficientnet_lite1_int8_2.tflite",
        "EfficientNet-L2" to "efficientnet_lite2_int8_2.tflite",
        "MobileNetV1" to "mobilenet_v1_1.0_224_quantized_1_metadata_1.tflite"
    )

    private fun createImageLabeler(modelPath: String): ImageLabeler {
        return if (modelPath == "DEFAULT") {
            ImageLabeling.getClient(ImageLabelerOptions.DEFAULT_OPTIONS)
        } else {
            val localModel = LocalModel.Builder().setAssetFilePath(modelPath).build()
            val options = CustomImageLabelerOptions.Builder(localModel)
                .setConfidenceThreshold(0.1f)
                .setMaxResultCount(4)
                .build()
            ImageLabeling.getClient(options)
        }
    }

    suspend fun processImage(bitmap: Bitmap): Pair<PollenAnalysis, String> = coroutineScope {
        val highResImage = InputImage.fromBitmap(bitmap, 0)
        var objectDetector: com.google.mlkit.vision.objects.ObjectDetector? = null
        var textRecognizer: com.google.mlkit.vision.text.TextRecognizer? = null
        var barcodeScanner: BarcodeScanner? = null
        val closableClients = mutableListOf<Closeable>()

        try {
            // --- √âtape 1: D√©tection d'objets ---
            val objectDetectorOptions = ObjectDetectorOptions.Builder()
                .setDetectorMode(ObjectDetectorOptions.SINGLE_IMAGE_MODE)
                .enableMultipleObjects().enableClassification().build()
            objectDetector = ObjectDetection.getClient(objectDetectorOptions)
            closableClients.add(objectDetector)
            val detectedObjects = objectDetector.process(highResImage).await()
            Log.d(TAG, "Phase 1: ${detectedObjects.size} objets d√©tect√©s.")

            // --- √âtape 2: Analyse Globale (Sp√©cialistes S√©quentiels + OCR + Barcode) ---
            val globalSpecialistResults = mutableListOf<Pair<String, List<ImageLabel>>>()
            for ((name, path) in specialistModelPaths) {
                Log.d(TAG, "Analyse globale avec le sp√©cialiste: $name")
                val labeler = createImageLabeler(path)
                try {
                    val labels = labeler.process(highResImage).await()
                    globalSpecialistResults.add(Pair(name, labels))
                } finally {
                    labeler.close() // Lib√®re les ressources imm√©diatement
                }
            }

            textRecognizer = TextRecognition.getClient(JapaneseTextRecognizerOptions.Builder().build())
            closableClients.add(textRecognizer)
            barcodeScanner = BarcodeScanning.getClient()
            closableClients.add(barcodeScanner)

            val globalOcrResult = textRecognizer.process(highResImage).await()
            val barcodeResults = barcodeScanner.process(highResImage).await()
            Log.d(TAG, "Phase 2: Analyse globale termin√©e.")

            // --- √âtape 3: Analyse par Objet (report√©e pour la stabilit√©) ---
            // Pour l'instant, on se concentre sur la stabilisation de l'analyse globale.
            Log.d(TAG, "Phase 3: Analyse par objet d√©sactiv√©e pour cette version.")
            val analyzedObjectsResults = emptyList<AnalyzedObject>()

            // --- √âtape 4: Construction des rapports ---
            val pollenAnalysisReport = PollenAnalysis(
                imageWidth = bitmap.width,
                imageHeight = bitmap.height,
                globalAnalysis = globalSpecialistResults.map { SpecialistReport(it.first, it.second.toClassifierResults()) }.filter { it.results.isNotEmpty() },
                analyzedObjects = analyzedObjectsResults,
                structuredOcrResult = globalOcrResult.toStructuredResult(),
                barcodeResults = barcodeResults.map { BarcodeResult(it.displayValue, it.format.toString()) }
            )

            val jsonReport = generateJsonReport(bitmap, barcodeResults, globalOcrResult, detectedObjects, globalSpecialistResults)

            return@coroutineScope Pair(pollenAnalysisReport, jsonReport)

        } finally {
            // Assure que tous les clients principaux sont ferm√©s
            closableClients.forEach {
                try { it.close() } catch (e: Exception) { Log.e(TAG, "Erreur lors de la fermeture d'un client ML Kit.", e) }
            }
        }
    }

    private fun List<ImageLabel>.toClassifierResults(): List<ClassifierResult> {
        return this.map { ClassifierResult(it.text, it.confidence) }
    }

    private fun Text.toStructuredResult(): List<OcrBlock> {
        return this.textBlocks.map { block ->
            OcrBlock(
                text = block.text,
                boundingBox = block.boundingBox,
                lines = block.lines.map { line ->
                    OcrLine(
                        text = line.text,
                        boundingBox = line.boundingBox,
                        elements = line.elements.map { element ->
                            OcrElement(
                                text = element.text,
                                boundingBox = element.boundingBox
                            )
                        }
                    )
                }
            )
        }
    }

    private fun generateJsonReport(
        bitmap: Bitmap,
        barcodes: List<Barcode>,
        ocrResult: Text,
        detectedObjects: List<DetectedObject>,
        specialistResults: List<Pair<String, List<ImageLabel>>>
    ): String {
        val gson = GsonBuilder().setPrettyPrinting().create()
        val reportMap = mutableMapOf<String, Any>()

        reportMap["image_dimensions"] = mapOf("width" to bitmap.width, "height" to bitmap.height)
        reportMap["barcode_scanner_results"] = barcodes.map { mapOf("format" to it.format, "raw_value" to it.rawValue) }
        reportMap["ocr_results"] = mapOf("full_text" to ocrResult.text)
        reportMap["object_detection_results"] = detectedObjects.map { obj ->
            mapOf(
                "labels" to obj.labels.map { label -> mapOf("text" to label.text, "confidence" to label.confidence) }
            )
        }
        reportMap["global_classification_results"] = specialistResults.associate { (name, labels) ->
            name to labels.map { mapOf("label" to it.text, "confidence" to it.confidence) }
        }

        return gson.toJson(reportMap)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenForge.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenGrain.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Bitmap
import java.util.UUID

/**
 * Repr√©sente un grain de pollen individuel avec son image, son √©tat et son rapport.
 * BOURDON'S REFACTOR: La classe a √©t√© enrichie pour suivre le statut de l'analyse
 * et conserver les rapports g√©n√©r√©s par la PollenForge.
 */
data class PollenGrain(
    val id: String = UUID.randomUUID().toString(),
    val bitmap: Bitmap,
    val status: PollenAnalysisStatus = PollenAnalysisStatus.PROCESSING,
    val report: PollenAnalysis? = null,
    val jsonReport: String? = null
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenGrain.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectDetectorProcessor.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import com.google.android.gms.tasks.Task
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.objects.DetectedObject
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.ObjectDetector
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions

/**
 * Un processeur qui utilise le D√âTECTEUR D'OBJETS PAR D√âFAUT de ML Kit.
 * C'est la version corrig√©e qui est capable de fournir des bo√Ætes englobantes.
 */
class PollenObjectDetectorProcessor(context: Context) : VisionProcessorBase<List<DetectedObject>>(context) {

    private val objectDetector: ObjectDetector

    init {
        // Configure l'ObjectDetector pour le mode streaming (cam√©ra en direct),
        // en activant la d√©tection de plusieurs objets et leur classification.
        val options = ObjectDetectorOptions.Builder()
            .setDetectorMode(ObjectDetectorOptions.STREAM_MODE)
            .enableMultipleObjects()
            .enableClassification()
            .build()
        objectDetector = ObjectDetection.getClient(options)
    }

    override fun stop() {
        super.stop()
        objectDetector.close()
    }

    override fun detectInImage(image: InputImage): Task<List<DetectedObject>> {
        return objectDetector.process(image)
    }

    override fun onSuccess(results: List<DetectedObject>, graphicOverlay: GraphicOverlay) {
        for (detectedObject in results) {
            graphicOverlay.add(PollenObjectGraphic(graphicOverlay, detectedObject))
        }
    }

    override fun onFailure(e: Exception) {
        Log.e(TAG, "La d√©tection d'objet a √©chou√©.", e)
    }

    companion object {
        private const val TAG = "ObjectDetectorProcessor"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectDetectorProcessor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.objects.DetectedObject
import java.util.Locale
import kotlin.math.max
import kotlin.math.min

/**
 * Objet graphique pour dessiner les objets d√©tect√©s et leurs √©tiquettes sur la GraphicOverlay.
 */
class PollenObjectGraphic(
    overlay: GraphicOverlay,
    private val detectedObject: DetectedObject
) : GraphicOverlay.Graphic(overlay) {

    private val boxPaint: Paint = Paint().apply {
        color = OBJECT_COLOR
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
    }

    private val textPaint: Paint = Paint().apply {
        color = Color.WHITE
        textSize = TEXT_SIZE
    }

    private val labelBackgroundPaint: Paint = Paint().apply {
        color = OBJECT_COLOR
        style = Paint.Style.FILL
    }

    override fun draw(canvas: Canvas) {
        // La bo√Æte de d√©limitation fournie par ML Kit
        val rect = RectF(detectedObject.boundingBox)

        // Traduction des coordonn√©es pour l'affichage
        val mappedRect = RectF(
            overlay.translateX(rect.left),
            overlay.translateY(rect.top),
            overlay.translateX(rect.right),
            overlay.translateY(rect.bottom)
        )

        // Dessine la bo√Æte
        canvas.drawRect(mappedRect, boxPaint)

        // Dessine la premi√®re √©tiquette trouv√©e (la plus probable) au-dessus de la bo√Æte.
        detectedObject.labels.firstOrNull()?.let { label ->
            val text = "${label.text.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }} (${"%.0f".format(label.confidence * 100)}%)"
            val textWidth = textPaint.measureText(text)
            val textHeight = TEXT_SIZE

            // Dessine un fond pour le texte pour une meilleure lisibilit√©
            canvas.drawRect(
                mappedRect.left,
                mappedRect.top - textHeight - (STROKE_WIDTH * 2),
                mappedRect.left + textWidth + (STROKE_WIDTH * 2),
                mappedRect.top,
                labelBackgroundPaint
            )

            // Dessine le texte
            canvas.drawText(
                text,
                mappedRect.left + STROKE_WIDTH,
                mappedRect.top - STROKE_WIDTH,
                textPaint
            )
        }
    }

    companion object {
        private const val OBJECT_COLOR = Color.MAGENTA // Magenta pour bien se distinguer
        private const val TEXT_SIZE = 40.0f
        private const val STROKE_WIDTH = 5.0f
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenPreviewAdapter.kt ---

package be.heyman.android.ai.kikko.pollen

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R

/**
 * BOURDON'S REFACTOR: L'adaptateur g√®re maintenant l'affichage des `PollenCapture`
 * et les clics sur les items termin√©s.
 *
 * @param pollenCaptures La liste des pollens (mod√®le UI) √† afficher.
 * @param onPollenClick Le callback √† ex√©cuter lorsqu'un grain de pollen analys√© est cliqu√©.
 */
class PollenPreviewAdapter(
    private var pollenCaptures: List<PollenCapture>,
    private val onPollenClick: (PollenCapture) -> Unit
) : RecyclerView.Adapter<PollenPreviewAdapter.PollenViewHolder>() {

    class PollenViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.pollen_preview_imageview)
        val progressIndicator: View = view.findViewById(R.id.pollen_progress_indicator)
        val doneIcon: View = view.findViewById(R.id.pollen_done_icon)
        val removeButton: View = view.findViewById(R.id.pollen_remove_button)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PollenViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_pollen_preview, parent, false)
        return PollenViewHolder(view)
    }

    override fun onBindViewHolder(holder: PollenViewHolder, position: Int) {
        val capture = pollenCaptures[position]
        holder.imageView.setImageBitmap(capture.bitmap)
        // La logique du bouton de suppression est pour l'instant masqu√©e.
        holder.removeButton.visibility = View.GONE

        when (capture.status) {
            PollenAnalysisStatus.PROCESSING -> {
                holder.progressIndicator.visibility = View.VISIBLE
                holder.doneIcon.visibility = View.GONE
                holder.itemView.isClickable = false
            }
            PollenAnalysisStatus.DONE -> {
                holder.progressIndicator.visibility = View.GONE
                holder.doneIcon.visibility = View.VISIBLE
                holder.itemView.isClickable = true
                holder.itemView.setOnClickListener { onPollenClick(capture) }
            }
            PollenAnalysisStatus.ERROR -> {
                holder.progressIndicator.visibility = View.GONE
                holder.doneIcon.visibility = View.GONE // Id√©alement, afficher une ic√¥ne d'erreur ici.
                holder.itemView.isClickable = false
            }
        }
    }

    override fun getItemCount() = pollenCaptures.size

    fun updatePollen(newCaptures: List<PollenCapture>) {
        this.pollenCaptures = newCaptures
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenPreviewAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenReport.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Rect
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.objects.DetectedObject

/**
 * Contient le r√©sultat d'un classifieur : une √©tiquette et sa confiance.
 */
data class ClassifierResult(val label: String, val confidence: Float)

/**
 * Contient le rapport complet d'un sp√©cialiste (ex: "Plantes", "Oiseaux").
 */
data class SpecialistReport(val specialistName: String, val results: List<ClassifierResult>)

/**
 * Repr√©sente un objet d√©tect√© qui a √©t√© analys√© en profondeur.
 * Contient l'objet original et tous les rapports des sp√©cialistes le concernant.
 */
data class AnalyzedObject(
    val detectedObject: DetectedObject,
    val specialistReports: List<SpecialistReport>
)

/**
 * Contient les informations extraites d'un code-barres.
 */
data class BarcodeResult(
    val displayValue: String?,
    val format: String
)

// BOURDON'S FIX: Ajout de structures de donn√©es pour un rapport OCR d√©taill√©.
/**
 * Repr√©sente un mot ou un √©l√©ment de texte reconnu par l'OCR.
 */
data class OcrElement(
    val text: String,
    val boundingBox: Rect?
)

/**
 * Repr√©sente une ligne de texte reconnue par l'OCR.
 */
data class OcrLine(
    val text: String,
    val boundingBox: Rect?,
    val elements: List<OcrElement>
)

/**
 * Repr√©sente un bloc de texte (paragraphe) reconnu par l'OCR.
 */
data class OcrBlock(
    val text: String,
    val boundingBox: Rect?,
    val lines: List<OcrLine>
)


/**
 * Le rapport d'analyse final et complet de la Forge.
 */
data class PollenAnalysis(
    val imageWidth: Int,
    val imageHeight: Int,
    val globalAnalysis: List<SpecialistReport>, // Analyse sur l'image enti√®re
    val analyzedObjects: List<AnalyzedObject>, // Analyse par objet
    // BOURDON'S FIX: Remplacement de la cha√Æne de caract√®res simple par une structure hi√©rarchique.
    val structuredOcrResult: List<OcrBlock>,
    val barcodeResults: List<BarcodeResult>
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenReport.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.text.Text

class PollenTextGraphic(
    overlay: GraphicOverlay,
    private val text: Text
) : GraphicOverlay.Graphic(overlay) {

    private val textPaint: Paint = Paint().apply {
        color = TEXT_COLOR
        textSize = TEXT_SIZE
        textAlign = Paint.Align.LEFT
    }

    private val rectPaint: Paint = Paint().apply {
        color = BOX_COLOR
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
    }

    override fun draw(canvas: Canvas) {
        for (block in text.textBlocks) {
            for (line in block.lines) {
                if (line.boundingBox != null) {
                    val rect = RectF(line.boundingBox)
                    // BOURDON'S FIX: Utilisation de overlay.translateX et overlay.translateY
                    canvas.drawRect(
                        overlay.translateX(rect.left),
                        overlay.translateY(rect.top),
                        overlay.translateX(rect.right),
                        overlay.translateY(rect.bottom),
                        rectPaint
                    )

                    canvas.drawText(
                        line.text,
                        overlay.translateX(rect.left),
                        overlay.translateY(rect.bottom),
                        textPaint
                    )
                }
            }
        }
    }

    companion object {
        private const val TEXT_COLOR = Color.WHITE
        private const val BOX_COLOR = Color.GREEN
        private const val TEXT_SIZE = 45.0f
        private const val STROKE_WIDTH = 5.0f
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextRecognitionProcessor.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import com.google.android.gms.tasks.Task
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.TextRecognizer
// BOURDON'S FIX: Importation n√©cessaire pour les options japonaises.
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions

/**
 * Processeur sp√©cialis√© dans la reconnaissance de texte.
 * Cette version est configur√©e pour le japonais.
 */
class PollenTextRecognitionProcessor(
    context: Context
) : VisionProcessorBase<Text>(context) {

    // BOURDON'S FIX: On remplace les options par d√©faut par les options japonaises.
    private val textRecognizer: TextRecognizer =
        TextRecognition.getClient(JapaneseTextRecognizerOptions.Builder().build())

    override fun stop() {
        super.stop()
        textRecognizer.close()
    }

    override fun detectInImage(image: InputImage): Task<Text> {
        return textRecognizer.process(image)
    }

    override fun onSuccess(results: Text, graphicOverlay: GraphicOverlay) {
        graphicOverlay.add(PollenTextGraphic(graphicOverlay, results))
    }

    override fun onFailure(e: Exception) {
        Log.w(TAG, "La reconnaissance de texte a √©chou√©.$e")
    }

    companion object {
        private const val TAG = "TextRecProcessor"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextRecognitionProcessor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SpecialistReportDialogFragment.kt ---

package be.heyman.android.ai.kikko.pollen

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import com.google.android.material.switchmaterial.SwitchMaterial

class SpecialistReportDialogFragment : DialogFragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.dialog_specialist_report, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val titleTextView: TextView = view.findViewById(R.id.dialog_title)
        val reportTextView: TextView = view.findViewById(R.id.report_content_textview)
        val formatSwitch: SwitchMaterial = view.findViewById(R.id.format_switch)

        val specialistName = requireArguments().getString(ARG_SPECIALIST_NAME)
        val textReport = requireArguments().getString(ARG_TEXT_REPORT)
        val jsonReport = requireArguments().getString(ARG_JSON_REPORT)

        titleTextView.text = "Rapport de l'Abeille : $specialistName"

        // Initial display
        reportTextView.text = textReport
        formatSwitch.text = "Voir en JSON"

        formatSwitch.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                reportTextView.text = jsonReport
                formatSwitch.text = "Voir en Texte"
            } else {
                reportTextView.text = textReport
                formatSwitch.text = "Voir en JSON"
            }
        }
    }

    companion object {
        private const val ARG_SPECIALIST_NAME = "specialist_name"
        private const val ARG_TEXT_REPORT = "text_report"
        private const val ARG_JSON_REPORT = "json_report"

        fun newInstance(specialistName: String, textReport: String, jsonReport: String): SpecialistReportDialogFragment {
            val args = Bundle().apply {
                putString(ARG_SPECIALIST_NAME, specialistName)
                putString(ARG_TEXT_REPORT, textReport)
                putString(ARG_JSON_REPORT, jsonReport)
            }
            val fragment = SpecialistReportDialogFragment()
            fragment.arguments = args
            return fragment
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SpecialistReportDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SubtleObjectGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.objects.DetectedObject

class SubtleObjectGraphic(
    overlay: GraphicOverlay,
    private val detectedObject: DetectedObject
) : GraphicOverlay.Graphic(overlay) {

    private val boxPaint: Paint = Paint().apply {
        color = Color.argb(100, 0, 255, 0)
        style = Paint.Style.FILL
    }

    private val textPaint: Paint = Paint().apply {
        color = Color.WHITE
        textSize = 35.0f
        textAlign = Paint.Align.CENTER
    }

    override fun draw(canvas: Canvas) {
        val rect = RectF(detectedObject.boundingBox)

        // BOURDON'S FIX: Utilisation de overlay.translateX et overlay.translateY
        val mappedRect = RectF(
            overlay.translateX(rect.left),
            overlay.translateY(rect.top),
            overlay.translateX(rect.right),
            overlay.translateY(rect.bottom)
        )
        canvas.drawRect(mappedRect, boxPaint)

        detectedObject.labels.firstOrNull()?.let { label ->
            canvas.drawText(
                label.text,
                mappedRect.centerX(),
                mappedRect.centerY() + 15,
                textPaint
            )
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SubtleObjectGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/YuvToRgbConverter.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.graphics.Bitmap
import android.graphics.ImageFormat
import android.graphics.Rect
import android.media.Image
import android.renderscript.Allocation
import android.renderscript.Element
import android.renderscript.RenderScript
import android.renderscript.ScriptIntrinsicYuvToRGB
import android.renderscript.Type
import java.nio.ByteBuffer

/**
 * Classe utilitaire pour convertir un objet Image au format YUV_420_888 en un bitmap RGB.
 *
 * NOTE : Cette impl√©mentation est une adaptation standard pour g√©rer les conversions d'images
 * de la cam√©ra et est n√©cessaire pour que les mod√®les ML puissent traiter les captures.
 */
class YuvToRgbConverter(context: Context) {
    private val rs = RenderScript.create(context)
    private val scriptYuvToRgb = ScriptIntrinsicYuvToRGB.create(rs, Element.U8_4(rs))

    // Tampon pour les donn√©es YUV, r√©utilis√© pour √©viter des allocations r√©p√©t√©es.
    private var yuvBuffer: ByteBuffer? = null
    private var yuvBufferSize = 0

    // Allocations RenderScript pour l'entr√©e (YUV) et la sortie (Bitmap RGB).
    private var allocationIn: Allocation? = null
    private var allocationOut: Allocation? = null

    @Synchronized
    fun yuvToRgb(image: Image, output: Bitmap) {
        val imageWidth = image.width
        val imageHeight = image.height

        // S'assurer que le tampon YUV est assez grand.
        if (yuvBufferSize < imageWidth * imageHeight * ImageFormat.getBitsPerPixel(ImageFormat.YUV_420_888) / 8) {
            yuvBufferSize = imageWidth * imageHeight * ImageFormat.getBitsPerPixel(ImageFormat.YUV_420_888) / 8
            yuvBuffer = ByteBuffer.allocateDirect(yuvBufferSize)
        }
        yuvBuffer!!.rewind()

        // Copier les donn√©es des 3 plans (Y, U, V) de l'image dans notre tampon.
        imageToByteBuffer(image.planes, yuvBuffer!!)

        // Cr√©er les allocations RenderScript si elles n'existent pas ou si la taille a chang√©.
        if (allocationIn == null) {
            val yuvType = Type.Builder(rs, Element.U8(rs)).setX(yuvBufferSize)
            allocationIn = Allocation.createTyped(rs, yuvType.create(), Allocation.USAGE_SCRIPT)
            val rgbaType = Type.Builder(rs, Element.RGBA_8888(rs)).setX(imageWidth).setY(imageHeight)
            allocationOut = Allocation.createTyped(rs, rgbaType.create(), Allocation.USAGE_SCRIPT)
        }

        // Copier les donn√©es du tampon vers l'allocation d'entr√©e.
        allocationIn!!.copyFrom(yuvBuffer!!.array())

        // Configurer les allocations pour le script de conversion.
        scriptYuvToRgb.setInput(allocationIn)
        scriptYuvToRgb.forEach(allocationOut)

        // Copier le r√©sultat de la conversion dans le bitmap de sortie.
        allocationOut!!.copyTo(output)
    }

    private fun imageToByteBuffer(planes: Array<Image.Plane>, yuvBuffer: ByteBuffer) {
        val yPlane = planes[0]
        val uPlane = planes[1]
        val vPlane = planes[2]

        val yBuffer = yPlane.buffer
        val uBuffer = uPlane.buffer
        val vBuffer = vPlane.buffer
        yBuffer.rewind()
        uBuffer.rewind()
        vBuffer.rewind()

        val ySize = yBuffer.remaining()
        var position = 0

        // Copier le plan Y
        yuvBuffer.put(yBuffer)
        position += ySize

        val vRowStride = vPlane.rowStride
        val uRowStride = uPlane.rowStride
        val vPixelStride = vPlane.pixelStride
        val uPixelStride = uPlane.pixelStride

        // Copier les plans U et V. On g√®re les formats semi-planaires (comme NV21).
        val vuv = ByteArray(vRowStride)
        if (vPixelStride == 2 && uPixelStride == 2 && vRowStride == uRowStride) {
            vBuffer.get(vuv, 0, vBuffer.remaining())
            uBuffer.get(yuvBuffer.array(), position, uBuffer.remaining())
            for (i in 0 until vuv.size / 2) {
                yuvBuffer.array()[position + 2 * i] = vuv[2 * i]
            }
            position += yuvBuffer.remaining()
        } else {
            yuvBuffer.position(position)
            yuvBuffer.put(vBuffer)
            yuvBuffer.position(position + vBuffer.remaining())
            yuvBuffer.put(uBuffer)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/YuvToRgbConverter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/CameraXViewModel.kt ---

package be.heyman.android.ai.kikko.pollen.vision // <-- Nouveau sous-package !

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.core.content.ContextCompat
import java.util.concurrent.ExecutionException

/**
 * Un ViewModel pour g√©rer l'objet ProcessCameraProvider de CameraX de mani√®re s√ªre
 * par rapport au cycle de vie de l'application.
 */
class CameraXViewModel(application: Application) : AndroidViewModel(application) {

    private var cameraProviderLiveData: MutableLiveData<ProcessCameraProvider>? = null

    // Renvoie un LiveData contenant le ProcessCameraProvider.
    val processCameraProvider: LiveData<ProcessCameraProvider>
        get() {
            if (cameraProviderLiveData == null) {
                cameraProviderLiveData = MutableLiveData()
                val cameraProviderFuture = ProcessCameraProvider.getInstance(getApplication())
                cameraProviderFuture.addListener(
                    {
                        try {
                            cameraProviderLiveData!!.setValue(cameraProviderFuture.get())
                        } catch (e: ExecutionException) {
                            // G√©rer l'erreur
                        } catch (e: InterruptedException) {
                            // G√©rer l'erreur
                        }
                    },
                    ContextCompat.getMainExecutor(getApplication())
                )
            }
            return cameraProviderLiveData!!
        }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/CameraXViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/GraphicOverlay.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import android.content.Context
import android.graphics.Canvas
import android.util.AttributeSet
import android.view.View

/**
 * Une vue qui dessine par-dessus l'aper√ßu de la cam√©ra pour afficher les r√©sultats de la vision.
 * BOURDON'S FIX: Cette version est maintenant align√©e sur la logique de la d√©mo ML Kit
 * pour g√©rer correctement l'inversion (miroir) et le redimensionnement.
 */
class GraphicOverlay(context: Context, attrs: AttributeSet?) : View(context, attrs) {

    private val lock = Any()
    private val graphics: MutableList<Graphic> = ArrayList()
    private var imageWidth = 0
    private var imageHeight = 0
    private var isImageFlipped = false

    // Facteurs de transformation calcul√©s pour passer des coordonn√©es de l'image √† la vue.
    private var scaleFactor = 1.0f
    private var postScaleWidthOffset = 0f
    private var postScaleHeightOffset = 0f


    abstract class Graphic(protected val overlay: GraphicOverlay) {
        protected val context: Context = overlay.context
        abstract fun draw(canvas: Canvas)
    }

    fun clear() {
        synchronized(lock) {
            graphics.clear()
        }
        postInvalidate()
    }

    fun add(graphic: Graphic) {
        synchronized(lock) {
            graphics.add(graphic)
        }
    }

    /**
     * D√©finit les informations de la source de l'image pour calculer la transformation.
     * Cette m√©thode est la cl√© pour corriger les probl√®mes d'orientation et de miroir.
     */
    fun setImageSourceInfo(width: Int, height: Int, isFlipped: Boolean) {
        synchronized(lock) {
            imageWidth = width
            imageHeight = height
            isImageFlipped = isFlipped
        }
        postInvalidate()
    }

    fun translateX(x: Float): Float {
        return if (isImageFlipped) {
            width - (x * scaleFactor + postScaleWidthOffset)
        } else {
            x * scaleFactor + postScaleWidthOffset
        }
    }

    fun translateY(y: Float): Float {
        return y * scaleFactor + postScaleHeightOffset
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        synchronized(lock) {
            if (imageWidth != 0 && imageHeight != 0) {
                val viewWidth = width.toFloat()
                val viewHeight = height.toFloat()

                val scaleX = viewWidth / imageWidth
                val scaleY = viewHeight / imageHeight
                scaleFactor = scaleX.coerceAtLeast(scaleY)

                postScaleWidthOffset = (viewWidth - imageWidth * scaleFactor) / 2
                postScaleHeightOffset = (viewHeight - imageHeight * scaleFactor) / 2
            }

            for (graphic in graphics) {
                graphic.draw(canvas)
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/GraphicOverlay.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/PreferenceUtils.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import android.content.Context
import android.preference.PreferenceManager
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions // Corrig√©: Import ajout√©

/**
 * Fonctions utilitaires pour acc√©der aux pr√©f√©rences partag√©es li√©es √† la cam√©ra et √† ML Kit.
 */
object PreferenceUtils {

    fun isClassificationEnabled(context: Context): Boolean {
        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)
        val key = "pref_key_object_detector_enable_classification"
        return sharedPreferences.getBoolean(key, true)
    }

    fun getObjectDetectorOptionsForLivePreview(context: Context): ObjectDetectorOptions {
        return ObjectDetectorOptions.Builder()
            .setDetectorMode(ObjectDetectorOptions.STREAM_MODE)
            .enableClassification()
            .build()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/PreferenceUtils.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/ScopedExecutor.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import java.util.concurrent.Executor
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Un ex√©cuteur qui peut √™tre ferm√©.
 * Lorsque l'ex√©cuteur est ferm√©, les t√¢ches en attente ne seront pas ex√©cut√©es.
 */
class ScopedExecutor(private val executor: Executor) : Executor {
    private val shutdown = AtomicBoolean()

    override fun execute(command: Runnable) {
        // N'ex√©cute la commande que si le garde du corps n'a pas signal√© l'arr√™t.
        if (!shutdown.get()) {
            executor.execute(command)
        }
    }

    /**
     * Signale √† l'ex√©cuteur d'arr√™ter d'accepter de nouvelles t√¢ches.
     */
    fun shutdown() {
        shutdown.set(true)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/ScopedExecutor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/VisionProcessorBase.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import android.content.Context
import android.util.Log
import androidx.camera.core.ExperimentalGetImage
import androidx.camera.core.ImageProxy
import com.google.android.gms.tasks.Task
import com.google.android.gms.tasks.TaskExecutors
import com.google.mlkit.vision.common.InputImage

/**
 * Classe de base simplifi√©e et corrig√©e.
 */
abstract class VisionProcessorBase<T>(val context: Context) {

    private val executor = ScopedExecutor(TaskExecutors.MAIN_THREAD)
    private var isShutdown = false

    @ExperimentalGetImage
    fun processImageProxy(
        imageProxy: ImageProxy,
        graphicOverlay: GraphicOverlay,
        onFinished: () -> Unit // Un simple callback pour dire "j'ai fini"
    ) {
        if (isShutdown) {
            onFinished()
            return
        }

        val mediaImage = imageProxy.image
        if (mediaImage == null) {
            imageProxy.close()
            onFinished()
            return
        }

        val inputImage = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)

        detectInImage(inputImage)
            .addOnSuccessListener(executor) { results: T ->
                this.onSuccess(results, graphicOverlay)
                graphicOverlay.postInvalidate()
            }
            .addOnFailureListener(executor) { e: Exception ->
                this.onFailure(e)
            }
            .addOnCompleteListener {
                onFinished()
            }
    }

    open fun stop() {
        executor.shutdown()
        isShutdown = true
    }

    protected abstract fun detectInImage(image: InputImage): Task<T>

    protected abstract fun onSuccess(results: T, graphicOverlay: GraphicOverlay)

    protected abstract fun onFailure(e: Exception)

    companion object {
        private const val TAG = "VisionProcessorBase"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/VisionProcessorBase.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptEditorActivity.kt ---

package be.heyman.android.ai.kikko.prompt

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.EditText
import android.widget.Spinner
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import be.heyman.android.ai.kikko.R
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import kotlinx.coroutines.launch

class PromptEditorActivity : AppCompatActivity() {

    private val TAG = "PromptEditorActivity"

    private lateinit var toolbar: MaterialToolbar
    private lateinit var promptSpinner: Spinner
    private lateinit var promptEditText: EditText
    private lateinit var saveButton: Button

    // BOURDON'S REFACTOR: La map locale contient maintenant les prompts complets (simples cha√Ænes).
    private var currentPrompts = mutableMapOf<String, String>()
    private var promptKeys = listOf<String>()
    private var lastSelectedSpinnerPosition = -1

    private val importPromptsLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        if (uri != null) {
            lifecycleScope.launch {
                val success = PromptManager.importPrompts(this@PromptEditorActivity, uri)
                if (success) {
                    Toast.makeText(this@PromptEditorActivity, R.string.toast_import_success, Toast.LENGTH_SHORT).show()
                    loadInitialPrompts()
                } else {
                    Toast.makeText(this@PromptEditorActivity, R.string.toast_import_failed, Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_prompt_editor)

        bindViews()
        setupToolbar()
        setupListeners()
        loadInitialPrompts()
    }

    private fun bindViews() {
        toolbar = findViewById(R.id.prompt_editor_toolbar)
        promptSpinner = findViewById(R.id.prompt_selector_spinner)
        promptEditText = findViewById(R.id.prompt_editor_edittext)
        saveButton = findViewById(R.id.prompt_editor_save_button)
    }

    private fun setupToolbar() {
        setSupportActionBar(toolbar)
        toolbar.setNavigationOnClickListener { finish() }
    }

    private fun setupListeners() {
        saveButton.setOnClickListener { saveChanges() }
    }

    private fun loadInitialPrompts() {
        // BOURDON'S REFACTOR: On charge la map simple de prompts.
        currentPrompts = PromptManager.getAllPrompts().toMutableMap()
        promptKeys = currentPrompts.keys.sorted()

        val adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, promptKeys)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        promptSpinner.adapter = adapter

        promptSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                // Sauvegarde les changements du prompt pr√©c√©dent avant de charger le nouveau.
                if (lastSelectedSpinnerPosition != -1 && lastSelectedSpinnerPosition < promptKeys.size) {
                    val previousKey = promptKeys[lastSelectedSpinnerPosition]
                    currentPrompts[previousKey] = promptEditText.text.toString()
                }

                val selectedKey = promptKeys[position]
                promptEditText.setText(currentPrompts[selectedKey])
                lastSelectedSpinnerPosition = position
            }
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }

        if (promptKeys.isNotEmpty()) {
            promptEditText.setText(currentPrompts[promptKeys.first()])
            lastSelectedSpinnerPosition = 0
        }
    }

    private fun saveChanges() {
        // Mettre √† jour la valeur de l'√©diteur dans la map avant de sauvegarder.
        val selectedKey = promptSpinner.selectedItem as? String
        if (selectedKey != null) {
            currentPrompts[selectedKey] = promptEditText.text.toString()
        }

        lifecycleScope.launch {
            PromptManager.savePrompts(this@PromptEditorActivity, currentPrompts)
            Toast.makeText(this@PromptEditorActivity, R.string.toast_prompts_saved, Toast.LENGTH_SHORT).show()
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_import_prompts -> {
                importPromptsLauncher.launch("application/json")
                true
            }
            R.id.action_export_prompts -> {
                exportPrompts()
                true
            }
            R.id.action_reset_prompts -> {
                showResetConfirmationDialog()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    private fun exportPrompts() {
        lifecycleScope.launch {
            val uri = PromptManager.exportPrompts(this@PromptEditorActivity)
            if (uri != null) {
                val shareIntent = Intent().apply {
                    action = Intent.ACTION_SEND
                    putExtra(Intent.EXTRA_STREAM, uri)
                    type = "application/json"
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }
                startActivity(Intent.createChooser(shareIntent, getString(R.string.share_prompts_title)))
            } else {
                Toast.makeText(this@PromptEditorActivity, R.string.toast_export_failed, Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun showResetConfirmationDialog() {
        MaterialAlertDialogBuilder(this)
            .setTitle(R.string.dialog_reset_prompts_title)
            .setMessage(R.string.dialog_reset_prompts_message)
            .setNegativeButton(R.string.dialog_cancel, null)
            .setPositiveButton(R.string.dialog_reset_confirm) { _, _ ->
                lifecycleScope.launch {
                    PromptManager.restoreDefaults(this@PromptEditorActivity)
                    loadInitialPrompts()
                    Toast.makeText(this@PromptEditorActivity, R.string.toast_prompts_restored, Toast.LENGTH_SHORT).show()
                }
            }
            .show()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptEditorActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptManager.kt ---

package be.heyman.android.ai.kikko.prompt

import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.core.content.FileProvider
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStreamReader
import java.util.MissingFormatArgumentException

object PromptManager {

    private const val TAG = "PromptManagerTrace"
    private val promptsCache = mutableMapOf<String, String>()
    private var isInitialized = false

    private fun getDefaultPrompts(): Map<String, String> {
        return mapOf(
            "forge_identification" to """
            ROLE: You are the AI Queen of the Kikko Hive, an expert in multimodal synthesis. Your reasoning must be flawless and strictly follow the evidence provided.
            CONTEXT: You are receiving a JSON **array** of intelligence reports from your Specialist Bees. Each object in the array corresponds to one visual clue (image). The `ocr_results` are the most reliable source of truth when available.
            TASK: **Synthesize ALL reports in the array** to determine a **single, unified subject identity**.
            1.  **Evidence Prioritization (CRITICAL):**
                -   **IF** the `ocr_results.full_text` from any report contains a specific product name or species: This OCR data is your **PRIMARY EVIDENCE**.
                -   **ELSE**: Use the highest-confidence labels from other classifiers across all reports as your PRIMARY EVIDENCE.
            2.  **Final Ruling:** Synthesize all information to determine one final `specificName` and one final `deckName`.
            CRITICAL RULES:
            -   You MUST IGNORE low-confidence labels that contradict the primary evidence.
            -   If the evidence is inconclusive, respond with `{"error": "Inconclusive analysis"}`.
            OUTPUT FORMAT: Your response MUST be a **single, valid JSON object**. Do NOT add any other text or markdown.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` or other characters instead.
            {
              "reasoning": {
                "visualAnalysis": "Your brief analysis synthesizing what is visible across ALL images.",
                "evidenceCorrelation": "Your analysis of the JSON reports, explaining how you combined evidence from all reports to reach a single conclusion."
              },
             "specificName": "The most specific and functional name of the subject.",
             "deckName": "based on the specificName, select the single most appropriate deck name from this short list: [`Bird`, `Insect`, `Plant`, `Food`] ",
              "confidence": 0.95
            }
            --- START OF DATA ---
            [INTELLIGENCE REPORTS]:
            %1${'$'}s
            """.trimIndent(),

            "forge_description" to """
            ROLE: You are a creative and engaging storyteller.
            TASK: Write a descriptive paragraph about "%1${'$'}s - %2${'$'}s". The text must be captivating and easy to read aloud (for Text-to-Speech).
            Crucially, you MUST include:
            1. The origins of the subject.
            2. Exactly four (4) interesting or fun facts seamlessly integrated into the text.
            The entire response must be a single paragraph of plain text, without markdown, lists, or bullet points.
            The response must be in %3${'$'}s.
            """.trimIndent(),

            "forge_stats" to """
            ROLE: You are a meticulous and resourceful Data Extraction AI. You never fail to find a value.
            CONTEXT: You are analyzing "%1${'$'}s". You have two sources of information: raw OCR data which is the primary source of truth, and a general narrative description which is secondary.
            TASK: Your mission is to find the values for the required stats: [%2${'$'}s]. %3${'$'}s
            Follow this strict priority order for your search:
            1.  **PRIORITY 1 (OCR)**: Scrutinize the `[RAW_OCR_DATA]` for precise figures.
            2.  **PRIORITY 2 (NARRATIVE)**: If a stat is not found in the OCR, search for it within the `[NARRATIVE_DESCRIPTION]`.
            3.  **PRIORITY 3 (INFERENCE)**: If a stat is **still not found**, it is **imperative** that you provide a typical **average value** for "%1${'$'}s".
            OUTPUT FORMAT: Your response MUST be a single, valid JSON object. Do not add any other text or markdown.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            Example Output: %4${'$'}s
            --- START OF DATA ---
            [RAW_OCR_DATA]: "%5${'$'}s"
            [NARRATIVE_DESCRIPTION]: "%6${'$'}s"
            """.trimIndent(),

            "forge_quiz" to """
            ROLE: You are a creative but strictly factual Quiz Master AI.
            CONTEXT: You have a `[DESCRIPTION]` and a `[STATS_DATA]` JSON object. This is your ONLY source of truth.
            TASK: Create exactly 4 multiple-choice questions with 4 possible answers each from BOTH the description and the stats data. At least one question must be about a specific numerical value.
            CRITICAL RULE: DO NOT use any external knowledge. All questions and answers must be directly verifiable from the provided context.
            OUTPUT FORMAT: Your response MUST be a single JSON array, with no other explanatory text. The content of the quiz must be in %1${'$'}s.
            Format: `[{"q": "...", "o": ["...", "...", "...", "..."], "c": correct_index, "explanation": "..."}]`
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value (like in "q" or "o"). Use single quotes `'` instead.
            --- START OF DATA ---
            [DESCRIPTION]: "%2${'$'}s"
            [STATS_DATA]: %3${'$'}s
            """.trimIndent(),

            "forge_translation" to """
            ROLE: You are an expert linguist and translator for the Kikko Hive.
            CONTEXT: You have the JSON content of a Knowledge Card.
            TASK: Translate ALL text content within the JSON to %1${'$'}s.
            - Maintain the EXACT JSON structure. Do NOT add or remove fields.
            - Only translate the string values. Do NOT translate field names.
            - Do NOT include any comments or extra text outside the JSON.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            Original JSON content to translate:
            %2${'$'}s
            """.trimIndent(),

            // BOURDON'S CRITICAL FIX: Restauration du format de sortie correct.
            "clash_verdict" to """
            ROLE: You are a versatile AI Judge for the Saga Arena.
            CONTEXT: You must judge a duel based on the `[CLASH_QUESTION]`. You have data for two contestants. Your verdict MUST be based solely on the provided data.
            TASK: You must provide two distinct outputs. Both generated text fields MUST be in the requested `[DEVICE_LANGUAGE]`.
            1.  **Reasoning Field**: Act as a meticulous, logical Judge. Provide a concise, technical justification for your verdict in 1-2 factual sentences.
            2.  **TTS Script Field**: Act as a fun, enthusiastic game show announcer (the Bourdon). Announce the winner and explain the main reason for the victory in simple, exciting terms for a child.
            OUTPUT FORMAT: Your response MUST be a single, valid JSON object and NOTHING ELSE.
            - The `reasoning` key: your concise, factual justification in the `[DEVICE_LANGUAGE]`.
            - The `tts_script` key: your short, exciting announcement in the `[DEVICE_LANGUAGE]`.
            - The `winner` key: CRITICAL. It MUST contain ONLY ONE of these exact three strings: "player1", "player2", or "tie".
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            --- START OF DUEL DATA ---
            [CLASH_QUESTION]: "%1${'$'}s"
            [DEVICE_LANGUAGE]: "%2${'$'}s"
            [CONTESTANT_1_NAME]: "%3${'$'}s"
            [CONTESTANT_1_STATS_JSON]: %4${'$'}s
            [CONTESTANT_2_NAME]: "%5${'$'}s"
            [CONTESTANT_2_STATS_JSON]: %6${'$'}s
            """.trimIndent(),

            "forge_judgment_arbiter" to """
            ROLE: You are the impartial AI Arbiter of the Forge. Your role is to synthesize and judge, not to create new information.
            CONTEXT: A competition was held among several AI Queens to determine the value for the property '%1${'$'}s'. You are provided with a JSON array of their proposals.
            TASK:
            1.  Analyze all proposals in the `[PROPOSALS_JSON]` array.
            2.  Evaluate them based on these criteria: Correct JSON formatting, completeness, and logical consistency.
            3.  Select the SINGLE BEST proposal.
            OUTPUT FORMAT: Your response MUST be a single, valid JSON object and nothing else.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            {
              "arbiterReasoning": "Your brief justification for selecting the winning proposal.",
              "bestProposal": { ... The complete, unmodified JSON object from the `rawResponse` of the winning proposal ... }
            }
            --- START OF EVIDENCE ---
            [PROPOSALS_JSON]:
            %2${'$'}s
            """.trimIndent()
        )
    }

    fun initialize(context: Context) {
        if (isInitialized) return
        synchronized(this) {
            if (isInitialized) return
            promptsCache.clear()
            promptsCache.putAll(getDefaultPrompts())
            Log.i(TAG, "${promptsCache.size} prompts charg√©s en m√©moire depuis la source en dur.")
            isInitialized = true
        }
    }

    fun getPrompt(key: String): String {
        val rawPrompt = promptsCache[key]
        if (rawPrompt == null) {
            Log.e(TAG, "!!! √âCHEC: Cl√© de prompt introuvable: '$key'")
            return "ERREUR: Prompt '$key' non trouv√©."
        }
        return rawPrompt
    }

    fun getAllPrompts(): Map<String, String> = promptsCache.toMap()

    suspend fun savePrompts(context: Context, updatedPrompts: Map<String, String>) {
        Log.w(TAG, "La sauvegarde des prompts est d√©sactiv√©e dans cette version de d√©bogage.")
    }

    suspend fun restoreDefaults(context: Context) {
        synchronized(this) {
            promptsCache.clear()
            promptsCache.putAll(getDefaultPrompts())
        }
        Log.i(TAG, "Prompts restaur√©s aux valeurs par d√©faut en m√©moire.")
    }

    suspend fun exportPrompts(context: Context): Uri? {
        Log.w(TAG, "L'export des prompts est d√©sactiv√© dans cette version de d√©bogage.")
        return null
    }

    suspend fun importPrompts(context: Context, uri: Uri): Boolean {
        Log.w(TAG, "L'import des prompts est d√©sactiv√© dans cette version de d√©bogage.")
        return false
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptManager.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/quizz/QuizActivity.kt ---

package be.heyman.android.ai.kikko.quiz

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.View
import android.widget.Button
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.QuizQuestion
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.card.MaterialCardView

class QuizActivity : AppCompatActivity() {

    private lateinit var toolbar: MaterialToolbar
    private lateinit var progressTextView: TextView
    private lateinit var questionTextView: TextView
    private lateinit var answersRadioGroup: RadioGroup
    private lateinit var answerRadioButtons: List<RadioButton>
    private lateinit var submitButton: Button
    private lateinit var nextButton: Button
    private lateinit var feedbackCard: MaterialCardView
    private lateinit var feedbackTextView: TextView

    private var quizQuestions: List<QuizQuestion> = emptyList()
    private var currentQuestionIndex = 0
    private var score = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_quiz)

        // BOURDON'S REFACTOR: Use of a dedicated 'card' variable for clarity.
        val card: KnowledgeCard? = intent.getParcelableExtra(EXTRA_CARD)
        quizQuestions = card?.quiz ?: emptyList()

        if (quizQuestions.isEmpty()) {
            Toast.makeText(this, "Erreur: Aucune question de quiz trouv√©e.", Toast.LENGTH_SHORT).show()
            finish()
            return
        }

        bindViews()
        setupToolbar(card?.specificName ?: "Quiz")
        setupListeners()
        displayQuestion()
    }

    private fun bindViews() {
        toolbar = findViewById(R.id.quiz_toolbar)
        progressTextView = findViewById(R.id.quiz_progress_textview)
        questionTextView = findViewById(R.id.quiz_question_textview)
        answersRadioGroup = findViewById(R.id.quiz_answers_radiogroup)
        answerRadioButtons = listOf(
            findViewById(R.id.quiz_answer_1),
            findViewById(R.id.quiz_answer_2),
            findViewById(R.id.quiz_answer_3),
            findViewById(R.id.quiz_answer_4)
        )
        submitButton = findViewById(R.id.quiz_submit_button)
        nextButton = findViewById(R.id.quiz_next_button)
        feedbackCard = findViewById(R.id.quiz_feedback_card)
        feedbackTextView = findViewById(R.id.quiz_feedback_textview)
    }

    private fun setupToolbar(cardName: String) {
        toolbar.title = "Quiz : $cardName"
        toolbar.setNavigationOnClickListener { finish() }
    }

    private fun setupListeners() {
        submitButton.setOnClickListener {
            val selectedAnswerId = answersRadioGroup.checkedRadioButtonId
            if (selectedAnswerId != -1) {
                val selectedRadioButton = findViewById<RadioButton>(selectedAnswerId)
                val selectedIndex = answerRadioButtons.indexOf(selectedRadioButton)
                checkAnswer(selectedIndex)
            } else {
                Toast.makeText(this, "Veuillez s√©lectionner une r√©ponse.", Toast.LENGTH_SHORT).show()
            }
        }

        nextButton.setOnClickListener {
            currentQuestionIndex++
            if (currentQuestionIndex < quizQuestions.size) {
                displayQuestion()
            } else {
                showFinalScore()
            }
        }
    }

    private fun displayQuestion() {
        resetQuestionState()
        val question = quizQuestions[currentQuestionIndex]
        progressTextView.text = "Question ${currentQuestionIndex + 1} / ${quizQuestions.size}"
        questionTextView.text = question.question
        question.options.forEachIndexed { index, optionText ->
            if(index < answerRadioButtons.size) {
                answerRadioButtons[index].text = optionText
                answerRadioButtons[index].visibility = View.VISIBLE
            }
        }
    }

    private fun checkAnswer(selectedIndex: Int) {
        val question = quizQuestions[currentQuestionIndex]
        val isCorrect = selectedIndex == question.correctAnswerIndex

        if (isCorrect) {
            score++
            feedbackTextView.text = "Bonne r√©ponse !"
            feedbackCard.setCardBackgroundColor(ContextCompat.getColor(this, R.color.kikko_success_green))
        } else {
            val correctAnswer = question.options[question.correctAnswerIndex]
            feedbackTextView.text = "Incorrect. La bonne r√©ponse √©tait : \n\"$correctAnswer\""
            feedbackCard.setCardBackgroundColor(ContextCompat.getColor(this, R.color.kikko_error_red))
        }

        feedbackTextView.setTextColor(ContextCompat.getColor(this, R.color.kikko_bark_brown))
        feedbackCard.visibility = View.VISIBLE

        toggleAnswerInteractivity(false)
        submitButton.visibility = View.GONE
        nextButton.visibility = View.VISIBLE
    }

    private fun showFinalScore() {
        val title = "Quiz Termin√© !"
        val message = "Votre score : $score / ${quizQuestions.size}"
        // For simplicity, we use an AlertDialog for the final score.
        // A dedicated results screen could be created for a more polished UX.
        android.app.AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton("Terminer") { _, _ -> finish() }
            .setCancelable(false)
            .show()
    }

    private fun resetQuestionState() {
        answersRadioGroup.clearCheck()
        feedbackCard.visibility = View.GONE
        submitButton.visibility = View.VISIBLE
        nextButton.visibility = View.GONE
        toggleAnswerInteractivity(true)
    }

    private fun toggleAnswerInteractivity(isEnabled: Boolean) {
        for (radioButton in answerRadioButtons) {
            radioButton.isEnabled = isEnabled
        }
    }

    companion object {
        private const val EXTRA_CARD = "EXTRA_CARD"

        fun newIntent(context: Context, card: KnowledgeCard): Intent {
            return Intent(context, QuizActivity::class.java).apply {
                putExtra(EXTRA_CARD, card)
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/quizz/QuizActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/AudienceSettingsDialogFragment.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.content.Context
import android.os.Bundle
import android.os.Parcelable
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import com.google.android.material.slider.Slider
import kotlinx.parcelize.Parcelize
import java.util.Locale

@Parcelize
data class AudienceSettings(val temperature: Float, val topK: Int) : Parcelable

class AudienceSettingsDialogFragment : DialogFragment() {

    interface AudienceSettingsListener {
        fun onSettingsConfirmed(settings: AudienceSettings)
    }

    private var listener: AudienceSettingsListener? = null
    private lateinit var currentSettings: AudienceSettings

    private lateinit var temperatureLabel: TextView
    private lateinit var temperatureSlider: Slider
    private lateinit var topKLabel: TextView
    private lateinit var topKSlider: Slider
    private lateinit var confirmButton: Button

    override fun onAttach(context: Context) {
        super.onAttach(context)
        // L'activit√© parente doit impl√©menter cette interface pour recevoir les r√©sultats.
        listener = context as? AudienceSettingsListener
            ?: throw ClassCastException("$context must implement AudienceSettingsListener")
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            @Suppress("DEPRECATION")
            currentSettings = it.getParcelable(ARG_SETTINGS) ?: AudienceSettings(0.2f, 40)
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_audience_settings, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        bindViews(view)
        setupViews()
        setupListeners()
    }

    private fun bindViews(view: View) {
        temperatureLabel = view.findViewById(R.id.audience_settings_temperature_label)
        temperatureSlider = view.findViewById(R.id.audience_settings_temperature_slider)
        topKLabel = view.findViewById(R.id.audience_settings_topk_label)
        topKSlider = view.findViewById(R.id.audience_settings_topk_slider)
        confirmButton = view.findViewById(R.id.audience_settings_confirm_button)
    }

    private fun setupViews() {
        dialog?.setTitle("D√©crets de la Reine")

        temperatureSlider.value = currentSettings.temperature
        topKSlider.value = currentSettings.topK.toFloat()

        updateTemperatureLabel(currentSettings.temperature)
        updateTopKLabel(currentSettings.topK.toFloat())
    }

    private fun setupListeners() {
        temperatureSlider.addOnChangeListener { _, value, _ ->
            updateTemperatureLabel(value)
        }
        topKSlider.addOnChangeListener { _, value, _ ->
            updateTopKLabel(value)
        }
        confirmButton.setOnClickListener {
            val newSettings = AudienceSettings(
                temperature = temperatureSlider.value,
                topK = topKSlider.value.toInt()
            )
            listener?.onSettingsConfirmed(newSettings)
            dismiss()
        }
    }

    private fun updateTemperatureLabel(value: Float) {
        temperatureLabel.text = String.format(Locale.US, "Temp√©rament (Cr√©ativit√© : %.2f)", value)
    }

    private fun updateTopKLabel(value: Float) {
        topKLabel.text = "Focalisation (Top-K : ${value.toInt()})"
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        const val TAG = "AudienceSettingsDialog"
        private const val ARG_SETTINGS = "current_settings"

        fun newInstance(currentSettings: AudienceSettings): AudienceSettingsDialogFragment {
            val args = Bundle().apply {
                putParcelable(ARG_SETTINGS, currentSettings)
            }
            return AudienceSettingsDialogFragment().apply {
                arguments = args
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/AudienceSettingsDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/QueenSelectorDialogFragment.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.QueenModelAdapter
import be.heyman.android.ai.kikko.R
import java.io.File

class QueenSelectorDialogFragment : DialogFragment() {

    interface QueenSelectorListener {
        fun onQueenSelected(modelName: String)
    }

    private var listener: QueenSelectorListener? = null
    private lateinit var queenSelectorAdapter: QueenModelAdapter

    private lateinit var availableModels: List<File>
    private var selectedModelName: String? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = context as? QueenSelectorListener
            ?: throw ClassCastException("$context must implement QueenSelectorListener")
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            @Suppress("DEPRECATION")
            val modelPaths = it.getStringArrayList(ARG_MODELS) ?: emptyList<String>()
            availableModels = modelPaths.map { path -> File(path) }
            selectedModelName = it.getString(ARG_SELECTED_MODEL)
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_queen_selector, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle("Choisir la Reine")

        val recyclerView: RecyclerView = view.findViewById(R.id.queen_selector_recyclerview)
        val emptyState: TextView = view.findViewById(R.id.queen_selector_empty_state)

        if (availableModels.isEmpty()) {
            recyclerView.visibility = View.GONE
            emptyState.visibility = View.VISIBLE
        } else {
            recyclerView.visibility = View.VISIBLE
            emptyState.visibility = View.GONE

            queenSelectorAdapter = QueenModelAdapter(
                models = availableModels,
                selectedModelName = selectedModelName
            ) { selectedFile ->
                listener?.onQueenSelected(selectedFile.name)
                dismiss()
            }
            recyclerView.layoutManager = LinearLayoutManager(context)
            recyclerView.adapter = queenSelectorAdapter
        }
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        const val TAG = "QueenSelectorDialog"
        private const val ARG_MODELS = "available_models"
        private const val ARG_SELECTED_MODEL = "selected_model"

        fun newInstance(availableModels: List<File>, selectedModelName: String?): QueenSelectorDialogFragment {
            val args = Bundle().apply {
                putStringArrayList(ARG_MODELS, ArrayList(availableModels.map { it.absolutePath }))
                putString(ARG_SELECTED_MODEL, selectedModelName)
            }
            return QueenSelectorDialogFragment().apply {
                arguments = args
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/QueenSelectorDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceActivity.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.core.content.ContextCompat
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePadding
import androidx.core.widget.addTextChangedListener
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.lifecycle.SavedStateViewModelFactory
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.SttVoskService
import be.heyman.android.ai.kikko.TtsService
import be.heyman.android.ai.kikko.VoskStatus
import com.bumptech.glide.Glide
import com.google.android.material.appbar.AppBarLayout
import kotlinx.coroutines.launch
import java.io.File

class RoyalAudienceActivity : AppCompatActivity(),
    AudienceSettingsDialogFragment.AudienceSettingsListener,
    QueenSelectorDialogFragment.QueenSelectorListener {

    private val viewModel: RoyalAudienceViewModel by lazy {
        Log.d(TAG, "üëë Audience Royale: J'utilise le bon Ma√Ætre des Cl√©s (SavedStateViewModelFactory) pour pr√©senter nos respects √† la Reine. Elle a besoin de son registre personnel (SavedStateHandle) !")
        ViewModelProvider(this, SavedStateViewModelFactory(application, this))
            .get(RoyalAudienceViewModel::class.java)
    }
    private lateinit var audienceAdapter: RoyalAudienceAdapter

    private lateinit var rootContainer: View
    private lateinit var recyclerView: RecyclerView
    private lateinit var inputBar: View
    private lateinit var inputEditText: EditText
    private lateinit var sendButton: ImageButton
    private lateinit var micButton: ImageButton
    private lateinit var attachButton: ImageButton
    private lateinit var settingsButton: ImageButton
    private lateinit var modelSelectorContainer: View
    private lateinit var modelNameTextView: TextView
    private lateinit var toolbar: Toolbar
    private lateinit var backButton: ImageButton

    private lateinit var imagePreviewContainer: FrameLayout
    private lateinit var previewImageView: ImageView
    private lateinit var removePreviewButton: ImageButton

    private lateinit var backgroundPlayerView: PlayerView
    private var exoPlayer: ExoPlayer? = null

    private var currentTranscription = ""
    private var selectedImageUri: Uri? = null

    private val requestPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
        if (isGranted) {
            startListening()
        } else {
            Toast.makeText(this, R.string.mic_permission_denied, Toast.LENGTH_SHORT).show()
        }
    }

    private val pickImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            selectedImageUri = it
            showImagePreview()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        WindowCompat.setDecorFitsSystemWindows(window, false)

        setContentView(R.layout.activity_royal_audience)
        Log.i(TAG, "üèõÔ∏è Entr√©e dans la salle d'audience de la Reine.")

        TtsService.initialize(this)

        bindViews()
        setupWindowInsets()
        setupRecyclerView()
        setupListeners()
        observeViewModel()
        observeVoskService()
        ensureVoskModelIsLoaded()

        updateSendButtonState()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
    }

    override fun onStop() {
        super.onStop()
        releasePlayer()
    }

    private fun bindViews() {
        rootContainer = findViewById(R.id.audience_root_container)
        recyclerView = findViewById(R.id.audience_recyclerview)
        backgroundPlayerView = findViewById(R.id.audience_background_video_view)

        inputBar = findViewById<View>(R.id.audience_input_bar)
        inputEditText = inputBar.findViewById(R.id.chat_input_edittext)
        sendButton = inputBar.findViewById(R.id.chat_send_button)
        micButton = inputBar.findViewById(R.id.chat_mic_button)
        attachButton = inputBar.findViewById(R.id.chat_attach_button)

        toolbar = findViewById(R.id.audience_toolbar)
        backButton = findViewById(R.id.audience_back_button)
        settingsButton = findViewById(R.id.audience_settings_button)
        modelSelectorContainer = findViewById(R.id.audience_model_selector_container)
        modelNameTextView = findViewById(R.id.audience_model_name)

        imagePreviewContainer = findViewById(R.id.audience_image_preview_container)

        Log.d(TAG, "üñºÔ∏è Vues de l'interface li√©es.")
    }

    private fun setupWindowInsets() {
        ViewCompat.setOnApplyWindowInsetsListener(rootContainer) { view, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            val imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())

            view.updatePadding(
                left = systemBars.left,
                top = systemBars.top,
                right = systemBars.right,
                bottom = systemBars.bottom
            )

            inputBar.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                bottomMargin = imeInsets.bottom
            }

            recyclerView.updatePadding(bottom = imeInsets.bottom + systemBars.bottom)

            insets
        }
    }

    private fun initializePlayer() {
        Log.d(TAG, "üé• Initialisation du fond vid√©o pour l'ambiance royale.")
        exoPlayer = ExoPlayer.Builder(this).build().also { player ->
            backgroundPlayerView.player = player
            val videoUri = Uri.parse("android.resource://$packageName/${R.raw.audience}")
            val mediaItem = MediaItem.fromUri(videoUri)
            player.setMediaItem(mediaItem)
            player.repeatMode = Player.REPEAT_MODE_ONE
            player.volume = 0f
            player.playWhenReady = true
            player.prepare()
        }
    }

    private fun releasePlayer() {
        Log.d(TAG, "üé¨ Lib√©ration des ressources vid√©o.")
        exoPlayer?.release()
        exoPlayer = null
    }

    private fun setupRecyclerView() {
        audienceAdapter = RoyalAudienceAdapter()
        recyclerView.apply {
            adapter = audienceAdapter
            layoutManager = LinearLayoutManager(this@RoyalAudienceActivity).apply {
                stackFromEnd = true
            }
        }
        Log.d(TAG, "üìú Parchemin de conversation d√©roul√© et pr√™t.")
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupListeners() {
        backButton.setOnClickListener { finish() }

        sendButton.setOnClickListener {
            val userInput = inputEditText.text.toString()
            viewModel.sendMessage(userInput, selectedImageUri)
            inputEditText.text.clear()
            clearImagePreview()
        }

        inputEditText.addTextChangedListener {
            updateSendButtonState()
        }

        micButton.setOnClickListener {
            if (SttVoskService.voskResult.value?.status != VoskStatus.LISTENING) {
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {
                    startListening()
                } else {
                    requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                }
            }
        }

        attachButton.setOnClickListener {
            pickImageLauncher.launch("image/*")
        }

        settingsButton.setOnClickListener {
            val currentSettings = viewModel.uiState.value.audienceSettings
            AudienceSettingsDialogFragment.newInstance(currentSettings)
                .show(supportFragmentManager, AudienceSettingsDialogFragment.TAG)
        }
        modelSelectorContainer.setOnClickListener {
            val availableModels = viewModel.uiState.value.availableModels
            val selectedModel = viewModel.uiState.value.selectedModelName
            QueenSelectorDialogFragment.newInstance(availableModels, selectedModel)
                .show(supportFragmentManager, QueenSelectorDialogFragment.TAG)
        }
    }

    private fun startListening() {
        Log.i(TAG, "üé§ D√©marrage de l'√©coute. Le Butineur s'adresse √† la Reine de vive voix.")
        if (!SttVoskService.isModelLoaded()) {
            Toast.makeText(this, R.string.audience_no_voice_model, Toast.LENGTH_LONG).show()
            return
        }
        currentTranscription = inputEditText.text.toString()
        if (currentTranscription.isNotBlank() && !currentTranscription.endsWith(" ")) {
            currentTranscription += " "
        }
        SttVoskService.startListening()
    }

    private fun updateMicButtonState(isListening: Boolean) {
        if (isListening) {
            micButton.setImageResource(R.drawable.ic_stop)
        } else {
            micButton.setImageResource(android.R.drawable.ic_btn_speak_now)
        }
        micButton.isEnabled = !viewModel.uiState.value.isLoading
    }

    private fun updateSendButtonState() {
        val hasText = inputEditText.text.isNotBlank()
        val hasImage = selectedImageUri != null
        val shouldShowSend = hasText || hasImage

        if (shouldShowSend) {
            if (SttVoskService.voskResult.value?.status == VoskStatus.LISTENING) {
                SttVoskService.stopListening()
            }
            sendButton.visibility = View.VISIBLE
            micButton.visibility = View.GONE
        } else {
            sendButton.visibility = View.GONE
            micButton.visibility = View.VISIBLE
        }
    }

    private fun showImagePreview() {
        if (imagePreviewContainer.childCount == 0) {
            layoutInflater.inflate(R.layout.layout_chat_image_preview, imagePreviewContainer, true)
            previewImageView = imagePreviewContainer.findViewById(R.id.preview_image_view)
            removePreviewButton = imagePreviewContainer.findViewById(R.id.remove_preview_button)
            removePreviewButton.setOnClickListener { clearImagePreview() }
        }
        imagePreviewContainer.visibility = View.VISIBLE
        Glide.with(this)
            .load(selectedImageUri)
            .into(previewImageView)
        updateSendButtonState()
    }

    private fun clearImagePreview() {
        selectedImageUri = null
        imagePreviewContainer.visibility = View.GONE
        updateSendButtonState()
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    viewModel.uiState.collect { state ->
                        audienceAdapter.submitList(state.messages)
                        modelNameTextView.text = state.selectedModelName ?: getString(R.string.audience_no_queen_available_short)

                        if (state.messages.isNotEmpty()) {
                            recyclerView.post { recyclerView.scrollToPosition(state.messages.size - 1) }
                        }

                        val isUserInputEnabled = !state.isLoading
                        inputEditText.isEnabled = isUserInputEnabled
                        attachButton.isEnabled = isUserInputEnabled
                        micButton.isEnabled = isUserInputEnabled
                    }
                }
                launch {
                    viewModel.toastEvent.collect { message ->
                        Toast.makeText(this@RoyalAudienceActivity, message, Toast.LENGTH_SHORT).show()
                    }
                }
            }
        }
        Log.d(TAG, "üëÄ Observation de l'√©tat de l'audience (ViewModel) activ√©e.")
    }

    private fun observeVoskService() {
        SttVoskService.voskResult.observe(this) { result ->
            val isCurrentlyListening = result.status == VoskStatus.LISTENING
            updateMicButtonState(isCurrentlyListening)

            if (isCurrentlyListening) {
                val fullText = currentTranscription + result.text
                inputEditText.setText(fullText)
                inputEditText.setSelection(fullText.length)
            } else {
                if(result.status == VoskStatus.FINAL_RESULT) {
                    val fullText = (currentTranscription + result.text).trim()
                    Log.i(TAG, "üé§ Transcription finale re√ßue : '$fullText'")
                    inputEditText.setText(fullText)
                    inputEditText.setSelection(fullText.length)
                }
            }
        }
    }

    private fun ensureVoskModelIsLoaded() {
        if (SttVoskService.isModelLoaded()) return

        val baseModelDir = File(filesDir, "vosk-models")
        if (baseModelDir.exists() && baseModelDir.isDirectory) {
            val modelDirs = baseModelDir.listFiles { file -> file.isDirectory }
            if (!modelDirs.isNullOrEmpty()) {
                val defaultModelDir = modelDirs.first()
                val dummyModel = Model(name = defaultModelDir.name, downloadFileName = "", url = "", sizeInBytes = 0)
                Log.d(TAG, "üß† Chargement du mod√®le vocal par d√©faut : '${defaultModelDir.name}'")
                SttVoskService.loadModel(dummyModel, baseModelDir) { success ->
                    if (success) {
                        runOnUiThread {
                            Toast.makeText(this, getString(R.string.audience_default_voice_model_loaded, defaultModelDir.name), Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            } else {
                Toast.makeText(this, R.string.audience_no_voice_model, Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "‚è∏Ô∏è Audience mise en pause.")
        SttVoskService.stopListening()
        TtsService.stopAndClearQueue()
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "üí• L'audience est termin√©e. Lib√©ration des ressources.")
        SttVoskService.reset()
        TtsService.shutdown()
    }

    override fun onSettingsConfirmed(settings: AudienceSettings) {
        viewModel.updateAudienceSettings(settings)
    }

    override fun onQueenSelected(modelName: String) {
        viewModel.updateSelectedQueen(modelName)
    }

    companion object {
        private const val TAG = "RoyalAudienceActivity"
        const val CARD_ID_KEY = "cardId"
        fun newIntent(context: Context, cardId: Long = -1L): Intent {
            return Intent(context, RoyalAudienceActivity::class.java).apply {
                putExtra(CARD_ID_KEY, cardId)
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceAdapter.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.graphics.BitmapFactory
import android.net.Uri
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import com.bumptech.glide.Glide
import java.io.File

/**
 * BOURDON'S REFORGE V2:
 * La data class est maintenant encore plus flexible pour inclure une image dans les messages.
 */
data class ChatMessage(
    val text: String? = null,
    val card: KnowledgeCard? = null,
    val imageUri: String? = null, // NOUVEAU: URI de l'image jointe par l'utilisateur
    val isFromUser: Boolean,
    var isStreaming: Boolean = false
)

class RoyalAudienceAdapter : RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    companion object {
        private const val VIEW_TYPE_USER = 1
        private const val VIEW_TYPE_QUEEN = 2
        private const val VIEW_TYPE_CARD_CONTEXT = 3
        private const val VIEW_TYPE_USER_WITH_IMAGE = 4 // NOUVEAU: Type de vue pour les messages avec image
    }

    private val messages: MutableList<ChatMessage> = mutableListOf()

    // --- ViewHolders pour chaque type de message ---

    inner class UserMessageViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val messageTextView: TextView = view.findViewById(R.id.chat_user_message_textview)
    }

    inner class QueenMessageViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val messageTextView: TextView = view.findViewById(R.id.chat_queen_message_textview)
    }

    inner class CardContextViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val cardImageView: ImageView = view.findViewById(R.id.chat_card_image)
        val cardNameTextView: TextView = view.findViewById(R.id.chat_card_name)
        val cardDescriptionTextView: TextView = view.findViewById(R.id.chat_card_description)

        fun bind(card: KnowledgeCard) {
            cardNameTextView.text = card.specificName
            cardDescriptionTextView.text = card.description ?: "Aucune description disponible."

            card.imagePath?.let { path ->
                val imgFile = File(path)
                if (imgFile.exists()) {
                    val bitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                    cardImageView.setImageBitmap(bitmap)
                }
            }
        }
    }

    // NOUVEAU: ViewHolder pour les messages utilisateur avec image
    inner class UserMessageWithImageViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        private val messageTextView: TextView = view.findViewById(R.id.chat_user_message_textview)
        private val imageView: ImageView = view.findViewById(R.id.chat_user_imageview)

        fun bind(message: ChatMessage) {
            // Le texte est optionnel si une image est pr√©sente
            if (message.text.isNullOrBlank()) {
                messageTextView.visibility = View.GONE
            } else {
                messageTextView.visibility = View.VISIBLE
                messageTextView.text = message.text
            }

            // L'image est charg√©e via Glide pour plus d'efficacit√©
            message.imageUri?.let {
                Glide.with(itemView.context)
                    .load(Uri.parse(it))
                    .into(imageView)
            }
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = messages[position]
        return when {
            message.card != null -> VIEW_TYPE_CARD_CONTEXT
            message.isFromUser && !message.imageUri.isNullOrEmpty() -> VIEW_TYPE_USER_WITH_IMAGE
            message.isFromUser -> VIEW_TYPE_USER
            else -> VIEW_TYPE_QUEEN
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            VIEW_TYPE_USER -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_user, parent, false)
                UserMessageViewHolder(view)
            }
            VIEW_TYPE_QUEEN -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_queen, parent, false)
                QueenMessageViewHolder(view)
            }
            VIEW_TYPE_CARD_CONTEXT -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_card_context, parent, false)
                CardContextViewHolder(view)
            }
            VIEW_TYPE_USER_WITH_IMAGE -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_user_with_image, parent, false)
                UserMessageWithImageViewHolder(view)
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
    }

    override fun getItemCount(): Int = messages.size

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        val message = messages[position]
        when (holder.itemViewType) {
            VIEW_TYPE_USER -> (holder as UserMessageViewHolder).messageTextView.text = message.text
            VIEW_TYPE_QUEEN -> (holder as QueenMessageViewHolder).messageTextView.text = message.text
            VIEW_TYPE_CARD_CONTEXT -> message.card?.let { (holder as CardContextViewHolder).bind(it) }
            VIEW_TYPE_USER_WITH_IMAGE -> (holder as UserMessageWithImageViewHolder).bind(message)
        }
    }

    fun submitList(newMessages: List<ChatMessage>) {
        messages.clear()
        messages.addAll(newMessages)
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceViewModel.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---
package be.heyman.android.ai.kikko.forge

import android.app.Application
import android.content.Context
import android.graphics.BitmapFactory
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.concurrent.CancellationException
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

data class CompetitionSummaryItem(
    val response: String,
    val voteCount: Int,
    val firstValidTask: AnalysisResult
)

data class CompetitionSummary(
    val propertyName: String,
    val items: List<CompetitionSummaryItem>
)

sealed class JudgmentState {
    data object None : JudgmentState()
    data class InProgress(val propertyName: String, val prompt: String, val streamingResponse: String = "") : JudgmentState()
    data class Complete(val propertyName: String, val arbiterReasoning: String, val winningProposal: AnalysisResult) : JudgmentState()
    data class Failed(val propertyName: String, val error: String) : JudgmentState()
}

data class ForgeWorkshopUiState(
    val isLoading: Boolean = true,
    val workshopGrains: List<PollenGrain> = emptyList(),
    val selectedGrain: PollenGrain? = null,
    val selectedCard: KnowledgeCard? = null,
    val analysisResults: Map<String, List<AnalysisResult>> = emptyMap(),
    val competitionSummaries: Map<String, CompetitionSummary> = emptyMap(),
    val judgmentState: JudgmentState = JudgmentState.None,
    val statusMessage: String? = null,
    val activeFilter: String = ForgeWorkshopViewModel.FILTER_RAW
)

class ForgeWorkshopViewModel(application: Application) : AndroidViewModel(application) {

    private val forgeRepository: ForgeRepository = (application as KikkoApplication).forgeRepository
    private val llmHelper: ForgeLlmHelper = (application as KikkoApplication).forgeLlmHelper
    private val pollenGrainDao: PollenGrainDao = (application as KikkoApplication).pollenGrainDao

    private val TAG = "KikkoForgeTrace"
    private val _uiState = MutableStateFlow(ForgeWorkshopUiState())
    val uiState = _uiState.asStateFlow()
    private val gson = Gson()

    private var competitionJob: Job? = null
    private var judgmentJob: Job? = null

    private var allWorkshopItems = listOf<Pair<PollenGrain, KnowledgeCard?>>()

    private val deckProperties = mapOf(
        "Food" to listOf("description", "ingredients", "allergens", "stats.energy"),
        "Plant" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.floweringPeriod"),
        "Insect" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.diet"),
        "Bird" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.wingspan")
    )

    private data class IdentificationResultData(
        val reasoning: Reasoning,
        val deckName: String,
        val specificName: String,
        val confidence: Float
    )

    companion object {
        const val FILTER_ALL = "ALL"
        const val FILTER_RAW = "RAW"
    }

    init {
        Log.d(TAG, "ViewModel initialis√©. Lancement du chargement initial des grains de pollen.")
        viewModelScope.launch {
            _uiState.update { it.copy(statusMessage = getString(R.string.workshop_loading_grains)) }
            loadWorkshopGrains()
        }
    }

    fun getPropertiesForDeck(deckName: String?): List<String> {
        val normalizedDeckName = deckName
            ?.trim()
            ?.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
            ?.removeSuffix("s")
        return deckProperties[normalizedDeckName] ?: emptyList()
    }


    fun selectGrain(grain: PollenGrain) {
        viewModelScope.launch {
            competitionJob?.cancel()
            judgmentJob?.cancel()
            Log.i(TAG, "[SELECT] S√©lection du grain ID: ${grain.id} | Statut: ${grain.status} | CardID li√©: ${grain.forgedCardId}")

            val card = allWorkshopItems.find { it.first.id == grain.id }?.second
            val newStatusMessage = if (grain.status == PollenStatus.AWAITING_VALIDATION || grain.status == PollenStatus.IDENTIFYING) {
                getString(R.string.workshop_awaiting_validation)
            } else {
                getString(R.string.workshop_ready_to_refine)
            }

            _uiState.update { it.copy(
                selectedGrain = grain,
                selectedCard = card,
                analysisResults = emptyMap(),
                competitionSummaries = emptyMap(),
                judgmentState = JudgmentState.None,
                statusMessage = newStatusMessage
            ) }

            if (card != null) {
                Log.d(TAG, "[SELECT] Carte charg√©e depuis la cache - ID: ${card.id}, Nom: '${card.specificName}', Deck: '${card.deckName}'")
            } else {
                Log.w(TAG, "[SELECT] Aucune carte n'a pu √™tre charg√©e pour ce grain.")
            }

            refreshAnalysisResults(grain.id, "identification")
            card?.deckName?.takeIf { it != "Unknown" }?.let { deckName ->
                getPropertiesForDeck(deckName).forEach { propertyName ->
                    refreshAnalysisResults(grain.id, propertyName)
                }
            }
        }
    }

    fun setFilter(filterType: String) {
        viewModelScope.launch {
            if (_uiState.value.activeFilter == filterType) return@launch
            _uiState.update { it.copy(activeFilter = filterType) }
            updateFilteredGrains()
        }
    }

    private fun updateFilteredGrains() {
        val currentFilter = _uiState.value.activeFilter
        val filteredItems = when (currentFilter) {
            FILTER_RAW -> allWorkshopItems.filter { (grain, _) ->
                grain.status in listOf(PollenStatus.RAW, PollenStatus.IDENTIFYING, PollenStatus.AWAITING_VALIDATION, PollenStatus.ERROR)
            }
            else -> allWorkshopItems.filter { (_, card) -> card?.deckName == currentFilter }
        }

        val filteredGrains = filteredItems.map { it.first }
        _uiState.update { it.copy(workshopGrains = filteredGrains) }

        if (filteredGrains.none { it.id == _uiState.value.selectedGrain?.id }) {
            filteredGrains.firstOrNull()?.let { selectGrain(it) } ?: _uiState.update {
                it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_in_deck))
            }
        }
    }

    fun createAnalysisTournament(propertyName: String) {
        viewModelScope.launch {
            val grain = _uiState.value.selectedGrain ?: return@launch
            _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_preparing_competition, propertyName)) }

            val modelsToCompete = withContext(Dispatchers.IO) {
                File(getApplication<Application>().filesDir, "imported_models")
                    .listFiles { _, name -> name.endsWith(".task") }?.map { it.name } ?: emptyList()
            }

            if (modelsToCompete.isEmpty()) {
                _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_no_queens_installed)) }
                return@launch
            }
            Log.i(TAG, "[COMPETITION] Reines en comp√©tition: ${modelsToCompete.joinToString()}")

            val accelerator = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                .getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU") ?: "GPU"

            val tasks = forgeRepository.createAnalysisTasksForProperty(grain.id, propertyName, modelsToCompete, accelerator)
            refreshAnalysisResults(grain.id, propertyName)

            val message = getApplication<Application>().resources.getQuantityString(R.plurals.workshop_tasks_ready, tasks.size, tasks.size)
            _uiState.update { it.copy(isLoading = false, statusMessage = message) }

            launchCompetitionExecution(propertyName)
        }
    }

    fun relaunchAnalysisTournament(propertyName: String) {
        viewModelScope.launch {
            val grain = _uiState.value.selectedGrain ?: return@launch
            _uiState.update { it.copy(isLoading = true, statusMessage = "Clearing old results for '$propertyName'...") }
            forgeRepository.clearAnalysisResultsForProperty(grain.id, propertyName)
            refreshAnalysisResults(grain.id, propertyName)
            createAnalysisTournament(propertyName)
        }
    }

    fun validateFromSummary(summaryItem: CompetitionSummaryItem) {
        Log.i(TAG, "[VALIDATE-SUMMARY] Validation for response '${summaryItem.response}' with ${summaryItem.voteCount} votes.")
        validateProperty(summaryItem.firstValidTask)
    }

    fun validateAndCreateCardFromIdentification(task: AnalysisResult) {
        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch

            withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_identification)) } }

            try {
                var resultData = parseIntelligentJson<IdentificationResultData>(rawResponse)
                if (resultData == null) {
                    val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
                    val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
                    if (name != null && deck != null) {
                        resultData = IdentificationResultData(name, deck, Reasoning("N/A", "Regex Fallback"), 0.5f)
                    } else {
                        throw IOException(getString(R.string.error_validation_parsing_failed))
                    }
                }

                var cardId = grain.forgedCardId
                if (cardId == null) {
                    val newCard = KnowledgeCard(specificName = resultData.specificName, deckName = resultData.deckName, imagePath = grain.pollenImagePaths.firstOrNull(), confidence = resultData.confidence, reasoning = resultData.reasoning, description = null, stats = null, quiz = null, translations = null, scientificName = null, vernacularName = null, allergens = null, ingredients = null)
                    cardId = cardDao.insert(newCard)
                    pollenGrainDao.updateForgingResult(grain.id, grain.status, cardId)
                } else {
                    cardDao.updateIdentification(cardId, resultData.specificName, resultData.deckName, resultData.reasoning, resultData.confidence)
                }
                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_DESCRIPTION)
                withContext(Dispatchers.Main) { loadWorkshopGrains() }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-ID] Critical validation failure.", e)
                withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message)) } }
            }
        }
    }

    fun validateProperty(task: AnalysisResult) {
        if (task.propertyName == "identification") {
            validateAndCreateCardFromIdentification(task)
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val cardId = grain.forgedCardId ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch
            Log.i(TAG, "[VALIDATE-PROP] Validating property '${task.propertyName}' with task ${task.id}.")

            withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_property, task.propertyName)) } }

            try {
                val propertyJson = parseIntelligentJson<JsonObject>(rawResponse) ?: throw IOException(getString(R.string.error_json_malformed))
                val valueElement = propertyJson.get(task.propertyName) ?: throw IOException(getString(R.string.error_json_key_missing, task.propertyName))
                val valueAsString = if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)

                forgeRepository.updateCardProperty(cardId, task.propertyName, valueAsString)
                pollenGrainDao.updateStatus(grain.id, getNextStatus(grain.status))
                withContext(Dispatchers.Main) { loadWorkshopGrains() }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-PROP] Failed to validate property '${task.propertyName}'.", e)
                withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message)) } }
            }
        }
    }

    private fun getNextStatus(currentStatus: PollenStatus): PollenStatus = when (currentStatus) {
        PollenStatus.PENDING_DESCRIPTION -> PollenStatus.PENDING_STATS
        PollenStatus.PENDING_STATS -> PollenStatus.PENDING_QUIZ
        PollenStatus.PENDING_QUIZ -> PollenStatus.PENDING_TRANSLATION
        PollenStatus.PENDING_TRANSLATION -> PollenStatus.FORGED
        else -> currentStatus
    }

    // BOURDON'S REFACTOR V3: L'Orchestrateur Royal "Ma√Ætre de C√©r√©monie"
    private fun launchCompetitionExecution(propertyName: String, singleTaskToRun: AnalysisResult? = null) {
        competitionJob?.cancel()
        competitionJob = viewModelScope.launch(Dispatchers.IO) {
            val tasksToRun = singleTaskToRun?.let { listOf(it) }
                ?: _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.PENDING } ?: emptyList()

            if (tasksToRun.isEmpty()) {
                Log.w(TAG, "[ORCHESTRATOR] Launch requested for '$propertyName', but no pending tasks found.")
                return@launch
            }

            val tasksByQueen = tasksToRun.groupBy { gson.fromJson(it.modelConfigJson, ModelConfiguration::class.java).modelName }
            Log.i(TAG, "[ORCHESTRATOR] Launching for ${tasksToRun.size} tasks, grouped by ${tasksByQueen.size} Queen(s).")

            for ((modelName, tasksForQueen) in tasksByQueen) {
                Log.i(TAG, "[ORCHESTRATOR] Summoning Queen '$modelName' for ${tasksForQueen.size} task(s).")
                val firstTaskConfig = gson.fromJson(tasksForQueen.first().modelConfigJson, ModelConfiguration::class.java)
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) {
                    Log.e(TAG, "[ORCHESTRATOR] FAILED: AI Queen file '$modelName' not found.")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Model file not found") }
                    continue
                }

                val isMultimodal = tasksForQueen.any { it.propertyName == "identification" || it.propertyName == "description" }
                val queenModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = modelName.contains("gemma-3n", ignoreCase = true))
                val initError = llmHelper.initialize(queenModel, firstTaskConfig.accelerator, isMultimodal)
                if (initError != null) {
                    Log.e(TAG, "[ORCHESTRATOR] Failed to initialize Queen '$modelName': $initError")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Initialization failed: $initError") }
                    continue
                }

                try {
                    for (task in tasksForQueen) {
                        if (!runSingleTask(task)) {
                            Log.w(TAG, "[ORCHESTRATOR] Task ${task.id.substring(0,4)} failed. Queen '$modelName' will continue with next task.")
                        }
                    }
                } finally {
                    Log.i(TAG, "[ORCHESTRATOR] Queen '$modelName' has completed her duties. Cleaning up resources.")
                    llmHelper.cleanUp()
                }
            }
            Log.i(TAG, "[ORCHESTRATOR] All Queens have completed their duties for property '$propertyName'.")
        }
    }

    private suspend fun runSingleTask(task: AnalysisResult): Boolean {
        return try {
            withContext(Dispatchers.Main) { updateTaskStatusInUi(task.id, task.propertyName) { it.copy(status = AnalysisStatus.RUNNING, streamingResponse = "") } }

            val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
            val parentGrain = _uiState.value.selectedGrain ?: throw IllegalStateException("Parent pollen grain not found")
            val card = forgeRepository.getCardForGrain(parentGrain)
            val swarmReportJson = parentGrain.swarmAnalysisReportJson ?: throw IOException("Swarm report missing")

            val isMultimodalTask = task.propertyName == "identification" || task.propertyName == "description"
            val images = if (isMultimodalTask) parentGrain.pollenImagePaths.mapNotNull { BitmapFactory.decodeFile(it) } else emptyList()

            val prompt = when(task.propertyName) {
                "identification" -> ForgePromptGenerator.generateIdentificationTournamentPrompt(swarmReportJson)
                else -> {
                    val currentCard = card ?: throw IllegalStateException("Card not found for refinement")
                    ForgePromptGenerator.generatePropertyForgePrompt(
                        propertyName = task.propertyName, deckName = currentCard.deckName, specificName = currentCard.specificName,
                        swarmReportJson = swarmReportJson, existingDescription = currentCard.description, dependencyDataJson = null
                    )
                }
            }

            llmHelper.resetSession(Model(name=config.modelName, url="", downloadFileName="", sizeInBytes=0), isMultimodalTask, config.temperature, config.topK)

            val fullResponse = suspendCoroutine<String> { continuation ->
                val responseBuilder = StringBuilder()
                llmHelper.runInference(prompt, images) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    if (done) {
                        if (continuation.context.isActive) {
                            continuation.resume(responseBuilder.toString())
                        }
                    }
                }
            }

            val updatedTask = task.copy(status = AnalysisStatus.COMPLETED, rawResponse = fullResponse, streamingResponse = null)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) { refreshAnalysisResults(task.pollenGrainId, task.propertyName) }
            true
        } catch (e: Exception) {
            val status = if (e is CancellationException) AnalysisStatus.CANCELLED else AnalysisStatus.FAILED
            updateTaskStatusInDb(task.id, task.pollenGrainId, task.propertyName, status, e.message)
            false
        }
    }

    fun launchFinalJudgment(propertyName: String) {
        judgmentJob?.cancel()
        val proposals = _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.COMPLETED }
        if (proposals.isNullOrEmpty()) {
            viewModelScope.launch { _uiState.update { it.copy(statusMessage = "Aucune proposition valide √† juger.") } }
            return
        }

        judgmentJob = viewModelScope.launch(Dispatchers.IO) {
            val prompt = ForgePromptGenerator.generateJudgmentPrompt(propertyName, proposals)
            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(judgmentState = JudgmentState.InProgress(propertyName, prompt)) }
            }

            try {
                val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                val modelName = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null) ?: throw IOException("Aucune Reine s√©lectionn√©e pour √™tre l'Arbitre.")
                val accelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) throw IOException("Fichier de la Reine Arbitre introuvable.")
                val arbiterModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0)
                val config = ModelConfiguration(modelName, accelerator, 0.1f, 1)

                val initError = llmHelper.initialize(arbiterModel, accelerator, false)
                if(initError != null) throw RuntimeException("√âchec de l'initialisation de l'Arbitre: $initError")

                val responseBuilder = StringBuilder()
                llmHelper.runInferenceWithConfig(prompt, emptyList(), config) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    viewModelScope.launch(Dispatchers.Main) {
                        _uiState.update {
                            val currentState = it.judgmentState
                            if(currentState is JudgmentState.InProgress) {
                                it.copy(judgmentState = currentState.copy(streamingResponse = responseBuilder.toString()))
                            } else it
                        }
                    }

                    if (done) {
                        val arbiterResponse = parseArbiterResponse(responseBuilder.toString(), proposals)
                        viewModelScope.launch(Dispatchers.Main) {
                            if (arbiterResponse != null) {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Complete(propertyName, arbiterResponse.first, arbiterResponse.second)) }
                            } else {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, "Impossible de parser le verdict de l'Arbitre.")) }
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, e.message ?: "Erreur inconnue de l'Arbitre."))}
                }
            }
        }
    }

    private data class ArbiterVerdict(val arbiterReasoning: String, val bestProposal: JsonObject)

    private fun parseArbiterResponse(rawResponse: String, originalProposals: List<AnalysisResult>): Pair<String, AnalysisResult>? {
        val verdict = parseIntelligentJson<ArbiterVerdict>(rawResponse) ?: return null

        val winningProposal = originalProposals.find {
            it.rawResponse?.let { originalRaw ->
                try {
                    val originalJsonObj = parseIntelligentJson<JsonObject>(originalRaw)
                    originalJsonObj != null && originalJsonObj == verdict.bestProposal
                } catch (e: Exception) { false }
            } ?: false
        }

        return winningProposal?.let { Pair(verdict.arbiterReasoning, it) }
    }

    fun confirmJudgment() {
        val currentState = _uiState.value.judgmentState
        if (currentState is JudgmentState.Complete) {
            validateProperty(currentState.winningProposal)
            dismissJudgment()
        }
    }

    fun dismissJudgment() {
        _uiState.update { it.copy(judgmentState = JudgmentState.None) }
    }

    fun cancelCompetition(propertyName: String) {
        competitionJob?.cancel()
        Log.i(TAG, "[AUTO-FORGE] Comp√©tition pour '$propertyName' annul√©e par l'utilisateur.")
    }

    fun retryAnalysisTask(task: AnalysisResult) {
        launchCompetitionExecution(task.propertyName, singleTaskToRun = task)
    }

    fun deleteSelectedGrain() {
        val grainToDelete = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                forgeRepository.deletePollenGrainAndAssociatedData(grainToDelete)
            }
            loadWorkshopGrains()
        }
    }

    private suspend fun updateTaskStatusInDb(taskId: String, grainId: String, propertyName: String, newStatus: AnalysisStatus, errorMessage: String? = null) {
        val currentTask = forgeRepository.getAnalysisResults(grainId, propertyName).find { it.id == taskId }
        if (currentTask != null) {
            val updatedTask = currentTask.copy(status = newStatus, errorMessage = errorMessage)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) {
                refreshAnalysisResults(grainId, propertyName)
            }
        }
    }

    private fun updateTaskStatusInUi(taskId: String, propertyName: String, updateAction: (AnalysisResult) -> AnalysisResult) {
        _uiState.update { currentState ->
            val newMap = currentState.analysisResults.toMutableMap()
            val propertyTasks = newMap[propertyName]?.toMutableList()
            val taskIndex = propertyTasks?.indexOfFirst { it.id == taskId }

            if (propertyTasks != null && taskIndex != null && taskIndex != -1) {
                propertyTasks[taskIndex] = updateAction(propertyTasks[taskIndex])
                newMap[propertyName] = propertyTasks
                currentState.copy(analysisResults = newMap)
            } else {
                currentState
            }
        }
    }

    private suspend fun loadWorkshopGrains() {
        _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_loading_grains)) }

        val grains = forgeRepository.getGrainsForWorkshop() + pollenGrainDao.getByStatus(PollenStatus.AWAITING_VALIDATION) + pollenGrainDao.getByStatus(PollenStatus.ERROR)
        val items = grains.distinctBy { it.id }.sortedByDescending { it.timestamp }.map { grain ->
            val card = forgeRepository.getCardForGrain(grain)
            Pair(grain, card)
        }
        allWorkshopItems = items

        _uiState.update { it.copy(isLoading = false) }
        updateFilteredGrains()

        val grainToSelect = _uiState.value.workshopGrains.firstOrNull()
        if (grainToSelect != null) {
            selectGrain(grainToSelect)
        } else {
            _uiState.update { it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_to_forge)) }
        }
    }

    private suspend fun refreshAnalysisResults(pollenGrainId: String, propertyName: String) {
        val results = forgeRepository.getAnalysisResults(pollenGrainId, propertyName)

        _uiState.update { currentState ->
            val newAnalysisMap = currentState.analysisResults.toMutableMap().apply { this[propertyName] = results }
            val newSummariesMap = currentState.competitionSummaries.toMutableMap()

            val hasCompletedTasks = results.any { it.status == AnalysisStatus.COMPLETED }
            if (hasCompletedTasks) {
                val summary = createCompetitionSummary(propertyName, results)
                if (summary.items.isNotEmpty()) {
                    newSummariesMap[propertyName] = summary
                } else {
                    newSummariesMap.remove(propertyName)
                }
            } else {
                newSummariesMap.remove(propertyName)
            }
            currentState.copy(analysisResults = newAnalysisMap, competitionSummaries = newSummariesMap)
        }
    }

    private fun createCompetitionSummary(propertyName: String, results: List<AnalysisResult>): CompetitionSummary {
        val completedTasks = results.filter { it.status == AnalysisStatus.COMPLETED && !it.rawResponse.isNullOrBlank() }
        if (completedTasks.isEmpty()) return CompetitionSummary(propertyName, emptyList())

        val responseGroups = completedTasks.groupBy { task ->
            extractValueFromResponse(task.rawResponse!!, propertyName)
        }.filterKeys { it.isNotBlank() }

        val summaryItems = responseGroups.map { (response, tasks) ->
            CompetitionSummaryItem(response = response, voteCount = tasks.size, firstValidTask = tasks.first())
        }.sortedByDescending { it.voteCount }
        return CompetitionSummary(propertyName, summaryItems)
    }

    private fun extractValueFromResponse(rawResponse: String, propertyName: String): String {
        try {
            val propertyJson = parseIntelligentJson<JsonObject>(rawResponse)
            if (propertyJson != null) {
                return when (propertyName) {
                    "identification" -> {
                        val name = propertyJson.get("specificName")?.asString ?: ""
                        val deck = propertyJson.get("deckName")?.asString ?: ""
                        if (name.isNotBlank() && deck.isNotBlank()) "$deck: $name" else ""
                    }
                    else -> {
                        val valueElement = propertyJson.get(propertyName)
                        if (valueElement != null) {
                            if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)
                        } else ""
                    }
                }
            }
        } catch (e: Exception) {
            Log.w(TAG, "[PARSER] Le parsing JSON a √©chou√© pour '$propertyName', tentative de fallback. Erreur: ${e.message}")
        }

        if (propertyName == "identification") {
            val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
            val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
            if (name != null && deck != null) {
                return "$deck: $name"
            }
        }
        return ""
    }


    private inline fun <reified T> parseIntelligentJson(rawString: String): T? {
        val firstBrace = rawString.indexOf('{')
        if (firstBrace == -1) return null

        var braceCount = 0
        var lastBrace = -1
        for (i in firstBrace until rawString.length) {
            when (rawString[i]) {
                '{' -> braceCount++
                '}' -> braceCount--
            }
            if (braceCount == 0) {
                lastBrace = i
                break
            }
        }

        if (lastBrace == -1) return null
        val jsonSubstring = rawString.substring(firstBrace, lastBrace + 1)
        Log.d(TAG, "[PARSER] JSON isol√© pour l'analyse: $jsonSubstring")

        return try {
            val type = object : TypeToken<T>() {}.type
            gson.fromJson(jsonSubstring, type)
        } catch (e: JsonSyntaxException) {
            Log.e(TAG, "[PARSER] Erreur de syntaxe Gson pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        } catch (e: Exception) {
            Log.e(TAG, "[PARSER] Erreur inattendue lors du parsing pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        }
    }

    private fun getString(resId: Int, vararg formatArgs: Any): String {
        return getApplication<Application>().getString(resId, *formatArgs)
    }

    override fun onCleared() {
        super.onCleared()
        competitionJob?.cancel()
        judgmentJob?.cancel()
        llmHelper.cleanUp()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/CardPreviewAdapter.kt ---

package be.heyman.android.ai.kikko.ui.adapters

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import java.io.File

/**
 * BOURDON'S REFACTOR: Cet adaptateur est maintenant align√© sur celui du DeckViewer.
 * Il utilise le layout de vignette compact pour une exp√©rience utilisateur coh√©rente.
 * D√©plac√© depuis le package `debug` car il est utilis√© par des fonctionnalit√©s principales
 * (ex: s√©lection de cartes dans le Clash, mais avec le layout `item_clash_champion_thumbnail`).
 *
 * @param cards La liste mutable des KnowledgeCard √† afficher.
 * @param onCardClickListener Callback lors du clic sur une carte.
 */
class CardPreviewAdapter(
    private val cards: MutableList<KnowledgeCard> = mutableListOf(),
    private val onCardClickListener: (KnowledgeCard) -> Unit
) : RecyclerView.Adapter<CardPreviewAdapter.ViewHolder>() {

    private var selectedCard: KnowledgeCard? = null

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        // BOURDON'S FIX: Les IDs correspondent maintenant √† item_clash_champion_thumbnail.xml.
        val nameTextView: TextView = view.findViewById(R.id.card_thumbnail_name)
        val imageView: ImageView = view.findViewById(R.id.card_thumbnail_image)
        // La vue des stats n'existe plus dans ce layout, donc elle est retir√©e.
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        // BOURDON'S FIX: Utilisation du layout correct et compact pour les vignettes de champion.
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_clash_champion_thumbnail, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val card = cards[position]
        holder.nameTextView.text = card.specificName

        card.imagePath?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                val bitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                holder.imageView.setImageBitmap(bitmap)
            } else {
                holder.imageView.setImageResource(R.drawable.ic_placeholder_card)
            }
        } ?: holder.imageView.setImageResource(R.drawable.ic_placeholder_card)

        holder.itemView.setOnClickListener { onCardClickListener(card) }
    }

    override fun getItemCount() = cards.size

    fun updateCards(newCards: List<KnowledgeCard>) {
        cards.clear()
        cards.addAll(newCards)
        notifyDataSetChanged()
    }

    fun setSelectedCard(card: KnowledgeCard?) {
        selectedCard = card
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/CardPreviewAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/KnowledgeCardAdapter.kt ---

package be.heyman.android.ai.kikko.ui.adapters

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R // BOURDON'S FIX: Import R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import com.bumptech.glide.Glide
import java.io.File // BOURDON'S FIX: Import File

// BOURDON'S FIX: Changement de ListAdapter √† RecyclerView.Adapter pour simplifier la gestion.
// ListAdapter n√©cessite un DiffUtil qui n'√©tait pas la source directe de l'erreur,
// mais revenons √† la base pour s'assurer de la correction du ViewBinding.
class KnowledgeCardAdapter(
    private val onCardClicked: (KnowledgeCard) -> Unit
) : RecyclerView.Adapter<KnowledgeCardAdapter.ViewHolder>() { // BOURDON'S FIX: H√©rite de RecyclerView.Adapter

    // BOURDON'S FIX: Le ViewHolder prend maintenant une View et utilise findViewById
    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val cardName: TextView = view.findViewById(R.id.card_title) // BOURDON'S FIX: ID correct pour item_knowledge_card_reforged
        val cardDeck: TextView = view.findViewById(R.id.card_deck_name) // BOURDON'S FIX: ID correct
        val cardImage: ImageView = view.findViewById(R.id.card_image) // BOURDON'S FIX: ID correct

        init {
            itemView.setOnClickListener {
                if (adapterPosition != RecyclerView.NO_POSITION) {
                    onCardClicked(currentList[adapterPosition]) // BOURDON'S FIX: Acc√®s √† currentList
                }
            }
        }

        fun bind(card: KnowledgeCard) {
            cardName.text = card.specificName
            cardDeck.text = card.deckName
            // BOURDON'S FIX: Utilisation de Glide avec le contexte de la vue et gestion des chemins locaux
            card.imagePath?.let { path ->
                val imgFile = File(path)
                if (imgFile.exists()) {
                    Glide.with(itemView.context)
                        .load(imgFile)
                        .into(cardImage)
                } else {
                    cardImage.setImageResource(R.drawable.ic_placeholder_card) // Image par d√©faut si le fichier n'existe pas
                }
            } ?: cardImage.setImageResource(R.drawable.ic_placeholder_card)
        }
    }

    // BOURDON'S FIX: Ajout d'une liste interne pour g√©rer les donn√©es, comme dans ListAdapter
    private var currentList: List<KnowledgeCard> = emptyList()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        // BOURDON'S FIX: Inflate le layout de carte refait pour le Clash
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_knowledge_card_reforged, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val card = currentList[position] // BOURDON'S FIX: Acc√®s √† currentList
        holder.bind(card)
    }

    override fun getItemCount() = currentList.size // BOURDON'S FIX: Taille de currentList

    // BOURDON'S FIX: M√©thode pour soumettre une nouvelle liste de cartes
    fun submitList(newList: List<KnowledgeCard>) {
        currentList = newList
        notifyDataSetChanged() // BOURDON'S FIX: Notifie le changement de donn√©es
    }
}

// BOURDON'S FIX: DiffUtil est conserv√© si on souhaite le remettre en place avec ListAdapter plus tard.
// Pour l'instant, il n'est plus directement utilis√© par KnowledgeCardAdapter.
class KnowledgeCardDiffCallback : DiffUtil.ItemCallback<KnowledgeCard>() {
    override fun areItemsTheSame(oldItem: KnowledgeCard, newItem: KnowledgeCard): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: KnowledgeCard, newItem: KnowledgeCard): Boolean {
        return oldItem == newItem
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/KnowledgeCardAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/LocalModelAdapter.kt ---

package be.heyman.android.ai.kikko.ui.adapters

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import java.io.File

/**
 * Adaptateur pour afficher une liste de mod√®les IA locaux (fichiers .task).
 * D√©plac√© depuis le package `debug` car il est essentiel pour `ToolsDialogFragment`.
 *
 * @param models La liste mutable des fichiers de mod√®le √† afficher.
 * @param onDeleteClick Une fonction lambda appel√©e lorsqu'un utilisateur clique sur le bouton de suppression.
 */
class LocalModelAdapter(
    private var models: MutableList<File>,
    private val onDeleteClick: (File) -> Unit
) : RecyclerView.Adapter<LocalModelAdapter.ViewHolder>() {

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val modelName: TextView = view.findViewById(R.id.local_model_name_textview)
        val deleteButton: ImageButton = view.findViewById(R.id.local_model_delete_button)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_local_model, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val modelFile = models[position]
        holder.modelName.text = modelFile.name
        holder.deleteButton.setOnClickListener {
            onDeleteClick(modelFile)
        }
    }

    override fun getItemCount() = models.size

    fun updateModels(newModels: List<File>) {
        models.clear()
        models.addAll(newModels)
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/LocalModelAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/PreferenceHelper.kt ---

package be.heyman.android.ai.kikko.util

import android.content.Context
import android.content.SharedPreferences

object PreferenceHelper {

    const val PREFS_NAME = "kikko_prefs"

    // Onboarding
    const val PREF_ONBOARDING_COMPLETED = "onboarding_completed"

    // Queen AI Configuration
    const val KEY_SELECTED_FORGE_QUEEN = "selected_forge_queen"
    const val KEY_SELECTED_FORGE_QUEEN_ACCELERATOR = "selected_forge_queen_accelerator"

    // Worker Constraints
    const val KEY_REQUIRE_CHARGING = "require_charging"
    const val KEY_REQUIRE_IDLE = "require_idle"


    private fun getPrefs(context: Context): SharedPreferences {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }

    fun setBoolean(context: Context, key: String, value: Boolean) {
        getPrefs(context).edit().putBoolean(key, value).apply()
    }

    fun getBoolean(context: Context, key: String, defaultValue: Boolean): Boolean {
        return getPrefs(context).getBoolean(key, defaultValue)
    }

    fun setString(context: Context, key: String, value: String?) {
        getPrefs(context).edit().putString(key, value).apply()
    }

    fun getString(context: Context, key: String, defaultValue: String?): String? {
        return getPrefs(context).getString(key, defaultValue)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/PreferenceHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLog.kt ---

package be.heyman.android.ai.kikko.util.logging

import kotlinx.serialization.Serializable

/**
 * Repr√©sente une seule entr√©e dans le journal de forge (Journal de Bord).
 * Capture l'int√©gralit√© d'une transaction avec un mod√®le LLM pour analyse et d√©bogage.
 * D√©plac√© depuis le package `debug` vers un nouveau package `util.logging`
 * car il est une fonctionnalit√© de logging g√©n√©rale.
 */
@Serializable
data class InferenceLog(
    val inferenceId: String,
    val timestamp: String,
    val useCase: String,
    val model: ModelInfo,
    val prompt: String, // AJOUT√â : Le prompt exact envoy√© au mod√®le.
    val rawResponse: String, // AJOUT√â : La r√©ponse brute compl√®te re√ßue.
    val metadata: InferenceMetadata
)

/**
 * Contient les informations sur le mod√®le utilis√© pour l'inf√©rence.
 */
@Serializable
data class ModelInfo(
    val name: String,
    val configuration: ModelConfiguration
)

/**
 * Contient les param√®tres de configuration cl√©s utilis√©s pour cette inf√©rence sp√©cifique.
 */
@Serializable
data class ModelConfiguration(
    val temperature: Float,
    val topK: Int,
    val maxTokens: Int,
    val accelerator: String
)

/**
 * Contient les m√©tadonn√©es de performance de l'inf√©rence.
 */
@Serializable
data class InferenceMetadata(
    val latencyMs: Long,
    val tokensPerSecond: Float
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLog.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLogger.kt ---

package be.heyman.android.ai.kikko.util.logging

import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

/**
 * Un logger singleton en m√©moire pour conserver une trace de toutes les inf√©rences LLM
 * effectu√©es pendant une session de d√©bogage.
 *
 * NOTE : Ce logger est volatile. Son contenu est perdu lorsque l'application est ferm√©e.
 * D√©plac√© depuis le package `debug` vers un nouveau package `util.logging`
 * car il est une fonctionnalit√© de logging g√©n√©rale.
 */
object InferenceLogger {

    // Configure l'encodeur JSON pour une sortie lisible (pretty print).
    private val json = Json { prettyPrint = true }

    // La liste priv√©e et mutable qui stocke nos entr√©es de journal.
    private val logEntries = mutableListOf<InferenceLog>()

    /**
     * Ajoute une nouvelle entr√©e de journal √† la liste de mani√®re thread-safe.
     * @param entry L'objet InferenceLog √† ajouter.
     */
    @Synchronized
    fun add(entry: InferenceLog) {
        logEntries.add(entry)
    }

    /**
     * Vide compl√®tement le journal de mani√®re thread-safe.
     */
    @Synchronized
    fun clear() {
        logEntries.clear()
    }

    /**
     * Renvoie une copie immuable de toutes les entr√©es du journal.
     * @return Une List<InferenceLog> des entr√©es actuelles.
     */
    fun getLogs(): List<InferenceLog> {
        return logEntries.toList()
    }

    /**
     * Compte le nombre d'entr√©es actuellement dans le journal.
     * @return Le nombre d'inf√©rences enregistr√©es.
     */
    fun count(): Int {
        return logEntries.size
    }

    /**
     * S√©rialise l'ensemble du journal en une cha√Æne de caract√®res JSON format√©e.
     * @return Une cha√Æne JSON repr√©sentant la liste des entr√©es, ou un message d'erreur.
     */
    @Synchronized
    fun exportToJson(): String {
        if (logEntries.isEmpty()) {
            return "{\"status\": \"Le journal de forge est vide.\"}"
        }
        return try {
            json.encodeToString(logEntries)
        } catch (e: Exception) {
            "{\"error\": \"√âchec de la s√©rialisation du journal en JSON.\", \"details\": \"${e.message}\"}"
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLogger.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/DownloadManagerKikko.kt ---

package be.heyman.android.ai.kikko.worker

import android.content.Context
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import be.heyman.android.ai.kikko.data.KEY_MODEL_DOWNLOAD_FILE_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_IS_ZIP
import be.heyman.android.ai.kikko.data.KEY_MODEL_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_TOTAL_BYTES
import be.heyman.android.ai.kikko.data.KEY_MODEL_UNZIPPED_DIR
import be.heyman.android.ai.kikko.data.KEY_MODEL_URL
import be.heyman.android.ai.kikko.data.Model

/**
 * Manager pour initier les t√©l√©chargements de mod√®les via WorkManager.
 * D√©plac√© depuis le package `debug` car il g√®re les mod√®les locaux de l'application.
 */
object DownloadManagerKikko {

    /**
     * Lance le t√©l√©chargement d'un mod√®le sp√©cifi√©.
     * Le mod√®le est identifi√© par son nom unique pour √©viter les t√©l√©chargements multiples.
     *
     * @param context Contexte de l'application.
     * @param model Le mod√®le √† t√©l√©charger.
     */
    fun startDownload(context: Context, model: Model) {
        val workManager = WorkManager.getInstance(context.applicationContext)

        val inputData = Data.Builder()
            .putString(KEY_MODEL_NAME, model.name)
            .putString(KEY_MODEL_URL, model.url)
            .putString(KEY_MODEL_DOWNLOAD_FILE_NAME, model.downloadFileName)
            .putLong(KEY_MODEL_TOTAL_BYTES, model.sizeInBytes)
            .putBoolean(KEY_MODEL_IS_ZIP, model.isZip)
            .putString(KEY_MODEL_UNZIPPED_DIR, model.unzipDir)
            .build()

        val downloadWorkRequest = OneTimeWorkRequestBuilder<KikkoDownloadWorker>()
            .setInputData(inputData)
            .addTag(model.name) // On utilise le nom comme tag unique pour identifier ce travail
            .build()

        workManager.enqueueUniqueWork(
            model.name, // Nom unique pour la t√¢che de t√©l√©chargement
            ExistingWorkPolicy.REPLACE, // Remplace la t√¢che si elle existe d√©j√†
            downloadWorkRequest
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/DownloadManagerKikko.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/ForgeWorker.kt ---

package be.heyman.android.ai.kikko.worker

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.pm.ServiceInfo
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.forge.ForgeLlmHelper
import be.heyman.android.ai.kikko.forge.PromptGenerator
import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.model.QuizQuestion
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.model.SwarmAnalysisResult
import be.heyman.android.ai.kikko.model.TranslatedContent
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Locale

class ForgeWorker(val appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {

    private val pollenGrainDao: PollenGrainDao = (appContext.applicationContext as KikkoApplication).pollenGrainDao
    private val cardDao: CardDao = (appContext.applicationContext as KikkoApplication).cardDao
    private val llmHelper: ForgeLlmHelper = (appContext.applicationContext as KikkoApplication).forgeLlmHelper
    private val gson = Gson()
    private val targetLanguages = mapOf("fr" to "French", "ja" to "Japanese")

    private data class IdentificationResult(
        val reasoning: Reasoning,
        val deckName: String,
        val specificName: String,
        val confidence: Float
    )
    private data class StatsResponse(val stats: Map<String, String>?)
    private data class FoodStatsResult(
        val stats: Map<String, String>?,
        val ingredients: List<String>?,
        val allergens: List<String>?
    )
    private data class BiologicalNamesResult(
        val scientificName: String?,
        val vernacularName: String?
    )

    companion object {
        const val TAG = "ForgeWorker"
        const val NOTIFICATION_ID = 1001
        const val NOTIFICATION_CHANNEL_ID = "KikkoForgeChannel"
        private const val THUMBNAIL_SIZE = 256

        val processingOrder = listOf(
            PollenStatus.RAW,
            PollenStatus.PENDING_DESCRIPTION,
            PollenStatus.PENDING_STATS,
            PollenStatus.PENDING_QUIZ,
            PollenStatus.PENDING_TRANSLATION
        )
    }

    override suspend fun doWork(): Result {
        Log.i(TAG, "WORKER MONOLITHIQUE D√âMARR√â.")
        setForeground(createForegroundInfo("La Forge s'√©veille..."))

        try {
            for (statusToProcess in processingOrder) {
                while (true) {
                    val grain = pollenGrainDao.getByStatus(statusToProcess).firstOrNull() ?: break
                    Log.i(TAG, "Traitement du grain ${grain.id} au statut $statusToProcess")

                    val thumbnail = withContext(Dispatchers.IO) { grain.pollenImagePaths.firstOrNull()?.let { createThumbnail(BitmapFactory.decodeFile(it), THUMBNAIL_SIZE) } }

                    try {
                        when (grain.status) {
                            PollenStatus.RAW -> {
                                setForeground(createForegroundInfo("√âtape 1/5: Identification du Pollen...", thumbnail))
                                val card = runIdentification(grain)
                                pollenGrainDao.updateForgingResult(grain.id, PollenStatus.PENDING_DESCRIPTION, card.id)
                            }
                            PollenStatus.PENDING_DESCRIPTION -> {
                                setForeground(createForegroundInfo("√âtape 2/5: G√©n√©ration de la Description...", thumbnail))
                                runDescription(grain.forgedCardId!!)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_STATS)
                            }
                            PollenStatus.PENDING_STATS -> {
                                setForeground(createForegroundInfo("√âtape 3/5: Extraction des Statistiques...", thumbnail))
                                runStats(grain.forgedCardId!!, grain.swarmAnalysisReportJson)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_QUIZ)
                            }
                            PollenStatus.PENDING_QUIZ -> {
                                setForeground(createForegroundInfo("√âtape 4/5: Cr√©ation du Quiz...", thumbnail))
                                runQuiz(grain.forgedCardId!!)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_TRANSLATION)
                            }
                            PollenStatus.PENDING_TRANSLATION -> {
                                setForeground(createForegroundInfo("√âtape 5/5: Traduction du Miel...", thumbnail))
                                runTranslation(grain.forgedCardId!!)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.FORGED)
                                Log.i(TAG, "FORGE TERMIN√âE AVEC SUCC√àS pour le grain ${grain.id}.")
                            }
                            else -> Log.w(TAG, "Statut inattendu trouv√©: ${grain.status}")
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "√âCHEC d'une √©tape pour le grain ${grain.id}", e)
                        pollenGrainDao.updateStatus(grain.id, PollenStatus.ERROR)
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Une erreur g√©n√©rale a interrompu le worker", e)
            return Result.failure()
        }

        Log.i(TAG, "Toutes les t√¢ches disponibles sont termin√©es. Le worker va se rendormir.")
        return Result.success()
    }

    private suspend fun runIdentification(grain: PollenGrain): KnowledgeCard {
        val config = getQueenModelConfig()
        try {
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = config.modelName.contains("gemma-3n", ignoreCase = true))

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = true)
            if (initError != null) throw RuntimeException("√âchec de l'initialisation (Identification): $initError")

            val swarmReportJson = grain.swarmAnalysisReportJson ?: throw IOException("Rapport d'essaim manquant.")
            val prompt = PromptGenerator.generateIdentificationPrompt(swarmReportJson)
            val bitmaps = withContext(Dispatchers.IO) { grain.pollenImagePaths.mapNotNull { BitmapFactory.decodeFile(it) } }

            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, bitmaps, config)
            val result = parseIntelligentJson<IdentificationResult>(fullResponse) ?: throw IOException("R√©ponse d'identification invalide: $fullResponse")

            val newCard = KnowledgeCard(
                specificName = result.specificName, deckName = result.deckName,
                imagePath = grain.pollenImagePaths.firstOrNull(), confidence = result.confidence,
                reasoning = result.reasoning, description = null, stats = null, allergens = null, ingredients = null, quiz = null, translations = null,
                scientificName = null, vernacularName = null
            )
            val newId = cardDao.insert(newCard)
            return newCard.copy(id = newId)
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runDescription(cardId: Long) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour la description.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("√âchec de l'initialisation (Description): $initError")

            val prompt = PromptGenerator.generateNarrationDescriptionPrompt(card.specificName, card.deckName, Locale.getDefault())
            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)
            cardDao.updateDescription(cardId, fullResponse.trim())
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runStats(cardId: Long, swarmReportJson: String?) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour les stats.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("√âchec de l'initialisation (Stats): $initError")

            val ocr = gson.fromJson(swarmReportJson, SwarmAnalysisResult::class.java)?.reports?.joinToString("\n") { it.ocrText }?.trim() ?: ""
            val prompt = PromptGenerator.generateStatsExtractionPrompt(card.specificName, card.deckName, ocr, card.description ?: "")
            if (prompt.isBlank()) {
                Log.w(TAG, "Aucun prompt g√©n√©r√© pour le deck ${card.deckName}. Pas de stats √† extraire.")
                return
            }

            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)

            if (card.deckName == "Food") {
                val foodResult = parseIntelligentJson<FoodStatsResult>(fullResponse)
                cardDao.updateStats(cardId, foodResult?.stats?.let { CardStats("Statistics", it) }, foodResult?.allergens, foodResult?.ingredients)
            } else {
                val statsResult = parseIntelligentJson<StatsResponse>(fullResponse)
                cardDao.updateStats(cardId, statsResult?.stats?.let { CardStats("Statistics", it) }, null, null)

                if (card.deckName == "Plant" || card.deckName == "Insect" || card.deckName == "Bird") {
                    val biologicalNamesResult = parseIntelligentJson<BiologicalNamesResult>(fullResponse)
                    cardDao.updateScientificAndVernacularNames(cardId, biologicalNamesResult?.scientificName, biologicalNamesResult?.vernacularName)
                }
            }
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runQuiz(cardId: Long) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour le quiz.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("√âchec de l'initialisation (Quiz): $initError")

            val prompt = PromptGenerator.generateQuizPrompt(card.specificName, card.description ?: "", card.stats, Locale.getDefault())
            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)
            val quiz = parseIntelligentJson<List<QuizQuestion>>(fullResponse) ?: throw IOException("La Reine IA a fourni un quiz vide ou dans un format invalide. R√©ponse brute: $fullResponse")
            cardDao.updateQuiz(cardId, quiz)
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runTranslation(cardId: Long) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour la traduction.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("√âchec de l'initialisation (Traduction): $initError")
            val newTranslations = card.translations?.toMutableMap() ?: mutableMapOf()

            for ((langCode, langName) in targetLanguages) {
                if (newTranslations.containsKey(langCode)) continue
                Log.d(TAG, "Traduction en cours vers '$langName'...")

                val originalContent = TranslatableCardContent(card.description, card.reasoning, card.quiz)
                val originalJson = gson.toJson(originalContent)
                val prompt = PromptGenerator.generateFullCardTranslationPrompt(originalJson, langName)
                val translatedJson = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)
                val translatedContent = parseIntelligentJson<TranslatedContent>(translatedJson)

                if(translatedContent != null) {
                    newTranslations[langCode] = translatedContent
                } else {
                    Log.w(TAG, "√âchec du parsing de la traduction pour la langue $langName. R√©ponse brute: $translatedJson")
                }
            }
            cardDao.updateTranslations(cardId, newTranslations)
        } finally {
            llmHelper.cleanUp()
        }
    }

    private fun getQueenModelConfig(): ModelConfiguration {
        val prefs = appContext.getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
        val name = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null) ?: throw IllegalStateException("Aucune Reine IA s√©lectionn√©e.")
        val accelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!
        val temperature = prefs.getFloat("forge_temp", 0.2f)
        val topK = prefs.getInt("forge_topK", 40)
        return ModelConfiguration(name, accelerator, temperature, topK)
    }

    private inline fun <reified T> parseIntelligentJson(rawString: String): T? {
        return try {
            val jsonSubstring = rawString.substringAfter("```json", rawString).substringBeforeLast("```").trim()
            val type = object : TypeToken<T>() {}.type
            gson.fromJson(jsonSubstring, type)
        } catch (e: Exception) {
            Log.e(TAG, "Le parsing intelligent a √©chou√© pour le type ${T::class.java.simpleName}: '$rawString'", e)
            null
        }
    }

    override suspend fun getForegroundInfo(): ForegroundInfo = createForegroundInfo("La Forge de la Ruche se pr√©pare...")

    private fun createThumbnail(source: Bitmap?, size: Int): Bitmap? {
        if (source == null) return null
        val scaledWidth = if (source.width > source.height) size * source.width / source.height else size
        val scaledHeight = if (source.height >= source.width) size * source.height / source.width else size
        return Bitmap.createScaledBitmap(source, scaledWidth, scaledHeight, false)
    }

    private fun createForegroundInfo(progress: String, thumbnail: Bitmap? = null): ForegroundInfo {
        val channelId = NOTIFICATION_CHANNEL_ID
        val channelName = "Forge Kikko en Arri√®re-Plan"
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_LOW)
            val notificationManager = appContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }

        val notificationBuilder = NotificationCompat.Builder(applicationContext, channelId)
            .setContentTitle("La Ruche travaille...")
            .setContentText(progress)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setOngoing(true)
            .setProgress(100, 0, true)

        if (thumbnail != null) {
            notificationBuilder.setLargeIcon(thumbnail)
        }

        val notification = notificationBuilder.build()

        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ForegroundInfo(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)
        } else {
            ForegroundInfo(NOTIFICATION_ID, notification)
        }
    }

    private data class TranslatableCardContent(
        val description: String?,
        val reasoning: Reasoning?,
        val quiz: List<QuizQuestion>?
    )
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/ForgeWorker.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/KikkoDownloadWorker.kt ---

package be.heyman.android.ai.kikko.worker

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.data.KEY_MODEL_DOWNLOAD_FILE_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_DOWNLOAD_REMAINING_MS
import be.heyman.android.ai.kikko.data.KEY_MODEL_IS_ZIP
import be.heyman.android.ai.kikko.data.KEY_MODEL_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_START_UNZIPPING
import be.heyman.android.ai.kikko.data.KEY_MODEL_TOTAL_BYTES
import be.heyman.android.ai.kikko.data.KEY_MODEL_UNZIPPED_DIR
import be.heyman.android.ai.kikko.data.KEY_MODEL_URL
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.delay
import java.io.BufferedInputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URL
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

/**
 * Worker Hilt pour le t√©l√©chargement et la d√©compression de mod√®les.
 * D√©plac√© depuis le package `debug` car il est central √† la gestion des mod√®les.
 */
class KikkoDownloadWorker(val context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {

    companion object {
        const val ACTION_PROGRESS_UPDATE = "com.google.edge.kikko.debug.PROGRESS_UPDATE"
        const val EXTRA_MODEL_NAME = "EXTRA_MODEL_NAME"
        const val EXTRA_RECEIVED_BYTES = "EXTRA_RECEIVED_BYTES"
        const val EXTRA_TOTAL_BYTES = "EXTRA_TOTAL_BYTES"
        const val EXTRA_DOWNLOAD_SPEED_BPS = "EXTRA_DOWNLOAD_SPEED_BPS"
        const val NOTIFICATION_CHANNEL_ID = "kikko_download_channel"
    }

    private val TAG = "KikkoDownloadWorker"
    private val notificationManager = NotificationManagerCompat.from(applicationContext)

    init {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "T√©l√©chargements de mod√®les Kikko",
                NotificationManager.IMPORTANCE_LOW
            )
            notificationManager.createNotificationChannel(channel)
        }
    }

    override suspend fun doWork(): Result {
        val modelName = inputData.getString(KEY_MODEL_NAME) ?: return Result.failure()
        val fileUrl = inputData.getString(KEY_MODEL_URL) ?: return Result.failure()
        val fileName = inputData.getString(KEY_MODEL_DOWNLOAD_FILE_NAME) ?: return Result.failure()
        val estimatedTotalBytes = inputData.getLong(KEY_MODEL_TOTAL_BYTES, 0L)
        val isZip = inputData.getBoolean(KEY_MODEL_IS_ZIP, false)
        val unzipDir = inputData.getString(KEY_MODEL_UNZIPPED_DIR)

        val modelBaseDir = File(applicationContext.getExternalFilesDir(null), "imported_models") // BOURDON'S FIX: Utilisation du dossier "imported_models"
        if (!modelBaseDir.exists()) modelBaseDir.mkdirs()
        val modelDir = File(modelBaseDir, modelName)
        if (!modelDir.exists()) modelDir.mkdirs()

        val outputFile = File(modelDir, fileName)

        try {
            setForeground(createForegroundInfo("D√©marrage du t√©l√©chargement pour $modelName", 0))
            downloadFile(fileUrl, outputFile, estimatedTotalBytes, modelName)

            if (isZip) { // BOURDON'S FIX: Le dossier de d√©compression est maintenant le dossier du mod√®le lui-m√™me, pas un sous-dossier sp√©cifi√© par `unzipDir`
                setForeground(createForegroundInfo("D√©compression de $modelName...", 0, true))
                setProgress(Data.Builder().putBoolean(KEY_MODEL_START_UNZIPPING, true).build())
                unzip(outputFile, modelDir) // D√©compresse directement dans le dossier du mod√®le
                outputFile.delete() // Supprime le fichier zip apr√®s d√©compression
            }
            return Result.success()
        } catch (e: Exception) {
            if (e is CancellationException || e is InterruptedException) {
                Log.i(TAG, "Download cancelled for $modelName")
            } else {
                Log.e(TAG, "Download or Unzip failed for $modelName", e)
                if(outputFile.exists()) outputFile.delete()
                return Result.failure()
            }
            return Result.success() // En cas d'annulation, on termine le worker proprement
        }
    }

    private suspend fun downloadFile(downloadUrl: String, outputFile: File, estimatedTotalBytes: Long, modelName: String) {
        val url = URL(downloadUrl)
        val connection = url.openConnection() as HttpURLConnection
        connection.connect()

        if (connection.responseCode != HttpURLConnection.HTTP_OK) {
            throw IOException("Server returned HTTP ${connection.responseCode} ${connection.responseMessage}")
        }

        val actualTotalBytes = if (connection.contentLength > 0) connection.contentLength.toLong() else estimatedTotalBytes

        val inputStream = connection.inputStream
        val outputStream = FileOutputStream(outputFile)
        val buffer = ByteArray(8 * 1024)
        var bytesCopied: Long = 0
        var bytesRead: Int
        var lastReportTime = System.currentTimeMillis()
        var lastReportedBytes: Long = 0
        val bytesReadSizeBuffer: MutableList<Long> = mutableListOf()
        val bytesReadLatencyBuffer: MutableList<Long> = mutableListOf()

        try {
            while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                if (isStopped) throw InterruptedException("Download cancelled")
                outputStream.write(buffer, 0, bytesRead)
                bytesCopied += bytesRead

                val currentTime = System.currentTimeMillis()
                if (currentTime - lastReportTime >= 500) { // Update notification less frequently
                    val timeDelta = (currentTime - lastReportTime)
                    val bytesDelta = bytesCopied - lastReportedBytes
                    val speedBps = if (timeDelta > 0) (bytesDelta * 1000 / timeDelta) else 0L

                    var remainingMs = -1L
                    bytesReadSizeBuffer.add(bytesDelta)
                    if (bytesReadSizeBuffer.size > 5) bytesReadSizeBuffer.removeAt(0)
                    bytesReadLatencyBuffer.add(timeDelta)
                    if (bytesReadLatencyBuffer.size > 5) bytesReadLatencyBuffer.removeAt(0)

                    val totalRecentBytes = bytesReadSizeBuffer.sum()
                    val totalRecentTime = bytesReadLatencyBuffer.sum()
                    if (totalRecentTime > 0 && totalRecentBytes > 0) {
                        val avgSpeedBps = totalRecentBytes * 1000 / totalRecentTime
                        if (avgSpeedBps > 0) {
                            remainingMs = (actualTotalBytes - bytesCopied) * 1000 / avgSpeedBps
                        }
                    }

                    val progressPercent = if (actualTotalBytes > 0) (bytesCopied * 100 / actualTotalBytes).toInt() else 0
                    val progressText = "T√©l√©chargement de $modelName ($progressPercent%)"
                    setForeground(createForegroundInfo(progressText, progressPercent))

                    val intent = Intent(ACTION_PROGRESS_UPDATE).apply {
                        putExtra(EXTRA_MODEL_NAME, modelName)
                        putExtra(EXTRA_RECEIVED_BYTES, bytesCopied)
                        putExtra(EXTRA_TOTAL_BYTES, actualTotalBytes)
                        putExtra(EXTRA_DOWNLOAD_SPEED_BPS, speedBps)
                        putExtra(KEY_MODEL_DOWNLOAD_REMAINING_MS, remainingMs)
                    }
                    LocalBroadcastManager.getInstance(context).sendBroadcast(intent)

                    lastReportTime = currentTime
                    lastReportedBytes = bytesCopied
                    delay(50)
                }
            }
        } finally {
            outputStream.close()
            inputStream.close()
        }
    }

    private fun unzip(zipFile: File, targetDirectory: File) {
        Log.d(TAG, "Unzipping ${zipFile.name} into ${targetDirectory.name}")
        ZipInputStream(BufferedInputStream(FileInputStream(zipFile))).use { zis ->
            var entry: ZipEntry? = zis.nextEntry
            while (entry != null) {
                if (isStopped) throw InterruptedException("Unzip cancelled")

                val newFile = File(targetDirectory, entry.name)
                // Protection contre les Zip Slip Attacks
                if (!newFile.canonicalPath.startsWith(targetDirectory.canonicalPath + File.separator)) {
                    throw IOException("Zip Slip Attack d√©tect√©e: ${entry.name}")
                }

                if (entry.isDirectory) {
                    if (!newFile.isDirectory && !newFile.mkdirs()) {
                        throw IOException("√âchec de la cr√©ation du r√©pertoire ${newFile.absolutePath}")
                    }
                } else {
                    val parent = newFile.parentFile
                    if (parent != null && !parent.isDirectory && !parent.mkdirs()) {
                        throw IOException("√âchec de la cr√©ation du r√©pertoire parent ${parent.absolutePath}")
                    }
                    FileOutputStream(newFile).use { fos -> zis.copyTo(fos) }
                }
                zis.closeEntry()
                entry = zis.nextEntry
            }
        }
    }

    override suspend fun getForegroundInfo(): ForegroundInfo {
        return createForegroundInfo("Pr√©paration du t√©l√©chargement...", 0)
    }

    private fun createForegroundInfo(text: String, progress: Int, indeterminate: Boolean = false): ForegroundInfo {
        val notification = NotificationCompat.Builder(applicationContext, NOTIFICATION_CHANNEL_ID)
            .setContentTitle("Forge de la Ruche Kikko")
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_launcher_foreground) // Assurez-vous d'avoir une ic√¥ne ici
            .setOngoing(true)
            .setProgress(100, progress, indeterminate)
            .build()

        return ForegroundInfo(id.hashCode(), notification)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/KikkoDownloadWorker.kt ---


--- START OF FILE app/src/main/res/font/luckiest_guy.xml ---

<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/luckiest_guy_regular" />
</font-family>

--- END OF FILE app/src/main/res/font/luckiest_guy.xml ---


--- START OF FILE app/src/main/res/font/poppins.xml ---

<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/poppins_regular" />
    <font
        android:fontStyle="normal"
        android:fontWeight="700"
        android:font="@font/poppins_bold" />
</font-family>

--- END OF FILE app/src/main/res/font/poppins.xml ---


--- START OF FILE app/src/main/res/layout/activity_clash_arena.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/clash_arena_root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/kikko_bark_brown"
    tools:context=".clash.ui.ClashActivity"
    tools:ignore="ContentDescription">

    <!-- BOURDON'S REFACTOR: Le ViewPager pour les duels -->
    <androidx.viewpager2.widget.ViewPager2
        android:id="@+id/tournament_viewpager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="?attr/colorSurfaceContainer"
        android:visibility="gone"
        tools:visibility="gone" />

    <!-- BOURDON'S REFACTOR V3: Remplacement de VideoView par PlayerView pour la s√©lection -->
    <androidx.media3.ui.PlayerView
        android:id="@+id/clash_background_video_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:resize_mode="zoom"
        app:use_controller="false" />

    <!-- BOURDON'S REFACTOR: Le groupe pour la vue de pr√©paration -->
    <androidx.constraintlayout.widget.Group
        android:id="@+id/clash_setup_group"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:constraint_referenced_ids="clash_background_video_view,clash_title,clash_button_random,clash_button_settings,clash_button_radar,clash_button_start_solo,player1_selection_container,player2_selection_container,clash_queen_status,guideline_center"
        android:visibility="visible"
        tools:visibility="visible"/>

    <!-- Le reste du layout reste identique -->

    <LinearLayout
        android:id="@+id/clash_judge_loading_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center"
        android:padding="24dp"
        android:background="@drawable/scroll_background"
        android:backgroundTint="#A0000000"
        android:elevation="10dp"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">
        <ProgressBar
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"/>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:text="@string/clash_judge_awakening"
            android:fontFamily="@font/luckiest_guy"
            android:textColor="@color/kikko_honey_yellow"
            android:textSize="18sp"/>
    </LinearLayout>

    <TextView
        android:id="@+id/clash_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:fontFamily="@font/luckiest_guy"
        android:shadowColor="@color/black"
        android:shadowDx="1"
        android:shadowDy="1"
        android:shadowRadius="2"
        android:text="@string/clash_title"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="34sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <ImageButton
        android:id="@+id/clash_button_random"
        style="@style/Widget.AppCompat.Button.Borderless"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginStart="16dp"
        android:layout_marginTop="16dp"
        android:src="@android:drawable/ic_menu_rotate"
        android:contentDescription="@string/clash_button_random_desc"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:tint="@color/kikko_honey_yellow" />

    <ImageButton
        android:id="@+id/clash_button_settings"
        style="@style/Widget.AppCompat.Button.Borderless"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginTop="16dp"
        android:layout_marginEnd="16dp"
        android:src="@android:drawable/ic_menu_manage"
        android:contentDescription="@string/clash_button_settings_desc"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:tint="@color/kikko_honey_yellow" />

    <ImageButton
        android:id="@+id/clash_button_radar"
        style="@style/Widget.AppCompat.Button.Borderless"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginEnd="16dp"
        android:src="@android:drawable/ic_menu_compass"
        android:contentDescription="@string/clash_button_radar_desc"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:tint="@color/kikko_honey_yellow" />

    <com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
        android:id="@+id/clash_button_start_solo"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/clash_button_start_solo"
        android:enabled="false"
        app:icon="@drawable/ic_swords"
        app:layout_constraintBottom_toTopOf="@id/clash_queen_status"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/clash_title"
        app:layout_constraintVertical_bias="0.9" />

    <LinearLayout
        android:id="@+id/player1_selection_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="4dp"
        android:layout_marginBottom="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toStartOf="@id/guideline_center">
        <FrameLayout android:id="@+id/p1_slot_food" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_food" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üçî" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_food" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p1_slot_plant" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_plant" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üåø" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_plant" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p1_slot_insect" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_insect" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üêû" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_insect" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p1_slot_bird" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_bird" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üê¶" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_bird" android:visibility="gone"/>
        </FrameLayout>
    </LinearLayout>
    <LinearLayout
        android:id="@+id/player2_selection_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="4dp"
        android:layout_marginBottom="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toEndOf="@id/guideline_center"
        app:layout_constraintEnd_toEndOf="parent">
        <FrameLayout android:id="@+id/p2_slot_food" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_food" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üçî" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_food" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p2_slot_plant" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_plant" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üåø" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_plant" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p2_slot_insect" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_insect" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üêû" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_insect" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p2_slot_bird" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_bird" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="üê¶" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_bird" android:visibility="gone"/>
        </FrameLayout>
    </LinearLayout>

    <TextView
        android:id="@+id/clash_queen_status"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:background="#A0000000"
        android:gravity="center"
        android:padding="4dp"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="12sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        tools:text="La Reine est pr√™te pour le jugement." />

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline_center"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintGuide_percent="0.5" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/p2p_panel"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:background="#E61C1C1E"
        android:elevation="16dp"
        android:translationX="2000dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintWidth_percent="0.5"
        tools:translationX="0dp">

        <be.heyman.android.ai.kikko.clash.ui.views.RadarView
            android:id="@+id/p2p_panel_radar_view"
            android:background="@drawable/radar_bourdon"
            android:layout_width="0dp"
            android:layout_height="0dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        <ImageButton
            android:id="@+id/p2p_panel_close_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_menu_close_clear_cancel"
            app:tint="@color/kikko_honey_yellow"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/p2p_panel_close_desc"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            android:layout_margin="8dp"/>

        <TextView
            android:id="@+id/p2p_panel_status_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_margin="16dp"
            android:gravity="center"
            android:textColor="@color/kikko_honey_yellow"
            app:layout_constraintBottom_toTopOf="@id/p2p_panel_recycler_view"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            tools:text="Recherche en cours..." />

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/p2p_panel_recycler_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="#99000000"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHeight_percent="0.4"
            app:layout_constraintStart_toStartOf="parent"
            tools:listitem="@layout/item_player_card" />

    </androidx.constraintlayout.widget.ConstraintLayout>

    <include
        layout="@layout/layout_card_selector_panel"
        android:id="@+id/card_selector_panel_include" />

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_clash_arena.xml ---


--- START OF FILE app/src/main/res/layout/activity_deck_selection.xml ---

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black">

    <VideoView
        android:id="@+id/background_video_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_alignParentBottom="true" />

    <FrameLayout
        android:id="@+id/main_content_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_above="@+id/bottom_navigation_bar" />

    <LinearLayout
        android:id="@+id/bottom_navigation_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="horizontal"
        android:elevation="8dp"
        android:weightSum="4">

        <!-- BOUTON 1: DECK -->
        <LinearLayout
            android:id="@+id/nav_button_deck"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Deck" />
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Deck"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>

        <!-- BOUTON 2: POLLEN -->
        <LinearLayout
            android:id="@+id/nav_button_pollen"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Pollen" />
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Pollen"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>

        <!-- BOUTON 3: RUCHE -->
        <LinearLayout
            android:id="@+id/nav_button_ruche"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Ruche"/>
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Ruche"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>

        <!-- BOUTON 4: CLASH -->
        <LinearLayout
            android:id="@+id/nav_button_clash"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Clash"/>
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Clash"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>
    </LinearLayout>

</RelativeLayout>

--- END OF FILE app/src/main/res/layout/activity_deck_selection.xml ---


--- START OF FILE app/src/main/res/layout/activity_deck_viewer.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black"
    tools:context=".deck.DeckViewerActivity">

    <VideoView
        android:id="@+id/background_video_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/top_guideline"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_percent="0.45" />

    <!-- BOURDON'S FIX: Augmentation du nombre de colonnes pour des cartes plus petites -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/deck_cards_recyclerview"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:clipToPadding="false"
        android:paddingStart="8dp"
        android:paddingEnd="8dp"
        android:paddingTop="8dp"
        android:paddingBottom="8dp"
        app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
        app:spanCount="3"
        app:layout_constraintTop_toTopOf="@id/top_guideline"
        app:layout_constraintBottom_toTopOf="@id/deck_selection_bar"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:listitem="@layout/item_clash_deck_thumbnail" />

    <LinearLayout
        android:id="@+id/deck_selection_bar"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:background="#A0000000"
        android:orientation="horizontal"
        android:paddingVertical="4dp"
        android:weightSum="4"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:id="@+id/deck_button_food"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_food_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_food"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_food"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/deck_button_plant"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_plant_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_plant"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_plant"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/deck_button_insect"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_insect_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_insect"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_insect"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/deck_button_bird"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_bird_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_bird"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_bird"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_deck_viewer.xml ---


--- START OF FILE app/src/main/res/layout/activity_forge_live.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".pollen.ForgeLiveActivity">

    <androidx.camera.view.PreviewView
        android:id="@+id/live_preview_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <ImageView
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:alpha="0.7"
        android:scaleType="centerCrop"
        android:src="@drawable/kikko_pollen"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:contentDescription="Fond d'√©cran de la forge de pollen" />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/captured_pollen_recyclerview"
        android:layout_width="0dp"
        android:layout_height="110dp"
        android:orientation="horizontal"
        android:clipToPadding="false"
        android:paddingStart="16dp"
        android:paddingEnd="16dp"
        android:paddingTop="8dp"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:listitem="@layout/item_pollen_preview"
        tools:visibility="visible"/>

    <LinearLayout
        android:id="@+id/bourdon_dialogue_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center_horizontal"
        android:padding="16dp"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintTop_toBottomOf="@id/captured_pollen_recyclerview"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <ImageView
                android:id="@+id/bourdon_avatar"
                android:layout_width="64dp"
                android:layout_height="64dp"
                android:src="@mipmap/ic_launcher"
                android:contentDescription="@string/bourdon_avatar_desc"/>

            <com.google.android.material.card.MaterialCardView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginStart="16dp"
                app:cardBackgroundColor="?attr/colorSurface"
                app:cardCornerRadius="12dp">

                <TextView
                    android:id="@+id/bourdon_message_textview"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:padding="12dp"
                    android:textAppearance="?attr/textAppearanceBodyLarge"
                    tools:text="@string/bourdon_message_placeholder"/>
            </com.google.android.material.card.MaterialCardView>
        </LinearLayout>

    </LinearLayout>

    <ToggleButton
        android:visibility="gone"
        android:id="@+id/facing_switch"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginStart="16dp"
        android:layout_marginBottom="16dp"
        android:background="@android:drawable/ic_menu_camera"
        android:contentDescription="@string/button_switch_camera_desc"
        android:textOff=""
        android:textOn=""
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent" />

    <LinearLayout
        android:id="@+id/capture_button_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:visibility="gone"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.95">

        <Button
            android:id="@+id/finish_harvest_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_finish_harvest"
            android:layout_marginEnd="8dp"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Button
            android:id="@+id/capture_and_forge_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/pollen_capture_button_default" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/final_choice_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.95">

        <Button
            android:id="@+id/restart_harvest_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_restart_harvest"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/send_to_hive_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_send_to_hive" />

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_forge_live.xml ---


--- START OF FILE app/src/main/res/layout/activity_forge_workshop.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".forge.ForgeWorkshopActivity">



    <!-- BOURDON'S REFORGE: Le contenu principal est maintenant dans un ConstraintLayout pour mieux g√©rer la barre du bas -->
    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <TextView
            android:id="@+id/workshop_status_message"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:background="?attr/colorSurface"
            android:gravity="center"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyMedium"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="3 grains de pollen attendent votre expertise." />

        <ProgressBar
            android:id="@+id/workshop_progress_bar"
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:indeterminate="true"
            android:visibility="gone"
            app:layout_constraintTop_toBottomOf="@id/workshop_status_message"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:visibility="visible" />

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/workshop_grains_recyclerview"
            android:layout_width="0dp"
            android:layout_height="150dp"
            android:clipToPadding="false"
            android:orientation="horizontal"
            android:padding="8dp"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            app:layout_constraintTop_toBottomOf="@id/workshop_progress_bar"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:listitem="@layout/item_pollen_grain_preview" />

        <com.google.android.material.divider.MaterialDivider
            android:id="@+id/workshop_divider"
            android:layout_width="0dp"
            android:layout_height="2dp"
            app:layout_constraintTop_toBottomOf="@id/workshop_grains_recyclerview"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <androidx.core.widget.NestedScrollView
            android:id="@+id/workshop_detail_container"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:visibility="gone"
            app:layout_constraintTop_toBottomOf="@id/workshop_divider"
            app:layout_constraintBottom_toTopOf="@id/workshop_filter_bar"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:visibility="visible">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <!-- Le contenu d√©taill√© du grain (image, nom, propri√©t√©s) reste identique -->
                <TextView
                    android:id="@+id/grain_id_label"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="end"
                    android:textAppearance="?attr/textAppearanceCaption"
                    tools:text="Grain ID: a1b2c3d4..."/>

                <com.google.android.material.card.MaterialCardView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">
                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:padding="8dp">
                        <ImageView
                            android:id="@+id/workshop_selected_image"
                            android:layout_width="100dp"
                            android:layout_height="100dp"
                            android:scaleType="centerCrop"
                            android:contentDescription="@string/workshop_selected_image_desc"
                            tools:src="@tools:sample/backgrounds/scenic"/>
                        <LinearLayout
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:orientation="vertical"
                            android:layout_marginStart="16dp">
                            <TextView
                                android:id="@+id/workshop_selected_name"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAppearance="?attr/textAppearanceTitleLarge"
                                tools:text="Dandelion"/>
                            <TextView
                                android:id="@+id/workshop_selected_deck"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAppearance="?attr/textAppearanceTitleSmall"
                                tools:text="Deck: Plant"/>

                            <Button
                                android:id="@+id/workshop_delete_grain_button"
                                style="?attr/materialButtonOutlinedStyle"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:layout_marginTop="8dp"
                                android:text="@string/workshop_button_reject_grain"
                                app:icon="@android:drawable/ic_menu_delete"
                                app:iconTint="?attr/colorError"
                                android:textColor="?attr/colorError"
                                app:strokeColor="?attr/colorError" />

                        </LinearLayout>
                    </LinearLayout>
                </com.google.android.material.card.MaterialCardView>

                <LinearLayout
                    android:id="@+id/workshop_properties_container"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="16dp" />

            </LinearLayout>
        </androidx.core.widget.NestedScrollView>

        <!-- BOURDON'S REFORGE: La nouvelle barre de filtres en bas -->
        <LinearLayout
            android:id="@+id/workshop_filter_bar"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:background="?attr/colorSurfaceContainer"
            android:orientation="horizontal"
            android:paddingVertical="4dp"
            android:elevation="4dp"
            android:weightSum="5"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent">

            <LinearLayout
                android:id="@+id/filter_button_raw"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/workshop_filter_raw_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_raw"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_raw"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_food"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_food_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_food"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_food"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_plant"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_plant_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_plant"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_plant"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_insect"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_insect_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_insect"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_insect"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_bird"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_bird_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_bird"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_bird"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>
        </LinearLayout>
    </androidx.constraintlayout.widget.ConstraintLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>

--- END OF FILE app/src/main/res/layout/activity_forge_workshop.xml ---


--- START OF FILE app/src/main/res/layout/activity_prompt_editor.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".prompt.PromptEditorActivity">

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/prompt_editor_appbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <!-- BOURDON'S DEFINITIVE FIX:
             - Le style est explicitement forc√© pour √©viter tout h√©ritage parasite.
             - Il n'y a AUCUN √©l√©ment enfant √† l'int√©rieur de cette balise. -->
        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/prompt_editor_toolbar"
            style="@style/Widget.Material3.Toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:menu="@menu/prompt_editor_menu"
            app:navigationIcon="@drawable/ic_close"
            app:title="@string/prompt_editor_title" />

    </com.google.android.material.appbar.AppBarLayout>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/prompt_selector_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="@string/prompt_selector_label"
                android:textAppearance="?attr/textAppearanceLabelLarge" />

            <Spinner
                android:id="@+id/prompt_selector_spinner"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"

                android:minHeight="48dp" />

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/prompt_editor_layout"
                style="?attr/textInputOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/prompt_editor_hint">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/prompt_editor_edittext"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="top"
                    android:inputType="textMultiLine"
                    android:minHeight="300dp"
                    android:scrollbars="vertical"
                    android:textColor="@color/kikko_gold"
                    android:typeface="monospace" />

            </com.google.android.material.textfield.TextInputLayout>

            <Button
                android:id="@+id/prompt_editor_save_button"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:text="@string/button_save_prompts"
                app:icon="@android:drawable/ic_menu_save" />

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

</androidx.coordinatorlayout.widget.CoordinatorLayout>

--- END OF FILE app/src/main/res/layout/activity_prompt_editor.xml ---


--- START OF FILE app/src/main/res/layout/activity_quiz.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".quiz.QuizActivity">

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/quiz_appbar"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/quiz_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:navigationIcon="@drawable/ic_close"
            tools:title="Quiz : Abeille Domestique" />
    </com.google.android.material.appbar.AppBarLayout>

    <TextView
        android:id="@+id/quiz_progress_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="24dp"
        android:textAppearance="?attr/textAppearanceTitleMedium"
        app:layout_constraintTop_toBottomOf="@id/quiz_appbar"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:text="Question 1 / 4" />

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/quiz_question_card"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        app:layout_constraintTop_toBottomOf="@id/quiz_progress_textview"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <TextView
            android:id="@+id/quiz_question_textview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="16dp"
            android:minHeight="100dp"
            android:gravity="center"
            android:textAppearance="?attr/textAppearanceHeadlineSmall"
            tools:text="Quelle est la vitesse de vol moyenne d'une abeille ?" />
    </com.google.android.material.card.MaterialCardView>

    <RadioGroup
        android:id="@+id/quiz_answers_radiogroup"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        app:layout_constraintTop_toBottomOf="@id/quiz_question_card"
        app:layout_constraintStart_toStartOf="@id/quiz_question_card"
        app:layout_constraintEnd_toEndOf="@id/quiz_question_card">

        <RadioButton
            android:id="@+id/quiz_answer_1"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="10 km/h" />

        <RadioButton
            android:id="@+id/quiz_answer_2"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="24 km/h" />

        <RadioButton
            android:id="@+id/quiz_answer_3"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="40 km/h" />

        <RadioButton
            android:id="@+id/quiz_answer_4"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="5 km/h" />
    </RadioGroup>

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/quiz_feedback_card"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginHorizontal="16dp"
        android:layout_marginBottom="16dp"
        android:visibility="gone"
        tools:visibility="visible"
        app:cardBackgroundColor="@color/kikko_leaf_green"
        app:layout_constraintBottom_toTopOf="@id/quiz_submit_button"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">
        <TextView
            android:id="@+id/quiz_feedback_textview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="16dp"
            android:gravity="center"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            android:textColor="?attr/colorOnPrimaryContainer"
            tools:text="Bonne r√©ponse !"/>
    </com.google.android.material.card.MaterialCardView>

    <Button
        android:id="@+id/quiz_submit_button"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Valider"
        android:layout_margin="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <Button
        android:id="@+id/quiz_next_button"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Question Suivante"
        android:visibility="gone"
        android:layout_margin="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_quiz.xml ---


--- START OF FILE app/src/main/res/layout/activity_royal_audience.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S REFORGE V3: Remplacement par RelativeLayout pour une gestion robuste du clavier avec adjustResize -->
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/audience_root_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".royal_audience.RoyalAudienceActivity">

    <androidx.media3.ui.PlayerView
        android:id="@+id/audience_background_video_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:resize_mode="zoom"
        app:use_controller="false" />

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/audience_app_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:color/transparent"
        android:fitsSystemWindows="true"
        app:elevation="0dp">

        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/audience_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize">

            <androidx.constraintlayout.widget.ConstraintLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent">

                <ImageButton
                    android:id="@+id/audience_back_button"
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:src="?attr/homeAsUpIndicator"
                    android:background="?attr/selectableItemBackgroundBorderless"
                    android:contentDescription="@string/audience_button_back_description"
                    app:tint="?attr/colorOnSurface"
                    app:layout_constraintStart_toStartOf="parent"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintBottom_toBottomOf="parent"/>

                <LinearLayout
                    android:id="@+id/audience_model_selector_container"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:gravity="center_horizontal"
                    android:background="?attr/selectableItemBackground"
                    android:clickable="true"
                    android:focusable="true"
                    android:paddingStart="16dp"
                    android:paddingEnd="16dp"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintBottom_toBottomOf="parent"
                    app:layout_constraintStart_toStartOf="parent"
                    app:layout_constraintEnd_toEndOf="parent">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/audience_toolbar_title"
                        android:textAppearance="?attr/textAppearanceLabelMedium"
                        android:textColor="?attr/colorOnSurfaceVariant"/>

                    <LinearLayout
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:gravity="center_vertical">

                        <ImageView
                            android:layout_width="16dp"
                            android:layout_height="16dp"
                            android:src="@drawable/ic_circle_dot"
                            app:tint="?attr/colorPrimary"/>

                        <TextView
                            android:id="@+id/audience_model_name"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:layout_marginStart="4dp"
                            android:textAppearance="?attr/textAppearanceTitleSmall"
                            android:textColor="?attr/colorOnSurface"
                            tools:text="Qwen2.5-1.5B-Instruct q8" />

                    </LinearLayout>
                </LinearLayout>

                <ImageButton
                    android:id="@+id/audience_settings_button"
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:src="@drawable/ic_settings_sliders"
                    android:background="?attr/selectableItemBackgroundBorderless"
                    android:contentDescription="@string/audience_button_settings_description"
                    app:layout_constraintEnd_toEndOf="parent"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintBottom_toBottomOf="parent"/>

            </androidx.constraintlayout.widget.ConstraintLayout>

        </com.google.android.material.appbar.MaterialToolbar>
    </com.google.android.material.appbar.AppBarLayout>

    <include
        android:id="@+id/audience_input_bar"
        layout="@layout/layout_chat_input_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true" />

    <FrameLayout
        android:id="@+id/audience_image_preview_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_above="@id/audience_input_bar"
        android:visibility="gone"
        tools:visibility="visible">
    </FrameLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/audience_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/audience_app_bar"
        android:layout_above="@id/audience_image_preview_container"
        android:clipToPadding="false"
        android:padding="8dp"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        tools:listitem="@layout/item_chat_queen" />

</RelativeLayout>

--- END OF FILE app/src/main/res/layout/activity_royal_audience.xml ---


--- START OF FILE app/src/main/res/layout/activity_start.xml ---

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black"
    tools:context=".StartActivity">

    <!-- Le reste du fichier est identique -->

    <VideoView
        android:id="@+id/background_video_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_alignParentBottom="true" />

    <!-- BOURDON'S FIX: Ajout d'un ID au conteneur principal pour la gestion des insets -->
    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/start_root_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <TextView
            android:id="@+id/start_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="32dp"
            android:fontFamily="@font/luckiest_guy"
            android:text="KiKKo's\nSaga Forge"
            android:textAlignment="center"
            android:textColor="@color/kikko_honey_yellow"
            android:textSize="40sp"
            android:shadowColor="@color/kikko_bark_brown"
            android:shadowDx="2"
            android:shadowDy="2"
            android:shadowRadius="3"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        <ImageButton
            android:id="@+id/start_button_tools"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:layout_margin="16dp"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="Outils"
            android:src="@android:drawable/ic_menu_manage"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:tint="@color/kikko_honey_yellow" />


        <LinearLayout
            android:id="@+id/bottom_navigation_bar"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:orientation="horizontal"
            android:weightSum="4"
            app:layout_constraintBottom_toTopOf="@id/status_counters_container"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent">

            <LinearLayout
                android:id="@+id/button_kikko"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@android:drawable/ic_menu_gallery"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Decks"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Decks"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/button_pollen"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@android:drawable/ic_menu_camera"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Pollen Live"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Pollen Live"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/button_forge"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@android:drawable/ic_menu_manage"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Forge"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Forge"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/button_clash"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@drawable/ic_swords"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Clash"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Clash"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:id="@+id/status_counters_container"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:orientation="horizontal"
            android:gravity="center"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent">

            <TextView
                android:id="@+id/raw_pollen_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="Brut: 12" />

            <TextView
                android:id="@+id/in_forge_pollen_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="En Forge: 5" />

            <TextView
                android:id="@+id/total_honey_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="Miel: 152" />

            <TextView
                android:id="@+id/error_pollen_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:textColor="@color/kikko_error_red"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="Erreurs: 2" />

        </LinearLayout>

    </androidx.constraintlayout.widget.ConstraintLayout>

</RelativeLayout>

--- END OF FILE app/src/main/res/layout/activity_start.xml ---


--- START OF FILE app/src/main/res/layout/dialog_audience_settings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Un nouveau dialogue pour configurer la Reine de l'Audience. -->
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="D√©crets de la Reine"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_marginBottom="20dp"/>

    <TextView
        android:id="@+id/audience_settings_temperature_label"
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Temp√©rament (Cr√©ativit√©)"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.slider.Slider
        android:id="@+id/audience_settings_temperature_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:valueFrom="0.0"
        android:valueTo="1.0"
        android:stepSize="0.01"
        android:value="0.20"
        android:layout_marginBottom="16dp"/>

    <TextView
        android:id="@+id/audience_settings_topk_label"
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Focalisation (Top-K)"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.slider.Slider
        android:id="@+id/audience_settings_topk_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:valueFrom="1"
        android:valueTo="100"
        android:stepSize="1"
        android:value="40"
        android:layout_marginBottom="24dp"/>

    <Button
        android:id="@+id/audience_settings_confirm_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Confirmer les D√©crets"/>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_audience_settings.xml ---


--- START OF FILE app/src/main/res/layout/dialog_card_details.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurface">



    <androidx.core.widget.NestedScrollView
        android:id="@+id/card_details_scrollview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="24dp">

            <ImageView
                android:id="@+id/card_details_image"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic" />

            <TextView
                android:id="@+id/card_details_specific_name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:textAppearance="?attr/textAppearanceHeadline5"
                tools:text="Specific Name" />

            <com.google.android.material.chip.Chip
                android:id="@+id/card_details_deck_name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:chipIcon="@drawable/ic_folder"
                tools:text="Deck Name" />

            <TextView
                android:id="@+id/card_details_confidence"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceCaption"
                tools:text="Confidence: 0.99" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:text="@string/card_details_description_title"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <TextView
                android:id="@+id/card_details_description"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:textAppearance="?attr/textAppearanceBody2"
                tools:text="This is a detailed description of the card's subject, containing interesting facts and origins." />

            <TextView
                android:id="@+id/card_details_stats"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:lineSpacingExtra="4dp"
                android:textAppearance="?attr/textAppearanceBodyMedium"
                android:textStyle="bold"
                tools:text="Stat 1: Value 1\nStat 2: Value 2" />

            <TextView
                android:id="@+id/card_details_reasoning"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:textAppearance="?attr/textAppearanceBody2"
                android:textStyle="italic"
                tools:text="Visual Analysis: ...\nEvidence Correlation: ..." />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="80dp"
                android:orientation="horizontal">

                <Button
                    android:id="@+id/card_details_button_delete"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:text="@string/card_details_button_delete"
                    app:icon="@android:drawable/ic_menu_delete" />

                <Button
                    android:id="@+id/card_details_button_quiz"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="8dp"
                    android:text="@string/card_details_button_quiz"
                    android:visibility="gone"
                    app:icon="@drawable/ic_dice" />
            </LinearLayout>

        </LinearLayout>
    </androidx.core.widget.NestedScrollView>

    <LinearLayout
        android:id="@+id/card_details_footer_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp"
        android:background="?attr/colorSurfaceContainer"
        android:elevation="8dp"
        android:layout_gravity="bottom">

        <Button
            android:id="@+id/card_details_button_translate"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/card_details_button_translate"
            android:visibility="gone"
            tools:visibility="visible"
            app:icon="@android:drawable/ic_menu_rotate"/>

        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1"/>

        <Button
            android:id="@+id/card_details_button_chat"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/card_details_button_chat"
            app:icon="@drawable/chat_spark" />
    </LinearLayout>

</androidx.coordinatorlayout.widget.CoordinatorLayout>

--- END OF FILE app/src/main/res/layout/dialog_card_details.xml ---


--- START OF FILE app/src/main/res/layout/dialog_card_selection.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="?attr/colorSurfaceContainer">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/card_selection_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:title="S√©lectionnez votre Champion"
            app:navigationIcon="@drawable/ic_close" />

    </com.google.android.material.appbar.AppBarLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp"
        android:gravity="center_vertical">

        <com.google.android.material.textfield.TextInputLayout
            style="?attr/textInputFilledStyle"
            android:id="@+id/card_selection_search_layout"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Rechercher par nom..."
            app:endIconMode="clear_text">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/card_selection_search_edittext"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:imeOptions="actionSearch"
                android:inputType="text"/>

        </com.google.android.material.textfield.TextInputLayout>

        <Spinner
            android:id="@+id/card_selection_sort_spinner"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:prompt="@string/sort_by_prompt"
            tools:listitem="@android:layout/simple_spinner_dropdown_item" />

    </LinearLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/card_selection_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:padding="8dp"
        android:clipToPadding="false"
        tools:listitem="@layout/item_card_preview"
        app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
        app:spanCount="3" />

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_card_selection.xml ---


--- START OF FILE app/src/main/res/layout/dialog_clash_setup.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Pr√©paration au Clash"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_marginBottom="20dp"/>

    <TextView
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="S√©lection de la Reine IA"
        android:layout_marginBottom="8dp"/>

    <Spinner
        android:id="@+id/clash_setup_model_spinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="16dp" />

    <TextView
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Choix du Cerveau"
        android:layout_marginBottom="8dp"/>

    <RadioGroup
        android:id="@+id/clash_setup_accelerator_radiogroup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginBottom="16dp">

        <RadioButton
            android:id="@+id/clash_setup_cpu_radio"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="CPU (Stable)"
            android:checked="true"/>

        <RadioButton
            android:id="@+id/clash_setup_gpu_radio"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:text="GPU (Rapide)"/>
    </RadioGroup>

    <TextView
        android:id="@+id/clash_setup_temperature_label"
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Temp√©rament du Juge (0.20)"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.slider.Slider
        android:id="@+id/clash_setup_temperature_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:valueFrom="0.0"
        android:valueTo="1.0"
        android:stepSize="0.01"
        android:value="0.20"
        android:layout_marginBottom="16dp"/>

    <TextView
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Options Audio"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/clash_setup_tts_switch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Activer la lecture des verdicts"
        android:checked="true"
        android:layout_marginBottom="24dp"/>


    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <CheckBox
            android:id="@+id/clash_setup_dont_show_again_checkbox"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Ne plus afficher cette fen√™tre au d√©marrage"/>

        <Button
            android:id="@+id/clash_setup_confirm_button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:text="Acc√©der √† l'Ar√®ne"/>
    </LinearLayout>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_clash_setup.xml ---


--- START OF FILE app/src/main/res/layout/dialog_judgment.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurface"
    android:orientation="vertical">

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/judgment_section_title_deliberation"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <!-- BOURDON'S DEFINITIVE FIX: Utilisation des attributs de couleur d'erreur existants. -->
            <com.google.android.material.card.MaterialCardView
                android:id="@+id/judgment_warning_card"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                app:cardBackgroundColor="?attr/colorErrorContainer"
                app:strokeColor="?attr/colorError"
                app:strokeWidth="1dp"
                android:visibility="gone"
                tools:visibility="visible">

                <TextView
                    android:id="@+id/judgment_warning_text"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:padding="12dp"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:textColor="?attr/colorOnErrorContainer"
                    app:drawableStartCompat="@android:drawable/ic_dialog_alert"
                    app:drawableTint="?attr/colorOnErrorContainer"
                    android:drawablePadding="8dp"
                    tools:text="Attention : 2 sur 4 Reines ont termin√©. Votre jugement sera bas√© sur des preuves partielles." />

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                app:cardBackgroundColor="?attr/colorSurfaceContainerHigh">

                <TextView
                    android:id="@+id/judgment_streaming_response"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:minHeight="150dp"
                    android:padding="12dp"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:typeface="monospace"
                    tools:text="[La d√©lib√©ration en direct de la Reine Arbitre appara√Ætra ici...]" />

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginVertical="24dp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/judgment_section_title_decree"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <TextView
                android:id="@+id/judgment_prompt_content"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:typeface="monospace"
                tools:text="[Le prompt complet envoy√© √† la Reine Arbitre sera affich√© ici pour une transparence totale.]" />

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginVertical="24dp" />

            <TextView
                android:id="@+id/judgment_evidence_title"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/judgment_section_title_evidence"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <TextView
                android:id="@+id/judgment_evidence_content"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:typeface="monospace"
                android:visibility="gone"
                tools:visibility="visible"
                tools:text="[Le rapport d'essaim et la liste des propositions des Reines seront affich√©s ici.]" />

        </LinearLayout>
    </androidx.core.widget.NestedScrollView>

    <LinearLayout
        android:id="@+id/judgment_actions_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/colorSurfaceContainer"
        android:elevation="8dp"
        android:orientation="horizontal"
        android:padding="16dp">

        <Button
            android:id="@+id/judgment_button_override"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/judgment_button_override" />

        <Button
            android:id="@+id/judgment_button_confirm"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_weight="1"
            android:enabled="false"
            android:text="@string/judgment_button_confirm" />
    </LinearLayout>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_judgment.xml ---


--- START OF FILE app/src/main/res/layout/dialog_queen_selector.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Le layout pour le dialogue de s√©lection de la Reine. -->
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp"
    android:minWidth="320dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Choisir la Reine"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_marginBottom="16dp"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/queen_selector_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:maxHeight="400dp"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        tools:listitem="@layout/item_queen_model_selection"
        tools:itemCount="3"/>

    <TextView
        android:id="@+id/queen_selector_empty_state"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Aucune Reine IA n'est disponible. Veuillez en ajouter via les Outils."
        android:gravity="center"
        android:padding="16dp"
        android:visibility="gone"
        tools:visibility="visible"/>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_queen_selector.xml ---


--- START OF FILE app/src/main/res/layout/dialog_specialist_report.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="#333333">

    <TextView
        android:id="@+id/dialog_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Rapport du Sp√©cialiste"
        android:textColor="@android:color/white"
        android:textSize="18sp"
        android:textStyle="bold"
        android:layout_gravity="center_horizontal"/>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/format_switch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Voir en JSON"
        android:textColor="@android:color/white"
        android:layout_gravity="center_horizontal"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="400dp"
        android:layout_marginTop="16dp"
        android:background="#222222"
        android:padding="8dp">

        <TextView
            android:id="@+id/report_content_textview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@android:color/white"
            android:textSize="12sp"
            android:fontFamily="monospace"/>

    </ScrollView>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_specialist_report.xml ---


--- START OF FILE app/src/main/res/layout/dialog_tools.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="8dp"
    android:minWidth="360dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/tools_dialog_title"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_gravity="center_horizontal"
        android:layout_marginBottom="16dp"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_active_queen_forge"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/tools_recyclerview_queen_selector"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:maxHeight="180dp"
                android:background="@drawable/scroll_background"
                android:padding="8dp"
                tools:listitem="@layout/item_queen_model_selection"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                android:layout_marginBottom="8dp"/>

            <TextView
                style="?attr/textAppearanceBodyMedium"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_queen_accelerator"
                android:layout_marginTop="8dp"/>
            <RadioGroup
                android:id="@+id/tools_radiogroup_queen_accelerator"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">
                <RadioButton
                    android:id="@+id/tools_radio_cpu"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/tools_accelerator_cpu" />
                <RadioButton
                    android:id="@+id/tools_radio_gpu"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="16dp"
                    android:text="@string/tools_accelerator_gpu"
                    android:checked="true"/>
            </RadioGroup>

            <!-- BOURDON'S REFACTOR: Section Vosk mise en sommeil -->
            <LinearLayout
                android:id="@+id/vosk_section_container"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:visibility="gone"
                tools:visibility="gone">

                <com.google.android.material.divider.MaterialDivider
                    android:layout_width="match_parent"
                    android:layout_height="1dp"
                    android:layout_marginTop="16dp"
                    android:layout_marginBottom="16dp"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/tools_voice_recognition"
                    android:textAppearance="?attr/textAppearanceTitleMedium"
                    android:layout_marginBottom="8dp"/>

                <androidx.recyclerview.widget.RecyclerView
                    android:id="@+id/tools_recyclerview_vosk_models"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:maxHeight="180dp"
                    android:background="@drawable/scroll_background"
                    android:padding="8dp"
                    tools:listitem="@layout/item_vosk_model"
                    app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                    android:layout_marginBottom="8dp"/>

                <TextView
                    android:id="@+id/vosk_result_textview"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:minHeight="80dp"
                    android:padding="8dp"
                    android:background="@drawable/scroll_background"
                    android:textIsSelectable="true"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:layout_marginBottom="8dp"
                    android:visibility="gone"
                    tools:visibility="visible"
                    tools:text="Appuyez sur 'play' pour commencer l'√©coute..."/>

                <Button
                    android:id="@+id/tools_button_import_vosk_model"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/tools_button_load_vosk"
                    app:icon="@android:drawable/ic_menu_add" />
            </LinearLayout>

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_forge_settings"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/tools_switch_require_charging"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_forge_require_charging" />

            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/tools_switch_require_idle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_forge_require_idle" />

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="16dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_manage_local_queens"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/tools_recyclerview_models"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:maxHeight="250dp"
                android:background="@drawable/scroll_background"
                android:padding="8dp"
                tools:listitem="@layout/item_local_model"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"/>

            <Button
                android:id="@+id/tools_button_add_model"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/tools_button_add_queen"
                app:icon="@android:drawable/ic_menu_add" />

            <Button
                android:id="@+id/tools_button_download_models"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/tools_button_download_more_queens"
                app:icon="@android:drawable/ic_menu_gallery" />


            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_saga_management"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">

                <Button
                    android:id="@+id/tools_button_import_saga"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:layout_marginEnd="8dp"
                    android:text="@string/tools_button_import_saga"
                    app:icon="@android:drawable/ic_menu_save"/>

                <Button
                    android:id="@+id/tools_button_export_saga"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/tools_button_export_saga"
                    app:icon="@android:drawable/ic_menu_upload"/>
            </LinearLayout>

            <Button
                android:id="@+id/tools_button_download_decks"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/tools_button_download_decks"
                app:icon="@android:drawable/ic_menu_gallery" />

            <!-- BOURDON'S ADDITION: Section pour la gestion des prompts -->
            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_prompt_management_title"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <Button
                android:id="@+id/tools_button_manage_prompts"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_button_manage_prompts"
                app:icon="@android:drawable/ic_menu_edit" />


            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_danger_zone"
                android:textColor="?attr/colorError"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <Button
                android:id="@+id/tools_button_nuke_db"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_button_nuke_db"
                app:icon="@android:drawable/ic_delete"
                app:backgroundTint="?attr/colorErrorContainer"
                android:textColor="?attr/colorOnErrorContainer"/>
        </LinearLayout>
    </ScrollView>
</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_tools.xml ---


--- START OF FILE app/src/main/res/layout/fragment_deck_page.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    tools:context=".deck.DeckPageFragment">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/deck_page_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:padding="8dp"
        android:clipToPadding="false"
        app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
        app:spanCount="2"
        tools:listitem="@layout/item_card_preview" />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/fragment_deck_page.xml ---


--- START OF FILE app/src/main/res/layout/fragment_duel_page.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S FINAL & CORRECTED REFORGE: This is the definitive version. -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".clash.ui.ClashDuelFragment">

    <!-- La vid√©o de fond, g√©r√©e par ExoPlayer pour un rendu parfait -->
    <androidx.media3.ui.PlayerView
        android:id="@+id/duel_background_video_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:resize_mode="zoom"
        app:use_controller="false"/>

    <!-- La question, toujours au sommet -->
    <TextView
        android:id="@+id/duel_question_textview"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:gravity="center"
        android:fontFamily="@font/luckiest_guy"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="22sp"
        android:shadowColor="@color/black"
        android:shadowDx="1"
        android:shadowDy="1"
        android:shadowRadius="2"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="Quel aliment a un indice glyc√©mique plus bas ?" />

    <include
        android:id="@+id/duel_player1_card"
        layout="@layout/item_clash_champion_card"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:rotation="-30"
        app:layout_constraintDimensionRatio="W,1.4"
        app:layout_constraintBottom_toTopOf="@id/guideline_bottom_cards"
        app:layout_constraintEnd_toStartOf="@+id/guideline_middle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/duel_question_textview"
        app:layout_constraintWidth_percent="0.20"
        app:layout_constraintVertical_bias="0.4" />

    <TextView
        android:id="@+id/duel_vs_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:fontFamily="@font/luckiest_guy"
        android:shadowColor="@color/black"
        android:shadowDx="2"
        android:shadowDy="2"
        android:shadowRadius="3"
        android:text="@string/clash_duel_vs"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="48sp"
        app:layout_constraintBottom_toBottomOf="@id/duel_player1_card"
        app:layout_constraintEnd_toStartOf="@id/duel_player2_card"
        app:layout_constraintStart_toEndOf="@id/duel_player1_card"
        app:layout_constraintTop_toTopOf="@id/duel_player1_card" />

    <include
        android:id="@+id/duel_player2_card"
        layout="@layout/item_clash_champion_card"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:rotation="30"
        app:layout_constraintDimensionRatio="W,1.4"
        app:layout_constraintBottom_toBottomOf="@id/duel_player1_card"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/guideline_middle"
        app:layout_constraintTop_toTopOf="@id/duel_player1_card"
        app:layout_constraintWidth_percent="0.20" />

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline_middle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintGuide_percent="0.5" />

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline_bottom_cards"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_percent="0.65" />


    <ScrollView
        android:id="@+id/duel_reasoning_scrollview"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="8dp"
        app:layout_constraintBottom_toTopOf="@id/duel_navigation_container"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/guideline_bottom_cards">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:gravity="center_horizontal">

            <TextView
                android:id="@+id/duel_streaming_reasoning_textview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="@drawable/debug_border"
                android:padding="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:textColor="@color/kikko_honey_yellow"
                android:visibility="gone"
                tools:text="Streaming tokens from the judge will appear here..." />

            <TextView
                android:id="@+id/duel_reasoning_textview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:gravity="center"
                android:visibility="invisible"
                android:fontFamily="@font/luckiest_guy"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="20sp"
                android:shadowColor="@color/black"
                android:shadowDx="1"
                android:shadowDy="1"
                android:shadowRadius="2"
                tools:text="L'HONEY A UN INDICE GLYC√âMIQUE PLUS BAS..."
                tools:visibility="visible" />
        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/duel_navigation_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/duel_previous_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/clash_duel_button_previous"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Space
            android:id="@+id/duel_nav_spacer"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:visibility="gone"
            tools:visibility="visible"/>

        <com.google.android.material.progressindicator.CircularProgressIndicator
            android:id="@+id/duel_loading_indicator"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:indeterminate="true"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Button
            android:id="@+id/duel_next_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/clash_duel_button_next"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Button
            android:id="@+id/duel_finish_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/clash_duel_button_finish"
            android:visibility="gone"
            tools:visibility="visible"/>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/fragment_duel_page.xml ---


--- START OF FILE app/src/main/res/layout/item_analysis_result.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginBottom="8dp"
    app:cardElevation="1dp"
    app:strokeWidth="1dp"
    app:strokeColor="?attr/colorOutlineVariant">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <!-- BOURDON'S REFORGE: Cet en-t√™te est maintenant la zone cliquable pour d√©plier -->
        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/analysis_header_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="12dp"
            android:background="?attr/selectableItemBackground">

            <TextView
                android:id="@+id/analysis_model_config"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:textColor="@color/black"
                android:textSize="14dp"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toStartOf="@id/analysis_status_chip"
                android:layout_marginEnd="8dp"
                tools:text="gemma-3n-E2B (GPU, T:0.9)" />

            <com.google.android.material.chip.Chip
                android:id="@+id/analysis_status_chip"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                tools:text="COMPLETED" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <!-- BOURDON'S REFORGE: Ce conteneur sera cach√©/affich√© -->
        <LinearLayout
            android:id="@+id/analysis_details_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            android:paddingBottom="12dp"
            android:visibility="gone"
            tools:visibility="visible">

            <TextView
                android:id="@+id/analysis_error_message"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:textColor="?attr/colorError"
                android:visibility="gone"
                tools:visibility="visible"
                tools:text="Error: Inference failed due to invalid parameters."/>

            <TextView
                android:id="@+id/analysis_raw_response"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textSize="12sp"
                android:padding="8dp"
                android:background="@color/black"
                android:textColor="@color/kikko_honey_yellow"
                android:typeface="monospace"
                android:textIsSelectable="true"
                android:visibility="gone"
                tools:visibility="visible"
                tools:text="{ 'description': 'A dandelion is...', 'stats': {...} }"/>

            <HorizontalScrollView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:scrollbars="none">

                <LinearLayout
                    android:id="@+id/analysis_actions_container"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="end">

                    <Button
                        android:id="@+id/analysis_validate_button"
                        style="?attr/materialButtonStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Valider"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_set_as" />

                    <Button
                        android:id="@+id/analysis_view_error_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Voir Erreur"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_info_details" />

                    <Button
                        android:id="@+id/analysis_retry_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Relancer"
                        android:layout_marginStart="8dp"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_revert" />

                    <Button
                        android:id="@+id/analysis_run_button"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Lancer"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_media_play" />

                    <Button
                        android:id="@+id/analysis_pause_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Pause"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_media_pause" />

                    <Button
                        android:id="@+id/analysis_cancel_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="8dp"
                        android:text="Annuler"
                        app:iconTint="?attr/colorError"
                        android:textColor="?attr/colorError"
                        app:strokeColor="?attr/colorError"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_close_clear_cancel" />
                </LinearLayout>
            </HorizontalScrollView>
        </LinearLayout>
    </LinearLayout>
</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_analysis_result.xml ---


--- START OF FILE app/src/main/res/layout/item_card_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="140dp"
    android:layout_height="180dp"
    android:layout_margin="8dp"
    app:cardElevation="4dp"
    app:cardCornerRadius="12dp">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_preview_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Illustration du champion" />

        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_bottom_dark"
            app:layout_constraintHeight_percent="0.4"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_preview_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@color/white"
            android:layout_marginStart="8dp"
            android:layout_marginEnd="8dp"
            android:layout_marginBottom="8dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Kikko Cookies" />

        <TextView
            android:id="@+id/card_preview_stats"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"
            tools:visibility="gone"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"/>

        <View
            android:id="@+id/card_preview_loser_veil"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="#99000000"
            android:visibility="gone"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_card_preview.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_card_context.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="280dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        app:cardElevation="4dp"
        app:cardCornerRadius="12dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <ImageView
                android:id="@+id/chat_card_image"
                android:layout_width="match_parent"
                android:layout_height="180dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic"
                android:contentDescription="Image de la carte en cours de discussion" />

            <TextView
                android:id="@+id/chat_card_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:paddingHorizontal="16dp"
                android:paddingTop="12dp"
                tools:text="Sujet de la Carte" />

            <ScrollView
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:paddingHorizontal="16dp"
                android:paddingVertical="8dp">

                <TextView
                    android:id="@+id/chat_card_description"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:textColor="?attr/colorOnSurfaceVariant"
                    tools:text="Ceci est une description d√©taill√©e de la carte qui peut √™tre assez longue et n√©cessiter un d√©filement pour √™tre lue en entier." />
            </ScrollView>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>
</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_card_context.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_queen.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="4dp"
    android:paddingStart="8dp"
    android:paddingEnd="64dp" android:alpha="0.8">

    <TextView
        android:id="@+id/chat_queen_message_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="start"
        android:background="@color/black"
        android:elevation="2dp"
        android:paddingHorizontal="16dp"
        android:paddingVertical="10dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        android:textColor="@color/kikko_gold"
        tools:text="D'apr√®s les informations de la carte, cette plante n'est pas r√©pertori√©e comme toxique." />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_queen.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_user.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="4dp"
    android:paddingStart="64dp"
    android:paddingEnd="8dp" android:alpha="0.8">

    <TextView
        android:id="@+id/chat_user_message_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:background="@color/kikko_gold"
        android:elevation="2dp"
        android:paddingHorizontal="16dp"
        android:paddingVertical="10dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        android:textColor="@color/black"
        tools:text="Est-ce que cette plante est toxique pour les chats ?" />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_user.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_user_with_image.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Un nouveau layout pour les messages utilisateur contenant une image. -->
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="4dp"
    android:paddingStart="64dp"
    android:paddingEnd="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        app:cardBackgroundColor="@color/kikko_gold"
        app:cardCornerRadius="18dp"
        app:cardElevation="2dp">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:maxWidth="280dp">

            <ImageView
                android:id="@+id/chat_user_imageview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:adjustViewBounds="true"
                android:maxHeight="250dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic"
                android:contentDescription="Image jointe par l'utilisateur" />

            <TextView
                android:id="@+id/chat_user_message_textview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingHorizontal="16dp"
                android:paddingVertical="10dp"
                android:textAppearance="?attr/textAppearanceBodyMedium"
                android:textColor="@color/black"
                tools:text="Regarde cette fleur, est-ce que tu la reconnais ?" />

        </LinearLayout>
    </com.google.android.material.card.MaterialCardView>
</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_user_with_image.xml ---


--- START OF FILE app/src/main/res/layout/item_clash_champion_card.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S REFORGE: Le design est maintenant inspir√© du thumbnail pour une esth√©tique sup√©rieure. -->
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:cardCornerRadius="12dp"
    app:cardElevation="8dp"
    app:cardUseCompatPadding="true"
    app:cardBackgroundColor="@android:color/black">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Image du champion" />

        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.5"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_deck_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="12dp"
            android:layout_marginBottom="4dp"
            android:textAppearance="?attr/textAppearanceLabelMedium"
            android:textColor="@color/kikko_honey_yellow"
            android:alpha="0.9"
            app:layout_constraintBottom_toTopOf="@id/card_title"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Food" android:visibility="gone"/>
        <ImageView
            android:layout_width="match_parent" android:scaleType="fitXY"
            android:layout_height="match_parent" android:src="@drawable/kikko_pollen"/>

        <TextView
            android:id="@+id/card_title"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            android:layout_marginHorizontal="12dp"
            android:layout_marginBottom="12dp"
            android:maxLines="3"
            android:ellipsize="end"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Haribo Haribo Haribo" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_clash_champion_card.xml ---


--- START OF FILE app/src/main/res/layout/item_clash_champion_thumbnail.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:cardCornerRadius="8dp"
    app:cardElevation="2dp"
    app:cardUseCompatPadding="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_thumbnail_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Vignette du champion s√©lectionn√©" />
<ImageView
    android:layout_width="match_parent" android:scaleType="fitXY"
    android:layout_height="match_parent" android:src="@drawable/kikko_pollen"/>
        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.6"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_thumbnail_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            android:layout_marginHorizontal="4dp"
            android:layout_marginBottom="4dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal|bottom"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Nom Tr√®s Long du Champion de la Mort" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_clash_champion_thumbnail.xml ---


--- START OF FILE app/src/main/res/layout/item_clash_deck_thumbnail.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="120dp"
    android:layout_height="160dp"
    app:cardCornerRadius="8dp"
    app:cardElevation="2dp"
    app:cardUseCompatPadding="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_thumbnail_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Vignette du champion s√©lectionn√©" />
        <ImageView
            android:layout_width="match_parent" android:scaleType="fitXY"
            android:layout_height="match_parent" android:src="@drawable/kikko_pollen"/>
        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.6"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_thumbnail_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            android:layout_marginHorizontal="4dp"
            android:layout_marginBottom="4dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal|bottom"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Nom Tr√®s Long du Champion de la Mort" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_clash_deck_thumbnail.xml ---


--- START OF FILE app/src/main/res/layout/item_competition_summary.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: La "St√®le des Propositions" pour l'Atelier. -->
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginBottom="8dp"
    app:cardElevation="0dp"
    app:strokeWidth="1dp"
    app:strokeColor="?attr/colorPrimary">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:padding="12dp">

        <TextView
            android:id="@+id/summary_response_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:textColor="@color/black"
            android:textSize="14dp"
            tools:text="3 Reines proposent : &quot;Plant: Dandelion&quot;" />

        <Button
            android:id="@+id/summary_validate_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:text="@string/workshop_button_validate"
            app:icon="@android:drawable/ic_menu_set_as" />

    </LinearLayout>
</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_competition_summary.xml ---


--- START OF FILE app/src/main/res/layout/item_knowledge_card_reforged.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:cardCornerRadius="12dp"
    app:cardElevation="4dp"
    app:cardUseCompatPadding="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <ImageView
            android:id="@+id/card_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintDimensionRatio="1:1"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"/>

        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintTop_toTopOf="@id/card_image"
            app:layout_constraintBottom_toBottomOf="@id/card_image"
            app:layout_constraintStart_toStartOf="@id/card_image"
            app:layout_constraintEnd_toEndOf="@id/card_image"/>

        <TextView
            android:id="@+id/card_deck_name"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="12dp"
            android:layout_marginBottom="8dp"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            android:textColor="@android:color/white"
            android:shadowColor="#80000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            app:layout_constraintBottom_toTopOf="@id/card_title"
            app:layout_constraintStart_toStartOf="parent"
            tools:text="Insect Deck" />

        <TextView
            android:id="@+id/card_title"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="12dp"
            android:layout_marginBottom="12dp"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="3"
            app:layout_constraintBottom_toBottomOf="@id/card_image"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Honey Bee" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_knowledge_card_reforged.xml ---


--- START OF FILE app/src/main/res/layout/item_local_model.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:gravity="center_vertical"
    android:padding="8dp"
    android:background="?attr/selectableItemBackground">

    <TextView
        android:id="@+id/local_model_name_textview"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        tools:text="gemma3-1B-it-int4.task" />

    <ImageButton
        android:id="@+id/local_model_delete_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:src="@android:drawable/ic_menu_delete"
        android:contentDescription="Supprimer le mod√®le local"
        android:layout_marginStart="8dp"/>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/item_local_model.xml ---


--- START OF FILE app/src/main/res/layout/item_player_card.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="200dp"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardElevation="4dp"
    app:cardCornerRadius="8dp"
    android:backgroundTint="@color/black">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="12dp"
        android:background="@color/black"
        >

        <ImageView
            android:id="@+id/player_icon"
            android:layout_width="40dp"
            android:layout_height="40dp"
            android:src="@drawable/ic_turtle"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            android:contentDescription="Ic√¥ne de joueur tortue" />

        <TextView
            android:id="@+id/player_name_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="12dp"
            android:textStyle="bold"
            android:textSize="16sp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/player_icon"
            app:layout_constraintTop_toTopOf="@id/player_icon"
            tools:text="KikkoUser123" />

        <TextView
            android:id="@+id/player_record_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="4dp"
            android:textSize="12sp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintStart_toStartOf="@id/player_name_text"
            app:layout_constraintTop_toBottomOf="@id/player_name_text"
            tools:text="üèÜ 15 / üíî 4" />

        <TextView
            android:id="@+id/player_distance_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="@id/player_record_text"
            tools:text="11.6m" />

        <View
            android:id="@+id/separator_line"
            android:layout_width="0dp"
            android:layout_height="1dp"
            android:layout_marginTop="8dp"
            android:background="?attr/colorPrimary"
            android:alpha="0.3"
            app:layout_constraintTop_toBottomOf="@id/player_record_text"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/decks_column_1_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:textSize="14sp"
            android:lineSpacingExtra="4dp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/separator_line"
            tools:text="üê¢(123)\nüåø(78)" />

        <TextView
            android:id="@+id/decks_column_2_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:textSize="14sp"
            android:lineSpacingExtra="4dp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintStart_toEndOf="@+id/decks_column_1_text"
            app:layout_constraintTop_toTopOf="@id/decks_column_1_text"
            tools:text="üéÇ(45)\nüçé(289)" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_player_card.xml ---


--- START OF FILE app/src/main/res/layout/item_pollen_grain_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="120dp"
    android:layout_height="140dp"
    android:layout_margin="8dp"
    app:cardElevation="2dp"
    app:cardCornerRadius="12dp"
    android:clickable="true"
    android:focusable="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/pollen_preview_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Aper√ßu du grain de pollen" />

        <View
            android:id="@+id/pollen_preview_scrim"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.5"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <com.google.android.material.chip.Chip
            android:id="@+id/pollen_preview_status_chip"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="4dp"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            app:chipMinHeight="20dp"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            tools:text="RAW" />

        <TextView
            android:id="@+id/pollen_preview_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="8dp"
            android:layout_marginBottom="8dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal"
            android:textAppearance="?attr/textAppearanceBodySmall"
            android:textColor="@android:color/white"
            android:textStyle="bold"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Pollen #A4F3" />

        <View
            android:id="@+id/pollen_preview_selection_border"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/selection_halo"
            android:visibility="gone"
            tools:visibility="visible"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_pollen_grain_preview.xml ---


--- START OF FILE app/src/main/res/layout/item_pollen_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginEnd="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="100dp"
        android:layout_height="100dp"
        app:cardCornerRadius="8dp"
        app:cardElevation="2dp"
        android:layout_marginTop="8dp"
        android:layout_marginEnd="8dp">

        <ImageView
            android:id="@+id/pollen_preview_imageview"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerCrop"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Pollen visuel s√©lectionn√©"/>

    </com.google.android.material.card.MaterialCardView>

    <ProgressBar
        android:id="@+id/pollen_progress_indicator"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:layout_gravity="center"
        android:visibility="gone"
        tools:visibility="visible"/>

    <ImageView
        android:id="@+id/pollen_done_icon"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:layout_gravity="bottom|end"
        android:layout_marginEnd="12dp"
        android:layout_marginBottom="4dp"
        android:src="@drawable/ic_victory_cockade"
        android:visibility="gone"
        tools:visibility="visible" />

    <ImageButton
        android:id="@+id/pollen_remove_button"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:layout_gravity="top|end"
        android:src="@drawable/ic_close"
        android:background="@drawable/selection_halo"
        android:backgroundTint="?attr/colorError"
        app:tint="?attr/colorOnError"
        android:contentDescription="Retirer cette image"/>

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_pollen_preview.xml ---


--- START OF FILE app/src/main/res/layout/item_property_refinement.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <com.google.android.material.divider.MaterialDivider
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="16dp"/>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/property_refinement_header"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/selectableItemBackground"
        android:paddingVertical="8dp">

        <TextView
            android:id="@+id/property_refinement_title"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toStartOf="@id/property_refinement_result_count"
            tools:text="Raffinage de la Description" />

        <TextView
            android:id="@+id/property_refinement_result_count"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceBodyMedium"
            android:textColor="?attr/colorOnSurfaceVariant"
            android:layout_marginEnd="8dp"
            app:layout_constraintEnd_toStartOf="@id/property_refinement_expand_icon"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            tools:text="(8 r√©sultats)" />

        <ImageView
            android:id="@+id/property_refinement_expand_icon"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@android:drawable/arrow_down_float"
            app:tint="?attr/colorOnSurfaceVariant"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:contentDescription="@string/workshop_expand_section_desc"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

    <LinearLayout
        android:id="@+id/property_refinement_content"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:visibility="gone"
        tools:visibility="visible">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="8dp">

            <Button
                android:id="@+id/property_refinement_launch_button"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                tools:text="Relancer la Comp√©tition üîÑ"/>

            <Button
                android:id="@+id/property_refinement_launch_judgment_button"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginStart="8dp"
                android:text="@string/workshop_button_launch_judgment"
                android:visibility="gone"
                tools:visibility="visible"/>
        </LinearLayout>


        <com.google.android.material.card.MaterialCardView
            android:id="@+id/property_refinement_summary_card"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            app:cardBackgroundColor="?attr/colorSurfaceContainerHigh"
            app:strokeWidth="0dp"
            android:visibility="gone"
            tools:visibility="visible">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="12dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/workshop_competition_summary_title"
                    android:textAppearance="?attr/textAppearanceTitleSmall"
                    android:layout_marginBottom="8dp"/>

                <LinearLayout
                    android:id="@+id/property_refinement_summary_container"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"/>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/property_refinement_results_recyclerview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:nestedScrollingEnabled="false"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:itemCount="2"
            tools:listitem="@layout/item_analysis_result"/>
    </LinearLayout>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/item_property_refinement.xml ---


--- START OF FILE app/src/main/res/layout/item_queen_model_selection.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingStart="8dp"
    android:paddingEnd="8dp">

    <RadioButton
        android:id="@+id/queen_model_radio_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingTop="12dp"
        android:paddingBottom="12dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        tools:text="gemma-3n-E4B-it-int4.task" />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_queen_model_selection.xml ---


--- START OF FILE app/src/main/res/layout/item_vosk_model.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="8dp">

    <ImageButton
        android:id="@+id/button_test_vosk_model"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@android:drawable/ic_media_play"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:contentDescription="Tester le mod√®le vocal" />

    <TextView
        android:id="@+id/vosk_model_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:layout_marginEnd="16dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toStartOf="@+id/button_delete_vosk_model"
        app:layout_constraintStart_toEndOf="@+id/button_test_vosk_model"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="vosk-model-fr-0.22" />

    <ImageButton
        android:id="@+id/button_delete_vosk_model"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@android:drawable/ic_menu_delete"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:contentDescription="Supprimer le mod√®le vocal" />

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/item_vosk_model.xml ---


--- START OF FILE app/src/main/res/layout/layout_card_selector_panel.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/card_selector_panel"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:visibility="gone"
    tools:visibility="visible"
    app:cardBackgroundColor="@color/kikko_dark_gray"
    app:strokeColor="@color/kikko_gold_light"
    app:strokeWidth="1dp"
    app:cardElevation="8dp"
    app:cardCornerRadius="16dp"
    app:layout_constraintWidth_percent="0.8"
    app:layout_constraintTop_toTopOf="parent"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintEnd_toEndOf="parent">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="16dp">

        <ImageView
            android:id="@+id/selector_panel_deck_icon"
            android:layout_width="32dp"
            android:layout_height="32dp"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:src="@drawable/ic_deck_food"
            app:tint="@color/kikko_honey_yellow"/>

        <TextView
            android:id="@+id/selector_panel_deck_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@color/kikko_honey_yellow"
            app:layout_constraintStart_toEndOf="@id/selector_panel_deck_icon"
            app:layout_constraintTop_toTopOf="@id/selector_panel_deck_icon"
            app:layout_constraintBottom_toBottomOf="@id/selector_panel_deck_icon"
            app:layout_constraintEnd_toStartOf="@id/selector_panel_close_button"
            tools:text="S√©lectionnez un champion du Deck Food"/>

        <ImageButton
            android:id="@+id/selector_panel_close_button"
            android:layout_width="32dp"
            android:layout_height="32dp"
            android:src="@android:drawable/ic_menu_close_clear_cancel"
            android:background="?attr/selectableItemBackgroundBorderless"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:tint="@color/kikko_honey_yellow"/>

        <!-- BOURDON'S FIX: Hauteur ajust√©e pour permettre une grille visible -->
        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/selector_panel_recyclerview"
            android:layout_width="0dp"
            android:layout_height="240dp"
            android:layout_marginTop="16dp"
            android:clipToPadding="false"
            app:layout_constraintTop_toBottomOf="@id/selector_panel_deck_icon"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:listitem="@layout/item_card_preview"
            tools:layout_manager="androidx.recyclerview.widget.GridLayoutManager"
            tools:spanCount="4"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/layout_card_selector_panel.xml ---


--- START OF FILE app/src/main/res/layout/layout_chat_image_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:paddingTop="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="start"
        app:cardCornerRadius="12dp"
        app:cardElevation="2dp">

        <FrameLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content">

            <ImageView
                android:id="@+id/preview_image_view"
                android:layout_width="100dp"
                android:layout_height="100dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic"
                android:contentDescription="Pr√©visualisation de l'image √† envoyer"/>

            <ImageButton
                android:id="@+id/remove_preview_button"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:layout_gravity="top|end"
                android:layout_margin="4dp"
                android:src="@android:drawable/ic_menu_close_clear_cancel"
                android:background="@drawable/circle"
                android:backgroundTint="#80000000"
                app:tint="@android:color/white"/>

        </FrameLayout>

    </com.google.android.material.card.MaterialCardView>

</FrameLayout>

--- END OF FILE app/src/main/res/layout/layout_chat_image_preview.xml ---


--- START OF FILE app/src/main/res/layout/layout_chat_input_bar.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Un composant r√©utilisable pour une barre de saisie de chat moderne. -->
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardElevation="4dp"
    app:cardCornerRadius="28dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingStart="8dp"
        android:paddingEnd="8dp"
        android:minHeight="56dp">

        <ImageButton
            android:id="@+id/chat_attach_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_menu_add"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/chat_attach_button_desc"
            app:tint="?attr/colorOnSurfaceVariant"/>

        <EditText
            android:id="@+id/chat_input_edittext"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="@string/chat_input_hint"
            android:background="@android:color/transparent"
            android:inputType="textMultiLine|textCapSentences"
            android:maxLines="5"
            android:paddingTop="16dp"
            android:paddingBottom="16dp"
            android:paddingStart="8dp"
            android:paddingEnd="8dp" />

        <ImageButton
            android:id="@+id/chat_mic_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_btn_speak_now"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/chat_mic_button_desc"
            app:tint="?attr/colorOnSurfaceVariant"
            android:visibility="visible"/>

        <ImageButton
            android:id="@+id/chat_send_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_menu_send"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/chat_send_button_desc"
            app:tint="?attr/colorPrimary"
            android:visibility="gone"
            tools:visibility="visible"/>
    </LinearLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/layout_chat_input_bar.xml ---


--- START OF FILE app/src/main/res/menu/prompt_editor_menu.xml ---

<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/action_import_prompts"
        android:title="@string/menu_import_prompts"
        android:icon="@android:drawable/ic_menu_save"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_export_prompts"
        android:title="@string/menu_export_prompts"
        android:icon="@android:drawable/ic_menu_upload"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_reset_prompts"
        android:title="@string/menu_reset_prompts"
        android:icon="@android:drawable/ic_menu_revert"
        app:showAsAction="never" />

</menu>

--- END OF FILE app/src/main/res/menu/prompt_editor_menu.xml ---


--- START OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- END OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml ---


--- START OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- END OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml ---


--- START OF FILE app/src/main/res/values-fr/strings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="sort_by_prompt">Trier par‚Ä¶</string>
    <string name="app_name">KiKKo Saga Forge</string>
    <string name="model_manager">Gestion des Mod√®les</string>
    <string name="downloaded_size">%1$s t√©l√©charg√©</string>
    <string name="cancel">Annuler</string>
    <string name="ok">OK</string>
    <string name="confirm_delete_model_dialog_title">Supprimer le t√©l√©chargement</string>
    <string name="confirm_delete_model_dialog_content">√ätes-vous s√ªr de vouloir supprimer le mod√®le t√©l√©charg√© \"%s\" ?</string>
    <string name="notification_title_success">T√©l√©chargement du mod√®le r√©ussi</string>
    <string name="notification_content_success">Le mod√®le \"%s\" a √©t√© t√©l√©charg√©</string>
    <string name="notification_title_fail">√âchec du t√©l√©chargement du mod√®le</string>
    <string name="notification_content_fail">Impossible de t√©l√©charger le mod√®le \"%s\"</string>
    <string name="chat_textinput_placeholder">√âcrire un message‚Ä¶</string>
    <string name="chat_you">Vous</string>
    <string name="chat_llm_agent_name">LLM</string>
    <string name="chat_generic_agent_name">Mod√®le</string>
    <string name="chat_generic_result_name">R√©sultat</string>
    <string name="model_not_downloaded_msg">Mod√®le non encore t√©l√©charg√©</string>
    <string name="model_is_initializing_msg">Initialisation du mod√®le‚Ä¶</string>
    <string name="text_input_placeholder_text_classification">√âcrire une critique de film √† classifier‚Ä¶</string>
    <string name="text_image_generation_text_field_placeholder">√âcrire un prompt‚Ä¶</string>
    <string name="text_input_placeholder_llm_chat">√âcrire un prompt‚Ä¶</string>
    <string name="run_again">R√©-ex√©cuter</string>
    <string name="benchmark">Lancer le benchmark</string>
    <string name="warming_up">pr√©paration‚Ä¶</string>
    <string name="running">en cours</string>

    <string name="debug_activity_title">Kikko Labo de Test &amp; D√©bug</string>
    <string name="model_management_title">Gestion des Mod√®les</string>
    <string name="service_testing_title">Test des Services</string>

    <string name="status_downloading">T√©l√©chargement... %1$d%%</string>
    <string name="status_unzipping">D√©compression...</string>
    <string name="status_ready">Pr√™t</string>
    <string name="status_not_downloaded">Non T√©l√©charg√©</string>
    <string name="status_error">Erreur</string>
    <string name="button_download">T√©l√©charger</string>
    <string name="button_delete">Supprimer</string>

    <string name="vosk_test_title">Vosk Reconnaissance Vocale</string>
    <string name="button_test_vosk">D√©marrer l\'√©coute</string>
    <string name="button_stop_vosk">Arr√™ter l\'√©coute</string>
    <string name="vosk_status_idle">Statut : Inactif</string>
    <string name="vosk_status_listening">Statut : √âcoute en cours...</string>
    <string name="vosk_status_result">R√©sultat :</string>
    <string name="vosk_permission_denied">Erreur : Permission du microphone refus√©e.</string>

    <string name="ml_kit_test_title">Tests ML Kit</string>
    <string name="ocr_test_title">Reconnaissance de Texte (OCR)</string>
    <string name="button_run_ocr_test">Lancer test OCR</string>
    <string name="object_detection_title">D√©tection d\'Objets</string>
    <string name="button_run_object_test">Lancer test D√©tection</string>

    <string name="language_id_title">Identification &amp; Traduction de Langue</string>
    <string name="language_id_hint">√âcrivez du texte ici...</string>
    <string name="button_run_language_test">Identifier &amp; Traduire (vers FR)</string>

    <string name="gemma_test_title">Test Gemma LLM</string>
    <string name="gemma_prompt_hint">Entrez un prompt pour Gemma...</string>
    <string name="button_run_gemma_test">Envoyer √† Gemma</string>
    <string name="gemma_status_thinking">Gemma r√©fl√©chit...</string>
    <string name="gemma_status_result">R√©ponse de Gemma :</string>
    <string name="model_not_initialized">Mod√®le non initialis√©</string>

    <string name="dialog_connection_title">Accepter la connexion de %1$s ?</string>
    <string name="dialog_connection_message">Confirmez que le code est : %1$s</string>
    <string name="dialog_accept">Accepter</string>
    <string name="dialog_decline">Refuser</string>
    <string name="card_record_format" translatable="false">üèÜ %1$d / üíî %2$d</string>
    <string name="card_distance_format_m" translatable="false">%.1fm</string>
    <string name="card_distance_format_cm" translatable="false">%.0fcm</string>

</resources>

--- END OF FILE app/src/main/res/values-fr/strings.xml ---


--- START OF FILE app/src/main/res/values-jp/strings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="sort_by_prompt">‰∏¶„ÅπÊõø„Åà‚Ä¶</string>
    <string name="app_name">KiKKo „Çµ„Éº„Ç¨„Éï„Ç©„Éº„Ç∏</string>
    <string name="model_manager">„É¢„Éá„É´ÁÆ°ÁêÜ</string>
    <string name="downloaded_size">%1$s „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊ∏à„Åø</string>
    <string name="cancel">„Ç≠„É£„É≥„Çª„É´</string>
    <string name="ok">OK</string>
    <string name="confirm_delete_model_dialog_title">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÂâäÈô§</string>
    <string name="confirm_delete_model_dialog_content">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åü„É¢„Éá„É´„Äå%s„Äç„ÇíÊú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü</string>
    <string name="notification_title_success">„É¢„Éá„É´„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü</string>
    <string name="notification_content_success">„É¢„Éá„É´„Äå%s„Äç„Åå„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åï„Çå„Åæ„Åó„Åü</string>
    <string name="notification_title_fail">„É¢„Éá„É´„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</string>
    <string name="notification_content_fail">„É¢„Éá„É´„Äå%s„Äç„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</string>
    <string name="chat_textinput_placeholder">„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ‚Ä¶</string>
    <string name="chat_you">„ÅÇ„Å™„Åü</string>
    <string name="chat_llm_agent_name">LLM</string>
    <string name="chat_generic_agent_name">„É¢„Éá„É´</string>
    <string name="chat_generic_result_name">ÁµêÊûú</string>
    <string name="model_not_downloaded_msg">„É¢„Éá„É´„ÅØ„Åæ„Å†„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì</string>
    <string name="model_is_initializing_msg">„É¢„Éá„É´„ÇíÂàùÊúüÂåñ‰∏≠‚Ä¶</string>
    <string name="text_input_placeholder_text_classification">ÂàÜÈ°û„Åô„ÇãÊò†Áîª„ÅÆ„É¨„Éì„É•„Éº„ÇíÂÖ•Âäõ‚Ä¶</string>
    <string name="text_image_generation_text_field_placeholder">„Éó„É≠„É≥„Éó„Éà„ÇíÂÖ•Âäõ‚Ä¶</string>
    <string name="text_input_placeholder_llm_chat">„Éó„É≠„É≥„Éó„Éà„ÇíÂÖ•Âäõ‚Ä¶</string>
    <string name="run_again">ÂÜçÂÆüË°å</string>
    <string name="benchmark">„Éô„É≥„ÉÅ„Éû„Éº„ÇØ„ÇíÂÆüË°å</string>
    <string name="warming_up">Ê∫ñÂÇô‰∏≠‚Ä¶</string>
    <string name="running">ÂÆüË°å‰∏≠</string>

    <string name="debug_activity_title">Kikko„Éá„Éê„ÉÉ„Ç∞ÔºÜ„ÉÜ„Çπ„Éà„É©„Éú</string>
    <string name="model_management_title">„É¢„Éá„É´ÁÆ°ÁêÜ</string>
    <string name="service_testing_title">„Çµ„Éº„Éì„Çπ „ÉÜ„Çπ„Éà</string>

    <string name="status_downloading">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ‰∏≠... %1$d%%</string>
    <string name="status_unzipping">Ëß£Âáç‰∏≠...</string>
    <string name="status_ready">Ê∫ñÂÇôÂÆå‰∫Ü</string>
    <string name="status_not_downloaded">Êú™„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</string>
    <string name="status_error">„Ç®„É©„Éº</string>
    <string name="button_download">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</string>
    <string name="button_delete">ÂâäÈô§</string>

    <string name="vosk_test_title">Vosk Èü≥Â£∞Ë™çË≠ò</string>
    <string name="button_test_vosk">ËÅû„ÅçÂèñ„ÇäÈñãÂßã</string>
    <string name="button_stop_vosk">ËÅû„ÅçÂèñ„ÇäÂÅúÊ≠¢</string>
    <string name="vosk_status_idle">Áä∂ÊÖãÔºöÂæÖÊ©ü‰∏≠</string>
    <string name="vosk_status_listening">Áä∂ÊÖãÔºöËÅû„ÅçÂèñ„Çä‰∏≠...</string>
    <string name="vosk_status_result">ÁµêÊûúÔºö</string>
    <string name="vosk_permission_denied">„Ç®„É©„ÉºÔºö„Éû„Ç§„ÇØ„ÅÆ‰ΩøÁî®Ë®±ÂèØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</string>

    <string name="ml_kit_test_title">ML Kit „ÉÜ„Çπ„Éà</string>
    <string name="ocr_test_title">„ÉÜ„Ç≠„Çπ„ÉàË™çË≠ò (OCR)</string>
    <string name="button_run_ocr_test">OCR„ÉÜ„Çπ„ÉàÂÆüË°å</string>
    <string name="object_detection_title">Áâ©‰ΩìÊ§úÂá∫</string>
    <string name="button_run_object_test">Áâ©‰ΩìÊ§úÂá∫„ÉÜ„Çπ„ÉàÂÆüË°å</string>

    <string name="language_id_title">Ë®ÄË™û„ÅÆË≠òÂà•„Å®ÁøªË®≥</string>
    <string name="language_id_hint">„Åì„Åì„Å´„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ...</string>
    <string name="button_run_language_test">Ë≠òÂà•„Åó„Å¶ÁøªË®≥ (Êó•Êú¨Ë™û„Å∏)</string>

    <string name="gemma_test_title">Gemma LLM „ÉÜ„Çπ„Éà</string>
    <string name="gemma_prompt_hint">Gemma„Å∏„ÅÆ„Éó„É≠„É≥„Éó„Éà„ÇíÂÖ•Âäõ...</string>
    <string name="button_run_gemma_test">Gemma„Å´ÈÄÅ‰ø°</string>
    <string name="gemma_status_thinking">Gemma„ÅØËÄÉ„Åà‰∏≠„Åß„Åô...</string>
    <string name="gemma_status_result">Gemma„ÅÆÂøúÁ≠îÔºö</string>
    <string name="model_not_initialized">„É¢„Éá„É´„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì</string>

    <string name="dialog_connection_title">%1$s„Åã„Çâ„ÅÆÊé•Á∂ö„ÇíÊâøË™ç„Åó„Åæ„Åô„ÅãÔºü</string>
    <string name="dialog_connection_message">„Ç≥„Éº„Éâ„Åå %1$s „Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ</string>
    <string name="dialog_accept">ÊâøË™ç</string>
    <string name="dialog_decline">ÊãíÂê¶</string>
    <string name="card_record_format" translatable="false">üèÜ %1$d / üíî %2$d</string>
    <string name="card_distance_format_m" translatable="false">%.1fm</string>
    <string name="card_distance_format_cm" translatable="false">%.0fcm</string>

</resources>

--- END OF FILE app/src/main/res/values-jp/strings.xml ---


--- START OF FILE app/src/main/res/values-night/themes.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
  <style name="Theme.Gallery" parent="android:Theme.Material.Light.NoActionBar" />
  <style name="Theme.Gallery.SplashScreen" parent="Theme.SplashScreen">
    <item name="windowSplashScreenBackground">#2A2A34</item>
    <item name="postSplashScreenTheme">@style/Theme.Gallery</item>
  </style>
  <style name="Theme.Gallery.OssLicenses" parent="Theme.AppCompat.Light.DarkActionBar">
    <item name="android:windowOptOutEdgeToEdgeEnforcement" tools:targetApi="35">true</item>
  </style>
  <style name="Theme.Kikko.FullScreenDialog" parent="Theme.Material3.DayNight.Dialog">
    <item name="android:windowIsFloating">false</item>
    <item name="android:windowBackground">@android:color/transparent</item>
    <item name="android:windowContentOverlay">@null</item>
    <item name="android:windowTitleStyle">@null</item>
    <item name="android:backgroundDimEnabled">true</item>
  </style>

  <style name="Theme.KikkoSagaForge" parent="Theme.Material3.DayNight.NoActionBar">
    <!-- BOURDON'S FIX: Rendre la barre de statut transparente et les ic√¥nes claires -->
    <item name="android:statusBarColor">@android:color/transparent</item>
    <item name="android:windowLightStatusBar">false</item>

    <!-- Palette de couleurs primaires -->
    <item name="colorPrimary">@color/kikko_honey_yellow</item>
    <item name="colorPrimaryContainer">@color/kikko_leaf_green</item>
    <item name="colorOnPrimaryContainer">@color/kikko_bark_brown</item>
    <item name="colorSecondary">@color/kikko_magic_cyan</item>
    <item name="colorSecondaryContainer">@color/kikko_sky_blue</item>
    <item name="colorOnSecondaryContainer">@color/kikko_bark_brown</item>
    <item name="android:colorBackground">@color/kikko_light_gray</item>
    <item name="colorSurface">@color/white</item>
    <item name="colorOnBackground">@color/kikko_bark_brown</item>
    <item name="colorOnSurface">@color/kikko_bark_brown</item>
    <item name="colorError">@color/kikko_error_red</item>

    <item name="materialAlertDialogTheme">@style/KikkoAlertDialogTheme</item>
  </style>

  <style name="KikkoAlertDialogTheme" parent="ThemeOverlay.Material3.MaterialAlertDialog">
    <item name="colorPrimary">@color/kikko_honey_yellow</item>
    <item name="colorSecondary">@color/kikko_magic_cyan</item>
    <item name="colorSurface">@color/white</item>
    <item name="colorOnSurface">@color/kikko_bark_brown</item>
    <item name="android:background">@color/white</item>
    <item name="android:textColorPrimary">@color/kikko_bark_brown</item>
    <item name="android:textColorSecondary">@color/kikko_dark_gray</item>
    <item name="shapeAppearance">@style/KikkoDialogShape</item>
  </style>

  <style name="KikkoDialogShape" parent="ShapeAppearance.Material3.MediumComponent">
    <item name="cornerFamily">rounded</item>
    <item name="cornerSize">16dp</item>
  </style>
</resources>

--- END OF FILE app/src/main/res/values-night/themes.xml ---


--- START OF FILE app/src/main/res/values/arrays.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="sort_options">
        <item>Trier par Nom</item>
        <item>Trier par Deck</item>
    </string-array>
</resources>

--- END OF FILE app/src/main/res/values/arrays.xml ---


--- START OF FILE app/src/main/res/values/colors.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#ffffff</color>
    <color name="kikko_gold">#FFD700</color>
    <color name="kikko_gold_light">#40FFD700</color>

    <!-- BOURDON'S REFORGE: Parchment Theme Colors -->
    <color name="kikko_parchment">#FBF5E6</color>
    <color name="kikko_ink_brown">#5D4037</color>
    <color name="kikko_sepia_outline">#D7CCC8</color>
    <!-- End of Reforge -->

    <color name="kikko_success_green">@color/kikko_leaf_green</color>
    <color name="kikko_honey_yellow">#FFC300</color>
    <color name="kikko_bark_brown">#582F0E</color>
    <color name="kikko_leaf_green">#A4D4AE</color>
    <color name="kikko_sky_blue">#A9D6E5</color>
    <color name="kikko_magic_cyan">#45B69C</color>
    <color name="kikko_bud_pink">#F28FAD</color>

    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="kikko_light_gray">#FFF6F6F6</color>
    <color name="kikko_dark_gray">#FF333333</color>
    <color name="kikko_error_red">#B00020</color>

    <color name="turtle_blue">#03A9F4</color>
    <color name="turtle_green">#4CAF50</color>
    <color name="turtle_red">#F44336</color>
    <color name="turtle_purple">#9C27B0</color>
    <color name="turtle_orange">#FF9800</color>
    <color name="turtle_pink">#E91E63</color>

    <array name="turtle_colors">
        <item>@color/turtle_blue</item>
        <item>@color/turtle_green</item>
        <item>@color/turtle_red</item>
        <item>@color/turtle_purple</item>
        <item>@color/turtle_orange</item>
        <item>@color/turtle_pink</item>
    </array>

    <color name="kikko_background">#FEF7FF</color>
    <color name="kikko_primary">#6750A4</color>
    <color name="kikko_primary_variant">#4F378B</color>
    <color name="kikko_secondary">#625B71</color>
    <color name="kikko_secondary_variant">#4A4458</color>
    <color name="kikko_surface">#FEF7FF</color>
    <color name="kikko_surface_variant">#E7E0EC</color>
    <color name="kikko_outline">#79747E</color>
    <color name="kikko_on_primary">#FFFFFF</color>
    <color name="kikko_on_secondary">#FFFFFF</color>
    <color name="kikko_on_surface">#1D1B20</color>
    <color name="kikko_on_surface_variant">#49454F</color>
    <color name="kikko_error">#B3261E</color>
    <color name="kikko_on_error">#FFFFFF</color>

</resources>

--- END OF FILE app/src/main/res/values/colors.xml ---


--- START OF FILE app/src/main/res/values/dimens.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->


<resources>
    <dimen name="model_selector_height">54dp</dimen>
    <dimen name="chat_bubble_corner_radius">24dp</dimen>
</resources>

--- END OF FILE app/src/main/res/values/dimens.xml ---


--- START OF FILE app/src/main/res/values/plurals.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- BOURDON'S NOTE: This file handles strings that change based on quantity (singular/plural). -->
    <plurals name="import_saga_success" translatable="false">
        <item quantity="one">%1$d new card imported successfully!</item>
        <item quantity="other">%1$d new cards imported successfully!</item>
    </plurals>
    <plurals name="workshop_tasks_ready" translatable="false">
        <item quantity="one">%1$d task ready for the tournament.</item>
        <item quantity="other">%1$d tasks ready for the tournament.</item>
    </plurals>
</resources>

--- END OF FILE app/src/main/res/values/plurals.xml ---


--- START OF FILE app/src/main/res/values/strings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- =============================================================== -->
    <!-- ORIGINAL STRINGS (TRANSLATABLE) -->
    <!-- =============================================================== -->
    <string name="app_name">KiKKo Saga Forge</string>
    <string name="model_manager">Model Manager</string>
    <string name="downloaded_size">%1$s downloaded</string>
    <string name="cancel">Cancel</string>
    <string name="ok">OK</string>
    <string name="confirm_delete_model_dialog_title">Delete download</string>
    <string name="confirm_delete_model_dialog_content">Are you sure you want to delete the downloaded model \"%s\"?</string>
    <string name="notification_title_success">Model download succeeded</string>
    <string name="notification_content_success">Model \"%s\" has been downloaded</string>
    <string name="notification_title_fail">Model download failed</string>
    <string name="notification_content_fail">Failed to download model \"%s\"</string>
    <string name="chat_textinput_placeholder">Type message‚Ä¶</string>
    <string name="chat_you">You</string>
    <string name="chat_llm_agent_name">LLM</string>
    <string name="chat_generic_agent_name">Model</string>
    <string name="chat_generic_result_name">Result</string>
    <string name="model_not_downloaded_msg">Model not downloaded yet</string>
    <string name="model_is_initializing_msg">Initializing model‚Ä¶</string>
    <string name="text_input_placeholder_text_classification">Type movie review to classify‚Ä¶</string>
    <string name="text_image_generation_text_field_placeholder">Type prompt‚Ä¶</string>
    <string name="text_input_placeholder_llm_chat">Type prompt‚Ä¶</string>
    <string name="run_again">Run again</string>
    <string name="benchmark">Run benchmark</string>
    <string name="warming_up">warming up‚Ä¶</string>
    <string name="running">running</string>
    <string name="debug_activity_title">Kikko Debug &amp; Test Lab</string>
    <string name="model_management_title">Model Management</string>
    <string name="service_testing_title">Service Testing</string>
    <string name="status_downloading">Downloading... %1$d%%</string>
    <string name="status_unzipping">Unzipping...</string>
    <string name="status_ready">Ready</string>
    <string name="status_not_downloaded">Not Downloaded</string>
    <string name="status_error">Error</string>
    <string name="button_download">Download</string>
    <string name="button_delete">Delete</string>
    <string name="sort_by_prompt">Sort by‚Ä¶</string>
    <string name="vosk_test_title">Vosk Speech-to-Text</string>
    <string name="button_test_vosk">Start Listening</string>
    <string name="button_stop_vosk">Stop Listening</string>
    <string name="vosk_status_idle">Status: Idle</string>
    <string name="vosk_status_listening">Status: Listening...</string>
    <string name="vosk_status_result">Result:</string>
    <string name="vosk_permission_denied">Error: Microphone permission denied.</string>
    <string name="ml_kit_test_title">ML Kit Tests</string>
    <string name="ocr_test_title">Text Recognition (OCR)</string>
    <string name="button_run_ocr_test">Run OCR Test</string>
    <string name="object_detection_title">Object Detection</string>
    <string name="button_run_object_test">Run Object Test</string>
    <string name="language_id_title">Language ID &amp; Translation</string>
    <string name="language_id_hint">Type text here...</string>
    <string name="button_run_language_test">Identify &amp; Translate (to FR)</string>
    <string name="gemma_test_title">Gemma LLM Test</string>
    <string name="gemma_prompt_hint">Enter a prompt for Gemma...</string>
    <string name="button_run_gemma_test">Send to Gemma</string>
    <string name="gemma_status_thinking">Gemma is thinking...</string>
    <string name="gemma_status_result">Gemma\'s response:</string>
    <string name="model_not_initialized">Model not initialized</string>
    <string name="dialog_connection_title">Accept connection from %1$s?</string>
    <string name="dialog_connection_message">Confirm the code is: %1$s</string>
    <string name="dialog_accept">Accept</string>
    <string name="dialog_decline">Decline</string>
    <string name="card_record_format" translatable="false">üèÜ %1$d / üíî %2$d</string>
    <string name="card_distance_format_m" translatable="false">%.1fm</string>
    <string name="card_distance_format_cm" translatable="false">%.0fcm</string>

    <!-- =================================================================================== -->
    <!-- BOURDON'S I18N AUDIT - NEW CENTRALIZED STRINGS (CURRENTLY NON-TRANSLATABLE) -->
    <!-- =================================================================================== -->

    <!-- Generic Errors -->
    <string name="error_unknown" translatable="false">Unknown error</string>
    <string name="error_title" translatable="false">Error</string>
    <string name="error_generic_prefix" translatable="false">Error: %1$s</string>
    <string name="error_no_model_selected" translatable="false">No AI model is selected or available.</string>
    <string name="dialog_ok" translatable="false">OK</string>

    <!-- StartActivity Layout -->
    <string name="app_title_multiline" translatable="false">KiKKo\'s\nSaga Forge</string>
    <string name="navigation_decks" translatable="false">Decks</string>
    <string name="navigation_pollen_live" translatable="false">Pollen Live</string>
    <string name="navigation_forge" translatable="false">Forge</string>
    <string name="navigation_clash" translatable="false">Clash</string>

    <!-- StartActivity & ToolsDialog Logic -->
    <string name="import_saga_failure" translatable="false">Saga import failed.</string>
    <string name="importing_new_model" translatable="false">Importing new model...</string>
    <string name="import_new_model_success" translatable="false">New model added successfully!</string>
    <string name="import_new_model_failure" translatable="false">Error importing new model.</string>
    <string name="vosk_model_import_success" translatable="false">Vosk model \'%1$s\' imported!</string>
    <string name="vosk_model_import_failure" translatable="false">Error: %1$s</string>
    <string name="vosk_model_import_invalid_zip" translatable="false">Invalid Zip or does not contain a model folder.</string>
    <string name="secret_interaction_unlocked" translatable="false">Secret interaction unlocked!</string>
    <string name="hive_memory_cleared" translatable="false">Hive Memory cleared!</string>
    <string name="dialog_confirmation_required_title" translatable="false">Confirmation Required</string>
    <string name="dialog_nuke_db_message" translatable="false">Are you absolutely sure you want to erase ALL Hive memory (cards and pollen)? This action is irreversible.</string>
    <string name="dialog_confirm_nuke" translatable="false">Yes, clear everything</string>
    <string name="dialog_cancel" translatable="false">Cancel</string>
    <string name="mic_permission_denied" translatable="false">Microphone permission denied.</string>
    <string name="mic_permission_granted" translatable="false">Permission granted. Hold to speak.</string>
    <string name="counter_label_raw" translatable="false">Raw: %1$d</string>
    <string name="counter_label_forging" translatable="false">In Forge: %1$d</string>
    <string name="counter_label_honey" translatable="false">Honey: %1$d</string>
    <string name="counter_label_error" translatable="false">Errors: %1$d</string>
    <string name="vosk_loading_model" translatable="false">Loading %1$s...</string>
    <string name="vosk_loading_model_failed" translatable="false">Failed to load model.</string>
    <string name="vosk_model_deleted_success" translatable="false">Model \'%1$s\' deleted.</string>
    <string name="vosk_model_deleted_failure" translatable="false">Failed to delete model \'%1$s\'.</string>
    <string name="share_saga_title" translatable="false">Share Kikko Saga</string>
    <string name="export_saga_failure" translatable="false">Export failed. No cards to export?</string>
    <string name="model_deleted_success" translatable="false">\'%1$s\' deleted.</string>
    <string name="model_deleted_failure" translatable="false">Failed to delete \'%1$s\'.</string>

    <!-- ToolsDialog Layout -->
    <string name="tools_dialog_title" translatable="false">Forager\'s Toolbox</string>
    <string name="tools_active_queen_forge" translatable="false">Active AI Queen for the Forge</string>
    <string name="tools_queen_accelerator" translatable="false">Queen\'s Brain</string>
    <string name="tools_accelerator_cpu" translatable="false">CPU (Stable)</string>
    <string name="tools_accelerator_gpu" translatable="false">GPU (Fast)</string>
    <string name="tools_voice_recognition" translatable="false">Voice Recognition (Vosk)</string>
    <string name="tools_button_load_vosk" translatable="false">Load a new voice model (.zip)</string>
    <string name="tools_forge_settings" translatable="false">Forge Settings</string>
    <string name="tools_forge_require_charging" translatable="false">Forge only while charging</string>
    <string name="tools_forge_require_idle" translatable="false">Forge only when device is idle</string>
    <string name="tools_manage_local_queens" translatable="false">Manage Local AI Queens</string>
    <string name="tools_button_add_queen" translatable="false">Add a new AI Queen (.task)</string>
    <string name="tools_saga_management" translatable="false">Saga Management (Card Decks)</string>
    <string name="tools_button_import_saga" translatable="false">Import Saga</string>
    <string name="tools_button_export_saga" translatable="false">Export Saga</string>
    <string name="tools_danger_zone" translatable="false">‚ö†Ô∏è Danger Zone</string>
    <string name="tools_button_nuke_db" translatable="false">Erase Entire Hive Memory</string>
    <string name="queen_selected_toast" translatable="false">\'%1$s\' is now the Queen of the Forge.</string>
    <string name="accelerator_set_toast" translatable="false">Queen\'s Brain set to: %1$s</string>
    <string name="forge_charging_toast" translatable="false">Forge while charging: %1$s</string>
    <string name="forge_idle_toast" translatable="false">Forge when idle: %1$s</string>
    <string name="generic_enabled" translatable="false">Enabled</string>
    <string name="generic_disabled" translatable="false">Disabled</string>
    <string name="tools_button_download_more_queens" translatable="false">Download More Queens</string>
    <string name="tools_button_download_decks" translatable="false">Download Decks</string>
    <string name="tools_prompt_management_title" translatable="false">Queen\'s Decrees (Prompts)</string>
    <string name="tools_button_manage_prompts" translatable="false">Manage Queen\'s Decrees</string>

    <!-- Clash -->
    <string name="clash_title" translatable="false">CLASH</string>
    <string name="clash_judge_awakening" translatable="false">The AI Judge is awakening...</string>
    <string name="clash_button_random_desc" translatable="false">Generate random teams</string>
    <string name="clash_button_settings_desc" translatable="false">Clash settings</string>
    <string name="clash_button_radar_desc" translatable="false">Find P2P opponents</string>
    <string name="clash_button_start_solo" translatable="false">Start Clash</string>
    <string name="p2p_panel_close_desc" translatable="false">Close P2P panel</string>
    <string name="p2p_permissions_required" translatable="false">P2P permissions are required.</string>
    <string name="p2p_default_player_name" translatable="false">KikkoUser%1$d</string>
    <string name="p2p_status_inactive" translatable="false">P2P Arena inactive.</string>
    <string name="p2p_status_connected" translatable="false">Connected! Choose your champions.</string>
    <string name="p2p_status_connection_failed" translatable="false">Connection failed.</string>
    <string name="p2p_status_disconnected" translatable="false">Disconnected.</string>
    <string name="judge_awakening_please_wait" translatable="false">The AI Judge is awakening, please wait.</string>
    <string name="inference_error_generic" translatable="false">Generic inference error</string>
    <string name="judge_ready_toast" translatable="false">AI Judge \'%1$s\' is ready for the Clash!</string>
    <string name="judge_error_toast" translatable="false">AI Judge Error: %1$s</string>
    <string name="error_not_enough_cards_in_deck" translatable="false">You need at least 2 cards in the \'%1$s\' deck.</string>
    <string name="verdict_parse_reasoning_fallback" translatable="false">The Judge remained silent.</string>
    <string name="verdict_parse_tts_fallback_script" translatable="false">The verdict is in!</string>
    <string name="verdict_parse_error_reasoning" translatable="false">The AI Judge provided a verdict in an unexpected format.</string>
    <string name="verdict_parse_error_tts" translatable="false">The Judge is perplexed.</string>
    <string name="clash_waiting_for_opponent" translatable="false">Waiting for your opponent\'s choice.</string>
    <string name="clash_waiting_for_judge" translatable="false">Please wait for the AI Judge to awaken.</string>
    <string name="clash_no_cards_in_deck" translatable="false">No cards in deck \'%1$s\'.</string>
    <string name="clash_tournament_finished" translatable="false">Tournament finished!</string>
    <string name="dialog_arena_ready_title" translatable="false">Arena Ready!</string>
    <string name="dialog_arena_ready_message" translatable="false">Your teams are complete. Start the Clash?</string>
    <string name="dialog_launch" translatable="false">Launch</string>
    <string name="dialog_teams_complete_title" translatable="false">Teams Complete</string>
    <string name="dialog_waiting_for_host_message" translatable="false">Waiting for the host to start the Clash...</string>
    <string name="clash_setup_dialog_title" translatable="false">Clash Preparation</string>
    <string name="clash_judge_status_placeholder" translatable="false">Waiting for Judge configuration...</string>
    <string name="clash_judge_status_format" translatable="false">Queen: %1$s | Brain: %2$s | Temp: %3$.2f</string>
    <string name="clash_selector_title_format" translatable="false">Player %1$d - Deck %2$s</string>

    <!-- Clash Duel -->
    <string name="clash_duel_vs" translatable="false">VS</string>
    <string name="clash_duel_button_previous" translatable="false">Previous</string>
    <string name="clash_duel_button_next" translatable="false">Next</string>
    <string name="clash_duel_button_finish" translatable="false">Finish</string>
    <string name="clash_duel_question_placeholder" translatable="false">...</string>

    <!-- ForgeLive -->
    <string name="bourdon_avatar_desc" translatable="false">Bourdon\'s avatar</string>
    <string name="bourdon_message_placeholder" translatable="false">Bourdon\'s message...</string>
    <string name="button_capture_now" translatable="false">Capture now</string>
    <string name="button_hold_to_speak_desc" translatable="false">Hold to speak</string>
    <string name="button_skip" translatable="false">Skip</string>
    <string name="button_switch_camera_desc" translatable="false">Switch camera</string>
    <string name="bourdon_ask_intent" translatable="false">Hey Forager, do you have an idea of what pollen you want to collect?</string>
    <string name="bourdon_confirm_intent" translatable="false">Okay, I got it: \"%1$s\"! We\'ll make some Honey out of this. You can now capture your pollen.</string>
    <string name="bourdon_skip_intent" translatable="false">Perfect! Show me directly what you want to forge.</string>
    <string name="bourdon_harvest_complete" translatable="false">Great harvest! Shall we start forging or do you want to try again?</string>
    <string name="bourdon_harvest_complete_alt" translatable="false">Good harvest! Do you want to start making Honey or restart the pollen capture?</string>
    <string name="bourdon_save_pollen" translatable="false">Saving pollen to the Hive...</string>
    <string name="bourdon_save_error" translatable="false">Error: could not save pollen images.</string>
    <string name="bourdon_save_success" translatable="false">Pollen saved! Automatic identification has started.</string>
    <string name="pollen_capture_button_default" translatable="false">Capture</string>
    <string name="pollen_capture_button_full" translatable="false">Maximum Reached</string>
    <string name="pollen_capture_button_format" translatable="false">Capture (%1$d/4)</string>
    <string name="pollen_save_toast" translatable="false">Pollen saved!</string>
    <string name="pollen_capture_error_toast" translatable="false">Capture error.</string>
    <string name="pollen_capture_failed_toast" translatable="false">Capture failed</string>
    <string name="button_finish_harvest" translatable="false">Finish</string>
    <string name="button_restart_harvest" translatable="false">Restart</string>
    <string name="button_send_to_hive" translatable="false">Send to Hive</string>
    <string name="specialist_report_dialog_title" translatable="false">Specialist Analysis Report</string>
    <string name="specialist_report_global_title" translatable="false">--- Global Analysis Report ---</string>
    <string name="specialist_report_no_global" translatable="false">No global classification found.</string>
    <string name="specialist_report_specialist_opinion" translatable="false">Specialist Opinion (%1$s):</string>
    <string name="specialist_report_item" translatable="false">  - %1$s (%.1f%%)</string>
    <string name="specialist_report_objects_title" translatable="false">\n--- Detected Objects (%1$d) ---</string>
    <string name="specialist_report_no_objects" translatable="false">No objects detected.</string>
    <string name="specialist_report_object_item" translatable="false">%1$d. %2$s (%.1f%%)</string>
    <string name="specialist_report_unknown_object" translatable="false">Unknown Object</string>
    <string name="specialist_report_object_specialist_item" translatable="false">  - %1$s: %2$s</string>
    <string name="vosk_model_loaded_toast" translatable="false">Voice model \'%1$s\' loaded.</string>
    <string name="bourdon_welcome_capture" translatable="false">Welcome Forager! Point your camera at anything you wish to forge.</string>


    <!-- ForgeWorkshop -->
    <string name="workshop_title" translatable="false">Royal Forge Workshop</string>
    <string name="deck_emoji_raw" translatable="false">?</string>
    <string name="deck_name_raw" translatable="false">Raw</string>
    <string name="workshop_button_back_desc" translatable="false">Back</string>
    <string name="workshop_filter_raw_desc" translatable="false">Filter by Raw Pollen</string>
    <string name="workshop_filter_food_desc" translatable="false">Filter by Food Deck</string>
    <string name="workshop_filter_plant_desc" translatable="false">Filter by Plant Deck</string>
    <string name="workshop_filter_insect_desc" translatable="false">Filter by Insect Deck</string>
    <string name="workshop_filter_bird_desc" translatable="false">Filter by Bird Deck</string>
    <string name="workshop_selected_image_desc" translatable="false">Selected pollen grain image</string>
    <string name="workshop_button_reject_grain" translatable="false">Reject this Grain</string>
    <string name="workshop_expand_section_desc" translatable="false">Expand/Collapse section</string>
    <string name="workshop_grain_id_format" translatable="false">Grain ID: %1$s...</string>
    <string name="workshop_deck_format" translatable="false">Deck: %1$s</string>
    <string name="workshop_results_count" translatable="false">(%1$d results)</string>
    <string name="workshop_validate_identification_first" translatable="false">Validate identification first</string>
    <string name="workshop_forge_ingredients_first" translatable="false">Forge Ingredients first</string>
    <string name="dialog_error_details_title" translatable="false">Error Details</string>
    <string name="error_identification_not_validated" translatable="false">Identification must be validated before refining other properties.</string>
    <string name="error_ingredients_not_forged" translatable="false">Cannot forge allergens until ingredients have been successfully forged.</string>
    <string name="error_queen_model_file_not_found_format" translatable="false">AI Queen file \'%1$s\' not found.</string>
    <string name="error_queen_init_failed_format" translatable="false">AI Queen initialization failed: %1$s</string>
    <string name="error_pollen_parent_not_found" translatable="false">Parent pollen grain not found.</string>
    <string name="error_swarm_report_missing" translatable="false">Swarm report is missing.</string>
    <string name="error_card_not_found_for_refinement" translatable="false">Card not available for property refinement.</string>
    <string name="error_json_malformed_or_incomplete" translatable="false">The JSON result is malformed or incomplete.</string>
    <string name="fallback_reasoning_visual" translatable="false">Visual analysis not extracted</string>
    <string name="fallback_reasoning_correlation" translatable="false">Correlation by Regex</string>
    <string name="error_validation_parsing_failed" translatable="false">Both smart JSON parsing and Regex fallback failed.</string>
    <string name="error_json_malformed" translatable="false">The JSON response is malformed.</string>
    <string name="error_json_key_missing" translatable="false">Key \'%1$s\' is missing in the JSON response.</string>
    <string name="workshop_loading_grains" translatable="false">Loading pollen grains...</string>
    <string name="workshop_no_grains_to_forge" translatable="false">No pollen grains to forge.</string>
    <string name="workshop_awaiting_validation" translatable="false">Identification awaiting validation.</string>
    <string name="workshop_ready_to_refine" translatable="false">Ready to refine.</string>
    <string name="workshop_preparing_competition" translatable="false">Preparing competition for \'%1$s\'...</string>
    <string name="workshop_no_queens_installed" translatable="false">Error: No AI Queens are installed for the competition!</string>
    <string name="workshop_validating_identification" translatable="false">Validating identification...</string>
    <string name="workshop_validation_error" translatable="false">Validation error: %1$s</string>
    <string name="workshop_validating_property" translatable="false">Validating \'%1$s\'...</string>
    <string name="workshop_delete_grain_dialog_title" translatable="false">Confirmation Required</string>
    <string name="workshop_delete_grain_dialog_message" translatable="false">Are you sure you want to delete this pollen grain and all associated data (card, analyses, images)? This action is irreversible.</string>
    <string name="workshop_button_delete" translatable="false">Yes, delete</string>
    <string name="workshop_competition_summary_title" translatable="false">Competition Summary</string>
    <string name="workshop_summary_proposal_format" translatable="false">%1$d Queens propose: \"%2$s\"</string>
    <string name="workshop_button_validate" translatable="false">Validate</string>
    <string name="workshop_launch_competition" translatable="false">Launch Competition ‚öîÔ∏è</string>
    <string name="workshop_refinement_title_format" translatable="false">Refining: %1$s</string>
    <string name="property_title_identification" translatable="false">Main Identification</string>
    <string name="property_title_description" translatable="false">Narrative Description</string>
    <string name="property_title_ingredients" translatable="false">Ingredient List</string>
    <string name="property_title_allergens" translatable="false">Allergen Detection</string>
    <string name="property_title_energy" translatable="false">Energy Value</string>
    <string name="property_title_scientific_name" translatable="false">Scientific Name</string>
    <string name="property_title_vernacular_name" translatable="false">Common Name</string>
    <string name="property_title_flowering" translatable="false">Flowering Period</string>
    <string name="property_title_diet" translatable="false">Diet</string>
    <string name="property_title_wingspan" translatable="false">Wingspan</string>
    <string name="workshop_raw_pollen_title" translatable="false">Raw Pollen</string>
    <string name="workshop_deck_unknown" translatable="false">Deck: To be identified</string>
    <string name="workshop_no_grains_in_deck" translatable="false">No grains in this category.</string>
    <string name="workshop_competition_in_progress" translatable="false">Competition in Progress...</string>
    <string name="workshop_relaunch_competition" translatable="false">Relaunch Competition üîÑ</string>
    <string name="dialog_relaunch_title" translatable="false">Relaunch Competition?</string>
    <string name="dialog_relaunch_message" translatable="false">This will delete all current analysis results for this property and create a new set of tasks. Are you sure?</string>
    <string name="dialog_relaunch_confirm" translatable="false">Yes, Relaunch</string>
    <string name="workshop_button_launch_judgment" translatable="false">Launch Final Judgment ‚öñÔ∏è</string>

    <!-- RoyalAudience -->
    <string name="audience_title_generic" translatable="false">Open Audience</string>
    <string name="audience_title_loading" translatable="false">Preparing Audience...</string>
    <string name="error_card_not_found" translatable="false">Card not found in database.</string>
    <string name="error_no_queen_installed_or_selected" translatable="false">No AI Queen is installed or selected.</string>
    <string name="error_queen_model_file_not_found" translatable="false">AI Queen model file not found.</string>
    <string name="error_queen_init_failed" translatable="false">Queen initialization failed: %1$s</string>
    <string name="queen_switching_message" translatable="false">Queen %1$s is retiring. Queen %2$s is preparing her arrival...</string>
    <string name="queen_waking_up" translatable="false">The Queen is waking up, please wait...</string>
    <string name="queen_ready_to_chat" translatable="false">There, I am ready. What would you like to discuss?</string>
    <string name="queen_settings_updated" translatable="false">Queen\'s decrees updated.</string>
    <string name="audience_no_voice_model" translatable="false">No voice model is loaded. Please import one via the Tools.</string>
    <string name="audience_default_voice_model_loaded" translatable="false">Default voice model loaded: \'%1$s\'.</string>
    <string name="audience_no_queen_available" translatable="false">No AI Queen is available. Please add one via the Tools.</string>
    <string name="audience_no_queen_available_short" translatable="false">No Queen</string>
    <string name="audience_dialog_select_queen_title" translatable="false">Choose the Queen</string>
    <string name="audience_toolbar_title" translatable="false">AI Chat</string>
    <string name="audience_button_back_description" translatable="false">Back</string>
    <string name="audience_button_settings_description" translatable="false">Configure the Queen</string>
    <string name="chat_input_hint" translatable="false">Chat with the Queen...</string>
    <string name="chat_attach_button_desc" translatable="false">Attach an image</string>
    <string name="chat_mic_button_desc" translatable="false">Dictate question</string>
    <string name="chat_send_button_desc" translatable="false">Send question</string>

    <!-- DeckViewer & CardDetails -->
    <string name="deck_select_food_desc" translatable="false">Select Food Deck</string>
    <string name="deck_emoji_food" translatable="false">üçî</string>
    <string name="deck_name_food" translatable="false">Food</string>
    <string name="deck_select_plant_desc" translatable="false">Select Plant Deck</string>
    <string name="deck_emoji_plant" translatable="false">üåø</string>
    <string name="deck_name_plant" translatable="false">Plant</string>
    <string name="deck_select_insect_desc" translatable="false">Select Insect Deck</string>
    <string name="deck_emoji_insect" translatable="false">üêû</string>
    <string name="deck_name_insect" translatable="false">Insect</string>
    <string name="deck_select_bird_desc" translatable="false">Select Bird Deck</string>
    <string name="deck_emoji_bird" translatable="false">üê¶</string>
    <string name="deck_name_bird" translatable="false">Bird</string>
    <string name="card_deleted_toast" translatable="false">\'%1$s\' has been deleted.</string>
    <string name="translation_requested_toast" translatable="false">Translation for \'%1$s\' has been requested and will be processed in the background.</string>
    <string name="card_details_confidence_format" translatable="false">Confidence: %.2f</string>
    <string name="card_details_description_title" translatable="false">Description</string>
    <string name="card_details_reasoning_format" translatable="false">Visual Analysis: %1$s\nEvidence Correlation: %2$s</string>
    <string name="card_details_no_stats_available" translatable="false">No stats available.</string>
    <string name="card_details_button_delete" translatable="false">Delete</string>
    <string name="card_details_button_quiz" translatable="false">Launch Quiz</string>
    <string name="card_details_button_translate" translatable="false">Translate</string>
    <string name="card_details_button_chat" translatable="false">Discuss</string>

    <!-- Quiz -->
    <string name="quiz_no_questions_error" translatable="false">Error: No quiz questions found.</string>
    <string name="quiz_toolbar_title_format" translatable="false">Quiz: %1$s</string>
    <string name="quiz_progress_format" translatable="false">Question %1$d / %2$d</string>
    <string name="quiz_select_answer_prompt" translatable="false">Please select an answer.</string>
    <string name="quiz_feedback_correct" translatable="false">Correct answer!</string>
    <string name="quiz_feedback_incorrect" translatable="false">Incorrect. The correct answer was:\n\"%1$s\"</string>
    <string name="quiz_final_score_title" translatable="false">Quiz Finished!</string>
    <string name="quiz_final_score_message" translatable="false">Your score: %1$d / %2$d</string>
    <string name="quiz_button_finish" translatable="false">Finish</string>
    <string name="quiz_button_submit" translatable="false">Submit</string>
    <string name="quiz_button_next" translatable="false">Next Question</string>

    <!-- BOURDON'S I18N FIX: Worker Notifications -->
    <string name="notification_channel_name" translatable="false">Kikko Forge Background Work</string>
    <string name="notification_title" translatable="false">The Hive is working...</string>
    <string name="notification_forge_preparing" translatable="false">The Hive\'s Forge is preparing...</string>
    <string name="notification_forge_awakens" translatable="false">The Forge awakens...</string>
    <string name="notification_queen_identifying" translatable="false">Queen \'%1$s\' is identifying the pollen...</string>
    <string name="notification_queen_identifying_streaming" translatable="false">The Queen is identifying... (%1$d chars generated)</string>

    <!-- BOURDON'S ADDITION: Prompt Editor -->
    <string name="prompt_editor_title" translatable="false">Queen\'s Prompt Armory</string>
    <string name="menu_import_prompts" translatable="false">Import</string>
    <string name="menu_export_prompts" translatable="false">Export</string>
    <string name="menu_reset_prompts" translatable="false">Reset to Defaults</string>
    <string name="prompt_selector_label" translatable="false">Select Prompt to Edit:</string>
    <string name="prompt_editor_hint" translatable="false">Edit the content of the selected prompt here...</string>
    <string name="button_save_prompts" translatable="false">Save Changes</string>
    <string name="dialog_reset_prompts_title" translatable="false">Reset All Prompts?</string>
    <string name="dialog_reset_prompts_message" translatable="false">This will discard all your custom modifications and restore the original prompts that came with the app. This action is irreversible.</string>
    <string name="dialog_reset_confirm" translatable="false">Yes, Reset</string>
    <string name="toast_prompts_saved" translatable="false">Prompts saved successfully.</string>
    <string name="toast_prompts_restored" translatable="false">Prompts restored to default.</string>
    <string name="toast_import_success" translatable="false">Prompts imported successfully.</string>
    <string name="toast_import_failed" translatable="false">Failed to import prompts. The file might be invalid.</string>
    <string name="toast_export_failed" translatable="false">Failed to export prompts.</string>
    <string name="share_prompts_title" translatable="false">Share Kikko Prompts</string>

    <!-- BOURDON'S ADDITION: Judgment Tribunal -->
    <string name="judgment_dialog_title" translatable="false">Final Judgment</string>
    <string name="judgment_section_title_deliberation" translatable="false">Arbiter\'s Deliberation</string>
    <string name="judgment_section_title_decree" translatable="false">Arbiter\'s Decree (Prompt)</string>
    <string name="judgment_section_title_evidence" translatable="false">Evidence Presented</string>
    <string name="judgment_button_override" translatable="false">Override &amp; Choose Manually</string>
    <string name="judgment_button_confirm" translatable="false">Confirm Arbiter\'s Verdict</string>
    <string name="workshop_launching_judgment" translatable="false">Convening the Arbiter\'s Court for \'%1$s\'...</string>
    <string name="judgment_warning_in_progress" translatable="false">Warning: %1$d of %2$d Queens have finished. Your judgment will be based on partial evidence.</string>

</resources>

--- END OF FILE app/src/main/res/values/strings.xml ---


--- START OF FILE app/src/main/res/values/styles.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="KikkoText" parent="Widget.AppCompat.TextView">
        <item name="android:textColor">@color/kikko_on_surface</item>
    </style>

    <style name="KikkoText.Title">
        <item name="android:textSize">22sp</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="KikkoText.Body">
        <item name="android:textSize">16sp</item>
    </style>

    <style name="KikkoText.Caption">
        <item name="android:textSize">12sp</item>
        <item name="android:textColor">@color/kikko_on_surface_variant</item>
    </style>

    <style name="KikkoButton" parent="Widget.MaterialComponents.Button">
        <item name="android:textAllCaps">false</item>
    </style>

    <style name="KikkoButton.Secondary">
        <item name="android:textColor">@color/kikko_primary</item>
        <item name="strokeColor">@color/kikko_outline</item>
        <item name="strokeWidth">1dp</item>
        <item name="backgroundTint">@color/kikko_surface</item>
    </style>

</resources>

--- END OF FILE app/src/main/res/values/styles.xml ---


--- START OF FILE app/src/main/res/values/themes.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">

    <!-- Th√®me principal de l'application. H√©rite de Material 3, sans ActionBar par d√©faut. -->
    <style name="Theme.KikkoSagaForge" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Rendre la barre de statut transparente pour une immersion totale -->
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:windowLightStatusBar">false</item>

        <!-- Palette de couleurs de la Ruche -->
        <item name="colorPrimary">@color/kikko_honey_yellow</item>
        <item name="colorPrimaryContainer">@color/kikko_leaf_green</item>
        <item name="colorOnPrimaryContainer">@color/kikko_bark_brown</item>
        <item name="colorSecondary">@color/kikko_magic_cyan</item>
        <item name="colorSecondaryContainer">@color/kikko_sky_blue</item>
        <item name="colorOnSecondaryContainer">@color/kikko_bark_brown</item>
        <item name="android:colorBackground">@color/kikko_light_gray</item>
        <item name="colorSurface">@color/white</item>
        <item name="colorOnBackground">@color/kikko_bark_brown</item>
        <item name="colorOnSurface">@color/kikko_bark_brown</item>
        <item name="colorError">@color/kikko_error_red</item>

        <!-- Th√®me personnalis√© pour les bo√Ætes de dialogue d'alerte -->
        <item name="materialAlertDialogTheme">@style/KikkoAlertDialogTheme</item>
    </style>

    <!-- Style pour les bo√Ætes de dialogue plein √©cran (utilis√© par CardDetails, etc.) -->
    <style name="Theme.Kikko.FullScreenDialog" parent="Theme.Material3.DayNight.Dialog">
        <item name="android:windowIsFloating">false</item>
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:windowTitleStyle">@null</item>
        <item name="android:backgroundDimEnabled">true</item>
    </style>

    <!-- Th√®me sp√©cifique pour les bo√Ætes de dialogue MaterialAlertDialog -->
    <style name="KikkoAlertDialogTheme" parent="ThemeOverlay.Material3.MaterialAlertDialog">
        <item name="colorPrimary">@color/kikko_honey_yellow</item>
        <item name="colorSecondary">@color/kikko_magic_cyan</item>
        <item name="colorSurface">@color/white</item>
        <item name="colorOnSurface">@color/kikko_bark_brown</item>
        <item name="android:background">@color/white</item>
        <item name="android:textColorPrimary">@color/kikko_bark_brown</item>
        <item name="android:textColorSecondary">@color/kikko_dark_gray</item>
        <item name="shapeAppearance">@style/KikkoDialogShape</item>
    </style>

    <!-- Forme personnalis√©e pour les coins arrondis des dialogues -->
    <style name="KikkoDialogShape" parent="ShapeAppearance.Material3.MediumComponent">
        <item name="cornerFamily">rounded</item>
        <item name="cornerSize">16dp</item>
    </style>

</resources>

--- END OF FILE app/src/main/res/values/themes.xml ---


--- START OF FILE app/src/main/res/xml/backup_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>

--- END OF FILE app/src/main/res/xml/backup_rules.xml ---


--- START OF FILE app/src/main/res/xml/data_extraction_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>

--- END OF FILE app/src/main/res/xml/data_extraction_rules.xml ---


--- START OF FILE app/src/main/res/xml/file_paths.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<paths>
    <cache-path
        name="cache_pictures"
        path="/" />

    <external-files-path
        name="my_external_files"
        path="." />

</paths>

--- END OF FILE app/src/main/res/xml/file_paths.xml ---


--- START OF FILE app/src/test/java/com/google/ai/edge/gallery/data/ModelAllowlistTest.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.JUnit4

@RunWith(JUnit4::class)
class ModelAllowlistTest {
  @Test
  fun toModel_success() {
    val modelName = "test_model"
    val modelId = "test_model_id"
    val modelFile = "test_model_file"
    val description = "test description"
    val sizeInBytes = 100L
    val version = "20250623"
    val topK = 10
    val topP = 0.5f
    val temperature = 0.1f
    val maxTokens = 1000
    val accelerators = "gpu,cpu"
    val taskTypes = listOf("llm_chat", "ask_image")
    val estimatedPeakMemoryInBytes = 300L

    val allowedModel =
      AllowedModel(
        name = modelName,
        modelId = modelId,
        modelFile = modelFile,
        description = description,
        sizeInBytes = sizeInBytes,
        version = version,
        defaultConfig =
          DefaultConfig(
            topK = topK,
            topP = topP,
            temperature = temperature,
            maxTokens = maxTokens,
            accelerators = accelerators,
          ),
        taskTypes = taskTypes,
        llmSupportImage = true,
        llmSupportAudio = true,
        estimatedPeakMemoryInBytes = estimatedPeakMemoryInBytes,
      )
    val model = allowedModel.toModel()

    // Check that basic fields are set correctly.
    assertEquals(model.name, modelName)
    assertEquals(model.version, version)
    assertEquals(model.info, description)
    assertEquals(
      model.url,
      "https://huggingface.co/test_model_id/resolve/main/test_model_file?download=true",
    )
    assertEquals(model.sizeInBytes, sizeInBytes)
    assertEquals(model.estimatedPeakMemoryInBytes, estimatedPeakMemoryInBytes)
    assertEquals(model.downloadFileName, modelFile)
    assertFalse(model.showBenchmarkButton)
    assertFalse(model.showRunAgainButton)
    assertTrue(model.llmSupportImage)
    assertTrue(model.llmSupportAudio)

    // Check that configs are set correctly.
    assertEquals(model.configs.size, 5)

    // A label for showing max tokens (non-changeable).
    assertTrue(model.configs[0] is LabelConfig)
    assertEquals((model.configs[0] as LabelConfig).defaultValue, "$maxTokens")

    // A slider for topK.
    assertTrue(model.configs[1] is NumberSliderConfig)
    assertEquals((model.configs[1] as NumberSliderConfig).defaultValue, topK.toFloat())

    // A slider for topP.
    assertTrue(model.configs[2] is NumberSliderConfig)
    assertEquals((model.configs[2] as NumberSliderConfig).defaultValue, topP)

    // A slider for temperature.
    assertTrue(model.configs[3] is NumberSliderConfig)
    assertEquals((model.configs[3] as NumberSliderConfig).defaultValue, temperature)

    // A segmented button for accelerators.
    assertTrue(model.configs[4] is SegmentedButtonConfig)
    assertEquals((model.configs[4] as SegmentedButtonConfig).defaultValue, "GPU")
    assertEquals((model.configs[4] as SegmentedButtonConfig).options, listOf("GPU", "CPU"))
  }
}


--- END OF FILE app/src/test/java/com/google/ai/edge/gallery/data/ModelAllowlistTest.kt ---


--- START OF FILE build.gradle.kts ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
  alias(libs.plugins.android.application) apply false
  alias(libs.plugins.google.services) apply false
  alias(libs.plugins.kotlin.android) apply false
  alias(libs.plugins.kotlin.compose) apply false
  alias(libs.plugins.hilt.application) apply false
}


--- END OF FILE build.gradle.kts ---


--- START OF FILE settings.gradle.kts ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pluginManagement {
  repositories {
    google {
      content {
        includeGroupByRegex("com\\.android.*")
        includeGroupByRegex("com\\.google.*")
        includeGroupByRegex("androidx.*")
      }
    }
    mavenCentral()
    gradlePluginPortal()
  }
  resolutionStrategy {
    eachPlugin {
      if (requested.id.id == "com.google.android.gms.oss-licenses-plugin") {
        useModule("com.google.android.gms:oss-licenses-plugin:0.10.6")
      }
    }
  }
}

dependencyResolutionManagement {
  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
  repositories {
    //        mavenLocal()
    google()
    mavenCentral()
  }
}

rootProject.name = "KiKKo Saga Forges"

include(":app")


--- END OF FILE settings.gradle.kts ---
