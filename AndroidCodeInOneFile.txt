

--- START OF FILE app/build.gradle.kts ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

plugins {
  alias(libs.plugins.android.application)
  // Note: set apply to true to enable google-services (requires google-services.json).
  alias(libs.plugins.google.services) apply false
  alias(libs.plugins.kotlin.android)
  alias(libs.plugins.kotlin.compose)
  alias(libs.plugins.kotlin.serialization)
  alias(libs.plugins.protobuf)
  // BOURDON'S FIX: Suppression du plugin Hilt.
  // alias(libs.plugins.hilt.application)
  alias(libs.plugins.oss.licenses)
  kotlin("kapt") // KAPT est toujours nécessaire pour Parcelize, mais plus pour Hilt.
  id("kotlin-parcelize")
}

android {
  namespace = "be.heyman.android.ai.kikko"
  compileSdk = 35

  defaultConfig {
    applicationId = "be.heyman.android.ai.kikko"
    minSdk = 26
    targetSdk = 35
    versionCode = 1
    versionName = "1.0.4"

    // Needed for HuggingFace auth workflows.
    manifestPlaceholders["appAuthRedirectScheme"] = "be.heyman.android.ai.kikko.oauth"

    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
  }

  buildTypes {
    release {
      isMinifyEnabled = false
      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
      signingConfig = signingConfigs.getByName("debug")
    }
  }
  compileOptions {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
  }
  kotlinOptions {
    jvmTarget = "11"
    freeCompilerArgs += "-Xcontext-receivers"
  }
  buildFeatures {
    compose = true
    buildConfig = true
    // BOURDON'S FIX: Activation explicite du View Binding
    viewBinding = true
  }
  aaptOptions {
    noCompress("tflite")
  }
}

dependencies {
  // BOURDON'S FIX: Suppression des dépendances Hilt pour WorkManager et Hilt en général.
  // implementation("androidx.hilt:hilt-work:1.2.0")
  // kapt("androidx.hilt:hilt-compiler:1.2.0")

  implementation("androidx.work:work-runtime-ktx:2.9.0")
  implementation(libs.androidx.core.ktx)
  implementation(libs.androidx.lifecycle.runtime.ktx)
  implementation(libs.androidx.activity.compose)
  implementation(platform(libs.androidx.compose.bom))
  implementation(libs.androidx.ui)
  implementation(libs.androidx.ui.graphics)
  implementation(libs.androidx.ui.tooling.preview)
  implementation(libs.androidx.material3)

  implementation(libs.androidx.compose.navigation)
  implementation(libs.kotlinx.serialization.json)
  implementation(libs.material.icon.extended)
  implementation(libs.androidx.work.runtime)
  implementation(libs.androidx.datastore)
  implementation(libs.com.google.code.gson)
  implementation(libs.androidx.lifecycle.process)
  implementation(libs.mediapipe.tasks.text)
  implementation(libs.mediapipe.tasks.genai)
  implementation(libs.mediapipe.tasks.imagegen)
  implementation(libs.commonmark)
  implementation(libs.richtext)
  implementation(libs.tflite)
  implementation(libs.tflite.gpu)
  implementation(libs.tflite.support)
  implementation(libs.camerax.core)
  implementation(libs.camerax.camera2)
  implementation(libs.camerax.lifecycle)
  implementation(libs.camerax.view)
  implementation(libs.openid.appauth)
  implementation(libs.androidx.splashscreen)
  implementation(libs.protobuf.javalite)
  // BOURDON'S FIX: Suppression des dépendances Hilt en général.
  // implementation(libs.hilt.android)
  // implementation(libs.hilt.navigation.compose)
  implementation(libs.play.services.oss.licenses)
  implementation(platform(libs.firebase.bom))
  implementation(libs.firebase.analytics)
  // BOURDON'S FIX: Suppression du kapt Hilt.
  // kapt(libs.hilt.android.compiler)
  testImplementation(libs.junit)
  androidTestImplementation(libs.androidx.junit)
  androidTestImplementation(libs.androidx.espresso.core)
  androidTestImplementation(platform(libs.androidx.compose.bom))
  androidTestImplementation(libs.androidx.ui.test.junit4)
  // BOURDON'S FIX: Suppression de la dépendance Hilt pour les tests.
  // androidTestImplementation(libs.hilt.android.testing)
  debugImplementation(libs.androidx.ui.tooling)
  debugImplementation(libs.androidx.ui.test.manifest)

  // Vosk & JNA
  implementation("com.alphacephei:vosk-android:0.3.47@aar")
  implementation("net.java.dev.jna:jna:5.13.0@aar")
  implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.2")

  // ML Kit
  implementation("com.google.mlkit:barcode-scanning:17.2.0")
  implementation("com.google.mlkit:text-recognition:16.0.1")
  implementation("com.google.mlkit:text-recognition-japanese:16.0.1")
  implementation("com.google.mlkit:language-id:17.0.6")
  implementation("com.google.mlkit:translate:17.0.3")
  implementation("com.google.mlkit:object-detection:17.0.1")
  implementation("com.google.mlkit:object-detection-custom:17.0.2")
  implementation("com.google.mlkit:image-labeling:17.0.9")
  implementation("com.google.mlkit:image-labeling-custom:17.0.3")

  // BOURDON'S ADDITION: Dépendances requises pour Google Nearby et Location
  implementation("com.google.android.gms:play-services-nearby:19.3.0")
  implementation("com.google.android.gms:play-services-location:21.3.0")

  // BOURDON'S ADDITION: Dépendances pour AndroidX Media3 (ExoPlayer)
  val media3Version = "1.4.0"
  implementation("androidx.media3:media3-exoplayer:$media3Version")
  implementation("androidx.media3:media3-ui:$media3Version")

  // Dépendances pour les layouts XML et AppCompat
  implementation("androidx.appcompat:appcompat:1.7.1")
  implementation("com.google.android.material:material:1.12.0")
  implementation("androidx.constraintlayout:constraintlayout:2.1.4")
  implementation("androidx.recyclerview:recyclerview:1.3.2")
  implementation("com.google.android.flexbox:flexbox:3.0.0")

  implementation("androidx.fragment:fragment-ktx:1.8.1")

  // BOURDON'S ADDITION: Dépendance pour Glide (chargement d'images)
  implementation("com.github.bumptech.glide:glide:4.16.0")

}

protobuf {
  protoc { artifact = "com.google.protobuf:protoc:4.26.1" }
  generateProtoTasks { all().forEach { it.plugins { create("java") { option("lite") } } } }
}

--- END OF FILE app/build.gradle.kts ---


--- START OF FILE app/proguard-rules.pro ---

# Règles pour protéger la librairie JNA (utilisée par Vosk)
-keep class com.sun.jna.** { *; }
-keepclassmembers class * extends com.sun.jna.** { public *; }

# Tu peux ajouter d'autres règles ProGuard spécifiques à ton projet ici.

--- END OF FILE app/proguard-rules.pro ---


--- START OF FILE app/src/main/AndroidManifest.xml ---

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-sdk
        android:minSdkVersion="26"
        android:targetSdkVersion="35" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC"/>

    <uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />

    <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES"
        android:usesPermissionFlags="neverForLocation"
        tools:targetApi="tiramisu" />
    <uses-feature
        android:name="android.hardware.camera"
        android:required="false" />

    <application
        android:name=".KikkoApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="KiKKo's Saga Forge"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.KikkoSagaForge"
        tools:targetApi="31">

        <activity
            android:name=".StartActivity"
            android:exported="true"
            android:theme="@style/Theme.KikkoSagaForge">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".deck.DeckViewerActivity" android:exported="false" android:label="Mon Gardien Kikkō" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".quiz.QuizActivity" android:exported="false" android:label="Kikko Quiz" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".clash.ui.ClashActivity" android:exported="false" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".pollen.ForgeLiveActivity" android:exported="false" android:theme="@style/Theme.KikkoSagaForge" />
        <activity android:name=".forge.ForgeWorkshopActivity" android:exported="false" android:label="Atelier de la Forge Royale" android:theme="@style/Theme.KikkoSagaForge" />

        <!-- BOURDON'S ADDITION: Déclaration de la nouvelle PromptEditorActivity -->
        <activity android:name=".prompt.PromptEditorActivity" android:exported="false" android:theme="@style/Theme.KikkoSagaForge" />

        <!-- BOURDON'S FIX: Ajout de windowSoftInputMode pour corriger le comportement du clavier. -->
        <activity
            android:name=".royal_audience.RoyalAudienceActivity"
            android:exported="false"
            android:theme="@style/Theme.KikkoSagaForge"
            android:windowSoftInputMode="adjustResize" />


        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

        <service
            android:name="androidx.work.impl.foreground.SystemForegroundService"
            android:foregroundServiceType="dataSync"
            android:exported="false"
            tools:node="merge" />

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="${applicationId}.androidx-startup"
            android:exported="false"
            tools:node="merge">
            <meta-data
                android:name="androidx.work.WorkManagerInitializer"
                tools:node="remove" />
        </provider>

    </application>

</manifest>

--- END OF FILE app/src/main/AndroidManifest.xml ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/GalleryTheme.kt ---

package be.heyman.android.ai.kikko

class GalleryTheme(function: () -> Unit) {

}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/GalleryTheme.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/GameConstants.kt ---

package be.heyman.android.ai.kikko

/**
 * BOURDON'S NOTE:
 * Un objet singleton pour contenir les constantes de notre jeu.
 * C'est ici que nous définissons les règles qui ne changent pas, comme la liste
 * officielle des decks, pour assurer la cohérence à travers toute l'application.
 */
object GameConstants {

    /**
     * La liste maîtresse, fixe et ordonnée, de TOUS les decks possibles dans le jeu.
     * L'ordre est important pour la sérialisation/désérialisation des catalogues de joueurs.
     */
    val MASTER_DECK_LIST = listOf(
        "Food",
        "Plant",
        "Insect",
        "Bird"
    )

    /**
     * Table de correspondance pour associer un emoji à chaque deck, pour l'affichage.
     */
    val DECK_EMOJIS = mapOf(
        "Food" to "🍔",
        "Plant" to "🌿",
        "Insect" to "🐞",
        "Bird" to "🐦"
    )
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/GameConstants.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoApplication.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko

import android.app.Application
import android.util.Log
import androidx.work.Configuration
import be.heyman.android.ai.kikko.clash.helpers.ClashLlmHelper
import be.heyman.android.ai.kikko.clash.services.ClashArenaService
import be.heyman.android.ai.kikko.common.writeLaunchInfo
import be.heyman.android.ai.kikko.forge.ForgeLlmHelper
import be.heyman.android.ai.kikko.forge.ForgeRepository
import be.heyman.android.ai.kikko.persistence.AnalysisResultDao
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import be.heyman.android.ai.kikko.prompt.PromptManager

class KikkoApplication : Application(), Configuration.Provider {

  val cardDao: CardDao by lazy { CardDao(this) }
  val pollenGrainDao: PollenGrainDao by lazy { PollenGrainDao(this) }
  val analysisResultDao: AnalysisResultDao by lazy { AnalysisResultDao(this) }
  val forgeRepository: ForgeRepository by lazy { ForgeRepository(pollenGrainDao, cardDao, analysisResultDao) }
  val clashLlmHelper: ClashLlmHelper by lazy { ClashLlmHelper(this) }
  val forgeLlmHelper: ForgeLlmHelper by lazy { ForgeLlmHelper(this) }
  val clashArenaService: ClashArenaService by lazy { ClashArenaService(this) }


  override fun onCreate() {
    super.onCreate()

    writeLaunchInfo(context = this)

    // BOURDON'S CRITICAL FIX: This line is mandatory and was missing.
    // It loads all prompts into memory when the app starts.
    PromptManager.initialize(this)

    cardDao.hashCode()
    pollenGrainDao.hashCode()
    analysisResultDao.hashCode()
    forgeRepository.hashCode()
    clashLlmHelper.hashCode()
    forgeLlmHelper.hashCode()
    clashArenaService.hashCode()
  }

  override val workManagerConfiguration: Configuration
    get() =
      Configuration.Builder()
        .setMinimumLoggingLevel(Log.DEBUG)
        .build()
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoApplication.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoMainActivity.kt ---

package be.heyman.android.ai.kikko

import android.annotation.SuppressLint
import android.graphics.Rect
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.MotionEvent
import android.widget.LinearLayout
import android.widget.Toast
import android.widget.VideoView
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

/**
 * Activité principale de l'application.
 * Gère le fond vidéo interactif et la barre de navigation inférieure.
 */
class KikkoMainActivity : AppCompatActivity() {

    // AJOUT : Un TAG pour filtrer nos logs facilement dans Logcat
    private val TAG = "KikkoMainActivity"

    private lateinit var backgroundVideoView: VideoView

    // --- Variables pour la logique du "Grattage de Ventre" ---
    private var scratchJob: Job? = null
    private val bellyHotspot = Rect()
    private var isReactionPlaying = false
    // --------------------------------------------------------

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // NOTE: Le layout R.layout.activity_main_avec_nav est utilisé ici.
        setContentView(R.layout.activity_deck_selection)
        Log.d(TAG, "onCreate: L'activité est créée.")

        backgroundVideoView = findViewById(R.id.background_video_view)

        setupBackgroundVideo()
        setupNavigation()
        setupBellyScratchListener() // Initialisation de l'interaction secrète
    }

    private fun setupBackgroundVideo() {
        Log.d(TAG, "setupBackgroundVideo: Configuration de la vidéo principale.")
        playVideo(R.raw.kikko_main, isLooping = true)
    }

    private fun playVideo(videoResId: Int, isLooping: Boolean) {
        val resourceName = resources.getResourceEntryName(videoResId)
        Log.d(TAG, "playVideo: Lancement de la vidéo '$resourceName' (loop: $isLooping)")
        val videoPath = "android.resource://" + packageName + "/" + videoResId
        val uri = Uri.parse(videoPath)

        backgroundVideoView.setVideoURI(uri)
        backgroundVideoView.setOnPreparedListener { mediaPlayer ->
            mediaPlayer.isLooping = isLooping
            mediaPlayer.setVolume(0f, 0f)
        }
        backgroundVideoView.start()
    }

    private fun setupNavigation() {
        // ... (le code des listeners de navigation reste identique)
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupBellyScratchListener() {
        Log.d(TAG, "setupBellyScratchListener: Le listener de grattage est maintenant actif.")
        backgroundVideoView.setOnTouchListener { view, event ->
            if (isReactionPlaying) {
                Log.v(TAG, "Touch ignoré: la vidéo de réaction est en cours.")
                return@setOnTouchListener false
            }

            val x = event.x.toInt()
            val y = event.y.toInt()

            val viewWidth = view.width
            val viewHeight = view.height
            bellyHotspot.set(
                (viewWidth * 0.25).toInt(),
                (viewHeight * 0.40).toInt(),
                (viewWidth * 0.75).toInt(),
                (viewHeight * 0.80).toInt()
            )

            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    Log.d(TAG, "ACTION_DOWN: Touché aux coordonnées ($x, $y). Hotspot: $bellyHotspot")
                    if (bellyHotspot.contains(x, y)) {
                        Log.i(TAG, "Touché DANS le hotspot. Démarrage du timer de 4 secondes...")
                        scratchJob = lifecycleScope.launch {
                            delay(4000)
                            Log.i(TAG, "TIMER TERMINÉ: 4 secondes écoulées. Déclenchement de l'événement.")
                            triggerBellyScratchEvent()
                        }
                    } else {
                        Log.d(TAG, "Touché HORS du hotspot.")
                    }
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    if (!bellyHotspot.contains(x, y)) {
                        if (scratchJob?.isActive == true) {
                            Log.w(TAG, "ACTION_MOVE: Doigt sorti du hotspot. Annulation du timer.")
                            scratchJob?.cancel()
                        }
                    }
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    if (scratchJob?.isActive == true) {
                        Log.w(TAG, "ACTION_UP/CANCEL: Doigt levé. Annulation du timer.")
                        scratchJob?.cancel()
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun triggerBellyScratchEvent() {
        if (isReactionPlaying) return
        isReactionPlaying = true

        runOnUiThread {
            Log.i(TAG, "triggerBellyScratchEvent: Événement déclenché ! Changement de vidéo.")
            Toast.makeText(this, "Interaction secrète débloquée !", Toast.LENGTH_SHORT).show()

            // NOTE DU BOURDON: J'ai corrigé le nom de votre vidéo de "kikko_deck_" à "kikko_reaction" pour plus de clarté.
            // Assurez-vous que le fichier R.raw.kikko_reaction existe bien.
            playVideo(R.raw.kikko_deck, isLooping = false)

            backgroundVideoView.setOnCompletionListener {
                Log.i(TAG, "onCompletion: La vidéo de réaction est terminée. Retour à la vidéo principale.")
                isReactionPlaying = false
                playVideo(R.raw.kikko_main, isLooping = true)
                backgroundVideoView.setOnCompletionListener(null)
            }
        }
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume: Reprise de l'activité, la vidéo devrait (re)démarrer.")
        if (!isReactionPlaying) {
            backgroundVideoView.start()
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/KikkoMainActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/QueenModelAdapter.kt ---

package be.heyman.android.ai.kikko

import android.annotation.SuppressLint
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RadioButton
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import java.io.File

class QueenModelAdapter(
    private var models: List<File>,
    private var selectedModelName: String?,
    private val onModelSelected: (File) -> Unit
) : RecyclerView.Adapter<QueenModelAdapter.ViewHolder>() {

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val radioButton: RadioButton = view.findViewById(R.id.queen_model_radio_button)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_queen_model_selection, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val modelFile = models[position]
        holder.radioButton.text = modelFile.name
        holder.radioButton.isChecked = (modelFile.name == selectedModelName)

        holder.radioButton.setOnClickListener {
            if (modelFile.name != selectedModelName) {
                onModelSelected(modelFile)
                // Le fragment mettra à jour l'adaptateur avec le nouveau nom sélectionné
            }
        }
    }

    override fun getItemCount() = models.size

    @SuppressLint("NotifyDataSetChanged")
    fun updateSelection(newModels: List<File>, newSelectedModelName: String?) {
        models = newModels
        selectedModelName = newSelectedModelName
        // On a besoin de redessiner toute la liste pour décocher l'ancien et cocher le nouveau.
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/QueenModelAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/SagaArchiver.kt ---

package be.heyman.android.ai.kikko

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.util.Log
import androidx.core.content.FileProvider
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.persistence.AnalysisResultDao
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

object SagaArchiver {

    private const val TAG = "SagaArchiver"
    private const val IMAGE_MAX_SIZE = 1024

    suspend fun exportSaga(context: Context): Uri? = withContext(Dispatchers.IO) {
        val cardDao = CardDao(context)
        val pollenGrainDao = PollenGrainDao(context)
        val analysisResultDao = AnalysisResultDao(context)

        val allCards = cardDao.getAll()
        if (allCards.isEmpty()) {
            Log.w(TAG, "Aucune carte à exporter.")
            return@withContext null
        }

        // BOURDON'S NOTE: On récupère maintenant TOUTES les données.
        val allPollenGrains = allCards.mapNotNull { it.id }.mapNotNull { pollenGrainDao.findByForgedCardId(it) }
        val allAnalysisResults = allPollenGrains.flatMap { analysisResultDao.getByPollenGrainIdAndProperty(it.id, "identification") } // Exemple, à étendre si nécessaire

        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val exportFileName = "KikkoSaga_Export_$timestamp.kikkoSaga"
        val exportDir = File(context.getExternalFilesDir(null), "exports")
        if (!exportDir.exists()) exportDir.mkdirs()
        val exportFile = File(exportDir, exportFileName)

        try {
            ZipOutputStream(FileOutputStream(exportFile)).use { zos ->
                // Sérialisation des trois types de données
                addFileToZip("cards.json", Gson().toJson(allCards).toByteArray(), zos)
                addFileToZip("pollen_grains.json", Gson().toJson(allPollenGrains).toByteArray(), zos)
                addFileToZip("analysis_results.json", Gson().toJson(allAnalysisResults).toByteArray(), zos)

                // BOURDON'S NOTE: Redimensionnement et ajout des images
                allCards.forEach { card ->
                    card.imagePath?.let { path ->
                        val imageFile = File(path)
                        if (imageFile.exists()) {
                            resizeAndAddImageToZip(imageFile, "card_images/${imageFile.name}", zos)
                        }
                    }
                }
            }
            Log.i(TAG, "Exportation complète de la Saga réussie vers : ${exportFile.absolutePath}")
            return@withContext FileProvider.getUriForFile(context, "${context.packageName}.provider", exportFile)

        } catch (e: Exception) {
            Log.e(TAG, "Erreur lors de l'exportation complète de la saga", e)
            exportFile.delete()
            return@withContext null
        }
    }

    suspend fun importSaga(context: Context, uri: Uri): Int = withContext(Dispatchers.IO) {
        val cardDao = CardDao(context)
        val pollenGrainDao = PollenGrainDao(context)
        val analysisResultDao = AnalysisResultDao(context)

        val existingCardNames = cardDao.getAll().map { it.specificName }.toSet()
        var importedCardCount = 0
        Log.d(TAG, "Démarrage de l'importation relationnelle de la Saga depuis : $uri")

        try {
            context.contentResolver.openInputStream(uri)?.use { inputStream ->
                ZipInputStream(inputStream).use { zis ->
                    // Étape 1: Extraire toutes les données en mémoire
                    val imageBytesMap = mutableMapOf<String, ByteArray>()
                    var cardsJson: String? = null
                    var pollenJson: String? = null
                    var analysisJson: String? = null

                    var entry = zis.nextEntry
                    while (entry != null) {
                        when {
                            entry.name == "cards.json" -> cardsJson = zis.bufferedReader().readText()
                            entry.name == "pollen_grains.json" -> pollenJson = zis.bufferedReader().readText()
                            entry.name == "analysis_results.json" -> analysisJson = zis.bufferedReader().readText()
                            !entry.isDirectory && entry.name.startsWith("card_images/") -> {
                                imageBytesMap[File(entry.name).name] = zis.readBytes()
                            }
                        }
                        entry = zis.nextEntry
                    }

                    if (cardsJson == null || pollenJson == null || analysisJson == null) {
                        Log.e(TAG, "L'archive est invalide ou incomplète.")
                        return@withContext -1
                    }

                    // Étape 2: Désérialiser et préparer les données
                    val gson = Gson()
                    val importedCards: List<KnowledgeCard> = gson.fromJson(cardsJson, object : TypeToken<List<KnowledgeCard>>() {}.type)
                    val importedPollen: List<PollenGrain> = gson.fromJson(pollenJson, object : TypeToken<List<PollenGrain>>() {}.type)
                    val importedAnalysis: List<AnalysisResult> = gson.fromJson(analysisJson, object : TypeToken<List<AnalysisResult>>() {}.type)

                    // BOURDON'S NOTE: Logique de greffe relationnelle
                    val oldCardIdToNewId = mutableMapOf<Long, Long>()
                    val oldPollenIdToNewId = mutableMapOf<String, String>()

                    // Insertion des cartes
                    for (card in importedCards) {
                        if (existingCardNames.contains(card.specificName)) continue

                        val newImagePath = card.imagePath?.let {
                            val imageName = File(it).name
                            imageBytesMap[imageName]?.let { bytes -> saveImageToInternalStorage(context, bytes) }
                        }
                        val oldId = card.id
                        val newId = cardDao.insert(card.copy(id = 0, imagePath = newImagePath))
                        oldCardIdToNewId[oldId] = newId
                        importedCardCount++
                    }

                    // Insertion des grains de pollen
                    for (pollen in importedPollen) {
                        val newCardId = oldCardIdToNewId[pollen.forgedCardId] ?: continue // Si la carte a été sautée, on saute le pollen aussi
                        val oldPollenId = pollen.id
                        val newPollenId = UUID.randomUUID().toString()
                        pollenGrainDao.insert(pollen.copy(id = newPollenId, forgedCardId = newCardId))
                        oldPollenIdToNewId[oldPollenId] = newPollenId
                    }

                    // Insertion des résultats d'analyse
                    for (analysis in importedAnalysis) {
                        val newPollenId = oldPollenIdToNewId[analysis.pollenGrainId] ?: continue
                        analysisResultDao.insert(analysis.copy(id = UUID.randomUUID().toString(), pollenGrainId = newPollenId))
                    }
                }
            }
            Log.i(TAG, "Importation de la Saga terminée. $importedCardCount cartes (et leurs données associées) ont été ajoutées.")
        } catch (e: Exception) {
            Log.e(TAG, "Erreur durant l'importation de la saga", e)
            return@withContext -1
        }
        return@withContext importedCardCount
    }

    private fun saveImageToInternalStorage(context: Context, imageBytes: ByteArray): String? {
        return try {
            val cardImagesDir = File(context.filesDir, "card_images")
            if (!cardImagesDir.exists()) cardImagesDir.mkdirs()
            val newImageFile = File(cardImagesDir, "card_${UUID.randomUUID()}.png")
            FileOutputStream(newImageFile).use { it.write(imageBytes) }
            newImageFile.absolutePath
        } catch (e: Exception) {
            Log.e(TAG, "Erreur lors de la sauvegarde de l'image importée", e)
            null
        }
    }

    private fun addFileToZip(entryName: String, data: ByteArray, zos: ZipOutputStream) {
        val entry = ZipEntry(entryName)
        zos.putNextEntry(entry)
        zos.write(data)
        zos.closeEntry()
    }

    // BOURDON'S NOTE: Nouvelle fonction pour redimensionner les images avant de les zipper.
    private fun resizeAndAddImageToZip(imageFile: File, entryName: String, zos: ZipOutputStream) {
        try {
            val originalBitmap = BitmapFactory.decodeFile(imageFile.absolutePath)
            if (originalBitmap == null) {
                Log.w(TAG, "Impossible de décoder le bitmap pour ${imageFile.path}")
                return
            }

            val (newWidth, newHeight) = calculateNewDimensions(originalBitmap.width, originalBitmap.height)

            val resizedBitmap = Bitmap.createScaledBitmap(originalBitmap, newWidth, newHeight, true)
            originalBitmap.recycle()

            ByteArrayOutputStream().use { baos ->
                resizedBitmap.compress(Bitmap.CompressFormat.PNG, 90, baos)
                addFileToZip(entryName, baos.toByteArray(), zos)
            }
            resizedBitmap.recycle()
        } catch (e: Exception) {
            Log.e(TAG, "Erreur lors du redimensionnement de l'image ${imageFile.path}", e)
        }
    }

    private fun calculateNewDimensions(width: Int, height: Int): Pair<Int, Int> {
        if (width <= IMAGE_MAX_SIZE && height <= IMAGE_MAX_SIZE) {
            return Pair(width, height)
        }
        return if (width > height) {
            val newHeight = (height.toFloat() / width.toFloat() * IMAGE_MAX_SIZE).toInt()
            Pair(IMAGE_MAX_SIZE, newHeight)
        } else {
            val newWidth = (width.toFloat() / height.toFloat() * IMAGE_MAX_SIZE).toInt()
            Pair(newWidth, IMAGE_MAX_SIZE)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/SagaArchiver.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartActivity.kt ---

package be.heyman.android.ai.kikko

import android.Manifest
import android.annotation.SuppressLint
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Rect
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.OpenableColumns
import android.util.Log
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import android.widget.Toast
import android.widget.VideoView
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.updateLayoutParams
import androidx.lifecycle.lifecycleScope
import be.heyman.android.ai.kikko.clash.ui.ClashActivity
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.deck.DeckViewerActivity
import be.heyman.android.ai.kikko.forge.ForgeWorkshopActivity
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import be.heyman.android.ai.kikko.pollen.ForgeLiveActivity
import be.heyman.android.ai.kikko.prompt.PromptEditorActivity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import java.util.zip.ZipInputStream

class StartActivity : AppCompatActivity(), ToolsDialogFragment.ToolsDialogListener {

    private val TAG = "KikkoStart"
    private var modelToTest: File? = null

    private lateinit var backgroundVideoView: VideoView
    private var scratchJob: Job? = null
    private val bellyHotspot = Rect()
    private var isReactionPlaying = false

    private lateinit var pollenGrainDao: PollenGrainDao
    private lateinit var cardDao: CardDao
    private lateinit var rawPollenCounter: TextView
    private lateinit var inForgePollenCounter: TextView
    private lateinit var totalHoneyCounter: TextView
    private lateinit var errorPollenCounter: TextView

    // BOURDON'S ADDITION: Le nouveau launcher pour les permissions multiples.
    private val requestMultiplePermissionsLauncher =
        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->
            val allGranted = permissions.entries.all { it.value }
            if (allGranted) {
                Toast.makeText(this, "Toutes les autorisations ont été accordées. La Ruche est prête !", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Certaines autorisations ont été refusées. Certaines fonctionnalités pourraient ne pas être disponibles.", Toast.LENGTH_LONG).show()
            }
        }

    private val importSagaLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        if (uri != null) {
            lifecycleScope.launch {
                val importedCount = SagaArchiver.importSaga(this@StartActivity, uri)
                if (importedCount >= 0) {
                    val message = resources.getQuantityString(R.plurals.import_saga_success, importedCount, importedCount)
                    Toast.makeText(this@StartActivity, message, Toast.LENGTH_LONG).show()
                    updateForgeCounters()
                } else {
                    Toast.makeText(this@StartActivity, R.string.import_saga_failure, Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private val addModelLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        if (uri != null) {
            lifecycleScope.launch {
                Toast.makeText(this@StartActivity, R.string.importing_new_model, Toast.LENGTH_SHORT).show()
                val localPath = copyModelToAppStorage(uri, "imported_models")
                if (localPath != null) {
                    Toast.makeText(this@StartActivity, R.string.import_new_model_success, Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(this@StartActivity, R.string.import_new_model_failure, Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private val importVoskModelLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            lifecycleScope.launch {
                handleVoskModelImport(it)
            }
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_start)
        Log.d(TAG, "onCreate: L'activité de démarrage est en cours de création.")

        // BOURDON'S ADDITION: La vérification des permissions est maintenant la première chose que nous faisons.
        checkAndRequestPermissions()

        pollenGrainDao = PollenGrainDao(this)
        cardDao = CardDao(this)
        Log.d(TAG, "onCreate: DAOs have been initialized.")

        backgroundVideoView = findViewById(R.id.background_video_view)
        setupBellyScratchListener()

        bindViewsAndSetupNavigation()
        setupWindowInsets()
    }

    // BOURDON'S ADDITION: Nouvelle fonction pour gérer la logique des permissions.
    private fun checkAndRequestPermissions() {
        val requiredPermissions = mutableListOf(
            Manifest.permission.CAMERA,
            Manifest.permission.RECORD_AUDIO,
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.ACCESS_COARSE_LOCATION
        )

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            requiredPermissions.add(Manifest.permission.BLUETOOTH_SCAN)
            requiredPermissions.add(Manifest.permission.BLUETOOTH_CONNECT)
            requiredPermissions.add(Manifest.permission.BLUETOOTH_ADVERTISE)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            requiredPermissions.add(Manifest.permission.POST_NOTIFICATIONS)
            requiredPermissions.add(Manifest.permission.NEARBY_WIFI_DEVICES)
        }

        val missingPermissions = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (missingPermissions.isNotEmpty()) {
            Log.i(TAG, "Demande des autorisations manquantes: $missingPermissions")
            requestMultiplePermissionsLauncher.launch(missingPermissions.toTypedArray())
        } else {
            Log.i(TAG, "Toutes les autorisations nécessaires sont déjà accordées.")
        }
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume: L'activité est visible, mise à jour des compteurs.")
        updateForgeCounters()

        if (!isReactionPlaying) {
            setupBackgroundVideo()
        }
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause: Mise en pause de l'activité, la vidéo s'arrête.")
        backgroundVideoView.stopPlayback()
    }

    private fun setupWindowInsets() {
        val rootContainer: View = findViewById(R.id.start_root_container)
        val toolsButton: View = findViewById(R.id.start_button_tools)

        ViewCompat.setOnApplyWindowInsetsListener(rootContainer) { _, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())

            toolsButton.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                topMargin = systemBars.top + 16
            }
            WindowInsetsCompat.CONSUMED
        }
    }


    private fun bindViewsAndSetupNavigation() {
        val buttonDecks: View = findViewById(R.id.button_kikko)
        val buttonPollen: View = findViewById(R.id.button_pollen)
        val buttonForge: View = findViewById(R.id.button_forge)
        val buttonClash: View = findViewById(R.id.button_clash)
        val buttonTools: ImageButton = findViewById(R.id.start_button_tools)

        rawPollenCounter = findViewById(R.id.raw_pollen_counter)
        inForgePollenCounter = findViewById(R.id.in_forge_pollen_counter)
        totalHoneyCounter = findViewById(R.id.total_honey_counter)
        errorPollenCounter = findViewById(R.id.error_pollen_counter)
        Log.d(TAG, "bindViewsAndSetupNavigation: Toutes les vues ont été liées.")

        buttonDecks.setOnClickListener {
            startActivity(Intent(this, DeckViewerActivity::class.java))
        }
        buttonPollen.setOnClickListener {
            startActivity(Intent(this, ForgeLiveActivity::class.java))
        }
        buttonForge.setOnClickListener {
            startActivity(Intent(this, ForgeWorkshopActivity::class.java))
        }
        buttonClash.setOnClickListener {
            startActivity(ClashActivity.newIntent(this))
        }
        buttonTools.setOnClickListener {
            ToolsDialogFragment.newInstance().show(supportFragmentManager, ToolsDialogFragment.TAG)
        }
    }

    private fun updateForgeCounters() {
        lifecycleScope.launch {
            val pollenCounts = pollenGrainDao.countByStatus()
            val allCards = cardDao.getAll()
            val totalCardsCount = allCards.size

            withContext(Dispatchers.Main) {
                val forgingCount = (pollenCounts[PollenStatus.IDENTIFYING] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_DESCRIPTION] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_STATS] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_QUIZ] ?: 0) +
                        (pollenCounts[PollenStatus.PENDING_TRANSLATION] ?: 0)

                updateCounterView(rawPollenCounter, R.string.counter_label_raw, pollenCounts[PollenStatus.RAW])
                updateCounterView(inForgePollenCounter, R.string.counter_label_forging, forgingCount)
                updateCounterView(totalHoneyCounter, R.string.counter_label_honey, totalCardsCount)
                updateCounterView(errorPollenCounter, R.string.counter_label_error, pollenCounts[PollenStatus.ERROR])
            }
        }
    }

    private fun updateCounterView(textView: TextView, labelResId: Int, count: Int?) {
        val countValue = count ?: 0
        textView.text = getString(labelResId, countValue)
        textView.visibility = View.VISIBLE
    }

    private fun setupBackgroundVideo() {
        Log.d(TAG, "setupBackgroundVideo: Configuration de la vidéo principale.")
        playVideo(R.raw.kikko_main, isLooping = true)
    }

    private fun playVideo(videoResId: Int, isLooping: Boolean) {
        val resourceName = resources.getResourceEntryName(videoResId)
        Log.d(TAG, "playVideo: Lancement de la vidéo '$resourceName' (loop: $isLooping)")
        val videoPath = "android.resource://" + packageName + "/" + videoResId
        val uri = Uri.parse(videoPath)

        backgroundVideoView.setVideoURI(uri)
        backgroundVideoView.setOnPreparedListener { mediaPlayer ->
            mediaPlayer.isLooping = isLooping
            mediaPlayer.setVolume(0f, 0f)
            mediaPlayer.start()
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupBellyScratchListener() {
        Log.d(TAG, "setupBellyScratchListener: Le listener de grattage est maintenant actif.")
        backgroundVideoView.setOnTouchListener { view, event ->
            if (isReactionPlaying) {
                return@setOnTouchListener false
            }

            val x = event.x.toInt()
            val y = event.y.toInt()

            val viewWidth = view.width
            val viewHeight = view.height
            bellyHotspot.set(
                (viewWidth * 0.25).toInt(),
                (viewHeight * 0.40).toInt(),
                (viewWidth * 0.75).toInt(),
                (viewHeight * 0.80).toInt()
            )

            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    if (bellyHotspot.contains(x, y)) {
                        scratchJob = lifecycleScope.launch {
                            delay(1000)
                            triggerBellyScratchEvent()
                        }
                    }
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    if (!bellyHotspot.contains(x, y)) {
                        scratchJob?.cancel()
                    }
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    scratchJob?.cancel()
                    true
                }
                else -> false
            }
        }
    }

    private fun triggerBellyScratchEvent() {
        if (isReactionPlaying) return
        isReactionPlaying = true

        runOnUiThread {
            Log.i(TAG, "triggerBellyScratchEvent: Événement déclenché ! Changement de vidéo.")
            Toast.makeText(this, R.string.secret_interaction_unlocked, Toast.LENGTH_SHORT).show()

            playVideo(R.raw.kikko_deck, isLooping = false)

            backgroundVideoView.setOnCompletionListener {
                Log.i(TAG, "onCompletion: La vidéo de réaction est terminée. Retour à la vidéo principale.")
                isReactionPlaying = false
                playVideo(R.raw.kikko_main, isLooping = true)
                backgroundVideoView.setOnCompletionListener(null)
            }
        }
    }

    private suspend fun copyModelToAppStorage(sourceUri: Uri, directory: String): String? = withContext(Dispatchers.IO) {
        val tag = "ModelStorage"
        try {
            val fileName = contentResolver.query(sourceUri, null, null, null, null)?.use { cursor ->
                val nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)
                cursor.moveToFirst()
                cursor.getString(nameIndex)
            } ?: "imported_file_${System.currentTimeMillis()}"
            val destDir = File(filesDir, directory)
            if (!destDir.exists()) destDir.mkdirs()
            val destFile = File(destDir, fileName)
            contentResolver.openInputStream(sourceUri)?.use { inputStream ->
                FileOutputStream(destFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
            }
            destFile.absolutePath
        } catch (e: Exception) {
            Log.e(tag, "Échec de la copie du fichier", e)
            null
        }
    }

    override fun onExportSagaRequested() {
        lifecycleScope.launch {
            val sagaUri = SagaArchiver.exportSaga(this@StartActivity)
            if (sagaUri != null) {
                val shareIntent = Intent().apply {
                    action = Intent.ACTION_SEND
                    putExtra(Intent.EXTRA_STREAM, sagaUri)
                    type = "application/zip"
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }
                startActivity(Intent.createChooser(shareIntent, getString(R.string.share_saga_title)))
            } else {
                Toast.makeText(this@StartActivity, R.string.export_saga_failure, Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onImportSagaRequested() {
        importSagaLauncher.launch("*/*")
    }

    override fun onDeleteModelRequested(modelFile: File) {
        if (modelFile.exists() && modelFile.delete()) {
            Toast.makeText(this, getString(R.string.model_deleted_success, modelFile.name), Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, getString(R.string.model_deleted_failure, modelFile.name), Toast.LENGTH_SHORT).show()
        }
    }

    override fun onAddModelRequested() {
        addModelLauncher.launch("*/*")
    }

    override fun onManagePromptsRequested() {
        startActivity(Intent(this, PromptEditorActivity::class.java))
    }

    private suspend fun handleVoskModelImport(uri: Uri) = withContext(Dispatchers.IO) {
        val modelName = getVoskModelNameFromZip(uri)
        if (modelName == null) {
            withContext(Dispatchers.Main) { Toast.makeText(this@StartActivity, R.string.vosk_model_import_invalid_zip, Toast.LENGTH_LONG).show() }
            return@withContext
        }
        val modelDir = File(File(filesDir, "vosk-models"), modelName)
        try {
            if (modelDir.exists()) modelDir.deleteRecursively()
            modelDir.mkdirs()
            contentResolver.openInputStream(uri)?.use { inputStream ->
                unzip(inputStream, modelDir, modelName)
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@StartActivity, getString(R.string.vosk_model_import_success, modelName), Toast.LENGTH_LONG).show()
                }
            } ?: throw Exception("Impossible d'ouvrir le flux de données pour l'URI.")
        } catch (e: Exception) {
            Log.e(TAG, "Échec de l'importation du modèle Vosk", e)
            withContext(Dispatchers.Main) {
                Toast.makeText(this@StartActivity, getString(R.string.vosk_model_import_failure, e.message), Toast.LENGTH_LONG).show()
            }
            if (modelDir.exists()) modelDir.deleteRecursively()
        }
    }

    @Throws(Exception::class)
    private fun getVoskModelNameFromZip(uri: Uri): String? {
        contentResolver.openInputStream(uri)?.use { inputStream ->
            ZipInputStream(inputStream).use { zis ->
                return zis.nextEntry?.name?.substringBefore('/')
            }
        }
        return null
    }

    @Throws(Exception::class)
    private fun unzip(inputStream: InputStream, destination: File, rootFolder: String) {
        ZipInputStream(inputStream).use { zis ->
            var zipEntry = zis.nextEntry
            while (zipEntry != null) {
                if (zipEntry.name.startsWith("$rootFolder/")) {
                    val newName = zipEntry.name.substringAfter("$rootFolder/")
                    if (newName.isNotEmpty()) {
                        val newFile = File(destination, newName)
                        if (!newFile.canonicalPath.startsWith(destination.canonicalPath + File.separator)) {
                            throw SecurityException("Zip Slip Attack détectée : ${zipEntry.name}")
                        }
                        if (zipEntry.isDirectory) {
                            if (!newFile.isDirectory && !newFile.mkdirs()) {
                                throw java.io.IOException("Échec de la création du répertoire ${newFile}")
                            }
                        } else {
                            val parent = newFile.parentFile
                            if (parent != null && !parent.isDirectory && !parent.mkdirs()) {
                                throw java.io.IOException("Échec de la création du répertoire ${parent}")
                            }
                            FileOutputStream(newFile).use { fos ->
                                val buffer = ByteArray(1024)
                                var len: Int
                                while (zis.read(buffer).also { len = it } > 0) {
                                    fos.write(buffer, 0, len)
                                }
                            }
                        }
                    }
                }
                zipEntry = zis.nextEntry
            }
        }
    }

    override fun onNukeDatabaseRequested() {
        lifecycleScope.launch {
            Log.w("BOURDON_NUKE", "Demande de purge de la base de données reçue.")
            withContext(Dispatchers.IO) {
                pollenGrainDao.nuke()
                cardDao.nuke()
            }
            withContext(Dispatchers.Main) {
                Toast.makeText(this@StartActivity, R.string.hive_memory_cleared, Toast.LENGTH_LONG).show()
                updateForgeCounters()
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartViewModel.kt ---

package be.heyman.android.ai.kikko

import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import javax.inject.Inject

data class StartUiState(
    val isLoading: Boolean = false,
    val statusMessage: String? = null,
    val errorMessage: String? = null
)


class StartViewModel @Inject constructor() : ViewModel() {

    private val _uiState = MutableStateFlow(StartUiState())
    val uiState = _uiState.asStateFlow()

    fun clearError() {
        _uiState.update { it.copy(errorMessage = null) }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/StartViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/SttVoskService.kt ---

package be.heyman.android.ai.kikko

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import be.heyman.android.ai.kikko.data.Model
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.vosk.Recognizer
import org.vosk.android.RecognitionListener
import org.vosk.android.SpeechService
import java.io.File
import java.io.IOException

enum class VoskStatus {
    IDLE,
    LOADING,
    READY,
    LISTENING,
    FINAL_RESULT,
    ERROR
}

data class VoskResult(
    val status: VoskStatus,
    val text: String = "",
    val isPartial: Boolean = false
)

object SttVoskService {
    private const val TAG = "SttVoskService"

    private var voskModel: org.vosk.Model? = null
    private var speechService: SpeechService? = null
    private var currentModelPath: String? = null

    private val _voskResult = MutableLiveData<VoskResult>()
    val voskResult: LiveData<VoskResult> = _voskResult

    private val voskTranscript = StringBuilder()

    fun isModelLoaded(): Boolean {
        return voskModel != null
    }

    fun loadModel(modelToLoad: Model, baseDir: File, onFinished: (Boolean) -> Unit) {
        val modelPath = File(baseDir, modelToLoad.name).absolutePath
        if (currentModelPath == modelPath && voskModel != null) {
            onFinished(true)
            return
        }

        _voskResult.postValue(VoskResult(VoskStatus.LOADING, "Chargement du modèle ${modelToLoad.name}..."))

        CoroutineScope(Dispatchers.IO).launch {
            try {
                voskModel?.close()
                voskModel = org.vosk.Model(modelPath)
                currentModelPath = modelPath
                withContext(Dispatchers.Main) {
                    _voskResult.postValue(VoskResult(VoskStatus.READY, "Modèle ${modelToLoad.name} prêt."))
                    onFinished(true)
                }
            } catch (e: IOException) {
                withContext(Dispatchers.Main) {
                    _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Erreur chargement modèle: ${e.message}"))
                    onFinished(false)
                }
            }
        }
    }

    fun startListening() {
        if (speechService != null) return
        val localModel = voskModel ?: run {
            _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Aucun modèle Vosk n'est chargé."))
            return
        }

        voskTranscript.clear()
        _voskResult.postValue(VoskResult(VoskStatus.LISTENING, "Écoute..."))

        try {
            val recognizer = Recognizer(localModel, 16000.0f)
            speechService = SpeechService(recognizer, 16000.0f)
            speechService?.startListening(recognitionListener)
        } catch (e: IOException) {
            _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Erreur au démarrage: ${e.message}"))
        }
    }

    fun stopListening() {
        speechService?.stop()
        speechService = null
        if (_voskResult.value?.status == VoskStatus.LISTENING) {
            _voskResult.postValue(VoskResult(VoskStatus.IDLE, voskTranscript.toString()))
        }
    }

    fun reset() {
        stopListening()
        voskTranscript.clear()
        _voskResult.postValue(VoskResult(VoskStatus.IDLE, ""))
        Log.d(TAG, "Service Vosk réinitialisé.")
    }

    fun shutdown() {
        speechService?.shutdown()
        voskModel?.close()
        speechService = null
        voskModel = null
        currentModelPath = null
    }

    private val recognitionListener = object : RecognitionListener {
        override fun onResult(hypothesis: String?) {
            try {
                val resultText = hypothesis?.let { JSONObject(it).getString("text") } ?: ""
                if (resultText.isNotBlank()) {
                    voskTranscript.append(resultText).append(" ")
                    _voskResult.postValue(VoskResult(VoskStatus.FINAL_RESULT, voskTranscript.toString().trim()))
                }
            } catch (e: Exception) {
                // Ignore parsing errors
            }
        }

        override fun onPartialResult(hypothesis: String?) {
            try {
                val partialText = hypothesis?.let { JSONObject(it).getString("partial") } ?: ""
                _voskResult.postValue(VoskResult(VoskStatus.LISTENING, voskTranscript.toString() + partialText, isPartial = true))
            } catch (e: Exception) {
                // Ignore parsing errors
            }
        }

        override fun onFinalResult(hypothesis: String?) {
            onResult(hypothesis)
            onListeningStopped()
        }

        override fun onError(e: Exception?) {
            _voskResult.postValue(VoskResult(VoskStatus.ERROR, "Erreur: ${e?.message}"))
            onListeningStopped()
        }

        override fun onTimeout() {
            onListeningStopped()
        }

        private fun onListeningStopped(){
            if(speechService != null){
                stopListening()
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/SttVoskService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsDialogFragment.kt ---

package be.heyman.android.ai.kikko

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.RadioGroup
import android.widget.TextView
import android.widget.Toast
import androidx.fragment.app.DialogFragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.data.ModelCatalogue
import be.heyman.android.ai.kikko.prompt.PromptEditorActivity
import be.heyman.android.ai.kikko.ui.adapters.LocalModelAdapter
import be.heyman.android.ai.kikko.worker.DownloadManagerKikko
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.switchmaterial.SwitchMaterial
import java.io.File

class ToolsDialogFragment : DialogFragment() {

    interface ToolsDialogListener {
        fun onExportSagaRequested()
        fun onImportSagaRequested()
        fun onAddModelRequested()
        fun onDeleteModelRequested(modelFile: File)
        fun onNukeDatabaseRequested()
        // BOURDON'S ADDITION: Nouvelle méthode pour lancer l'éditeur de prompts.
        fun onManagePromptsRequested()
    }

    private var listener: ToolsDialogListener? = null
    private lateinit var queenManagementAdapter: LocalModelAdapter
    private lateinit var queenSelectorAdapter: QueenModelAdapter
    private val TAG = "ToolsDialog"

    private lateinit var prefs: SharedPreferences
    private lateinit var requireChargingSwitch: SwitchMaterial
    private lateinit var requireIdleSwitch: SwitchMaterial
    private lateinit var nukeDbButton: Button
    private lateinit var queenAcceleratorRadioGroup: RadioGroup
    private lateinit var downloadModelsButton: Button
    private lateinit var downloadDecksButton: Button
    // BOURDON'S ADDITION: Référence pour le nouveau bouton.
    private lateinit var managePromptsButton: Button


    companion object {
        const val TAG = "ToolsDialog"
        const val PREFS_NAME = "ForgeSettings"
        const val KEY_REQUIRE_CHARGING = "KEY_FORGE_WHILE_CHARGING"
        const val KEY_REQUIRE_IDLE = "KEY_FORGE_WHEN_IDLE"
        const val KEY_SELECTED_FORGE_QUEEN = "KEY_SELECTED_FORGE_QUEEN"
        const val KEY_SELECTED_FORGE_QUEEN_ACCELERATOR = "KEY_SELECTED_FORGE_QUEEN_ACCELERATOR"


        fun newInstance(): ToolsDialogFragment {
            return ToolsDialogFragment()
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = context as? ToolsDialogListener
            ?: throw ClassCastException("$context must implement ToolsDialogListener")
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_tools, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle(R.string.tools_dialog_title)

        prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        bindViews(view)
        setupForgeQueenSelector(view)
        setupForgeQueenAccelerator()
        setupQueenModelManagement(view)
        setupSagaButtons(view)
        setupForgeSettings()
        setupNukeButton()
        // BOURDON'S ADDITION: Appel à la nouvelle méthode de configuration.
        setupPromptManagementButton()
    }

    private fun bindViews(view: View) {
        requireChargingSwitch = view.findViewById(R.id.tools_switch_require_charging)
        requireIdleSwitch = view.findViewById(R.id.tools_switch_require_idle)
        nukeDbButton = view.findViewById(R.id.tools_button_nuke_db)
        queenAcceleratorRadioGroup = view.findViewById(R.id.tools_radiogroup_queen_accelerator)
        downloadModelsButton = view.findViewById(R.id.tools_button_download_models)
        downloadDecksButton = view.findViewById(R.id.tools_button_download_decks)
        // BOURDON'S ADDITION: Liaison du nouveau bouton.
        managePromptsButton = view.findViewById(R.id.tools_button_manage_prompts)
    }

    private fun setupForgeQueenSelector(view: View) {
        val queenSelectorRecyclerView: RecyclerView = view.findViewById(R.id.tools_recyclerview_queen_selector)
        val selectedQueenName = prefs.getString(KEY_SELECTED_FORGE_QUEEN, null)

        queenSelectorAdapter = QueenModelAdapter(
            mutableListOf(),
            selectedQueenName
        ) { selectedFile ->
            prefs.edit().putString(KEY_SELECTED_FORGE_QUEEN, selectedFile.name).apply()
            Toast.makeText(context, getString(R.string.queen_selected_toast, selectedFile.name), Toast.LENGTH_SHORT).show()
            loadForgeQueenModels()
        }

        queenSelectorRecyclerView.layoutManager = LinearLayoutManager(context)
        queenSelectorRecyclerView.adapter = queenSelectorAdapter
        loadForgeQueenModels()
    }

    private fun setupForgeQueenAccelerator() {
        val savedAccelerator = prefs.getString(KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")
        if (savedAccelerator == "CPU") {
            queenAcceleratorRadioGroup.check(R.id.tools_radio_cpu)
        } else {
            queenAcceleratorRadioGroup.check(R.id.tools_radio_gpu)
        }

        queenAcceleratorRadioGroup.setOnCheckedChangeListener { _, checkedId ->
            val selectedAccelerator = if (checkedId == R.id.tools_radio_cpu) "CPU" else "GPU"
            prefs.edit().putString(KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, selectedAccelerator).apply()
            Toast.makeText(context, getString(R.string.accelerator_set_toast, selectedAccelerator), Toast.LENGTH_SHORT).show()
        }
    }

    private fun setupQueenModelManagement(view: View) {
        val queenRecyclerView: RecyclerView = view.findViewById(R.id.tools_recyclerview_models)
        val addModelButton: Button = view.findViewById(R.id.tools_button_add_model)

        queenManagementAdapter = LocalModelAdapter(mutableListOf()) { modelFile ->
            listener?.onDeleteModelRequested(modelFile)
            loadQueenManagementModels()
        }
        queenRecyclerView.layoutManager = LinearLayoutManager(context)
        queenRecyclerView.adapter = queenManagementAdapter
        loadQueenManagementModels()
        addModelButton.setOnClickListener { listener?.onAddModelRequested() }

        downloadModelsButton.setOnClickListener {
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://www.kikko.be/model"))
            startActivity(intent)
            dismiss()
        }
    }

    private fun setupSagaButtons(view: View) {
        val exportSagaButton: Button = view.findViewById(R.id.tools_button_export_saga)
        val importSagaButton: Button = view.findViewById(R.id.tools_button_import_saga)
        importSagaButton.setOnClickListener { listener?.onImportSagaRequested(); dismiss() }
        exportSagaButton.setOnClickListener { listener?.onExportSagaRequested(); dismiss() }

        // Ajout du listener pour le nouveau bouton de téléchargement de decks
        downloadDecksButton.setOnClickListener {
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://www.kikko.be/sagas"))
            startActivity(intent)
            dismiss()
        }
    }

    // BOURDON'S ADDITION: Nouvelle méthode pour configurer le bouton de gestion des prompts.
    private fun setupPromptManagementButton() {
        managePromptsButton.setOnClickListener {
            listener?.onManagePromptsRequested()
            dismiss()
        }
    }

    private fun setupForgeSettings() {
        requireChargingSwitch.isChecked = prefs.getBoolean(KEY_REQUIRE_CHARGING, false)
        requireIdleSwitch.isChecked = prefs.getBoolean(KEY_REQUIRE_IDLE, false)

        requireChargingSwitch.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean(KEY_REQUIRE_CHARGING, isChecked).apply()
            val status = if(isChecked) getString(R.string.generic_enabled) else getString(R.string.generic_disabled)
            Toast.makeText(context, getString(R.string.forge_charging_toast, status), Toast.LENGTH_SHORT).show()
        }
        requireIdleSwitch.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean(KEY_REQUIRE_IDLE, isChecked).apply()
            val status = if(isChecked) getString(R.string.generic_enabled) else getString(R.string.generic_disabled)
            Toast.makeText(context, getString(R.string.forge_idle_toast, status), Toast.LENGTH_SHORT).show()
        }
    }

    private fun setupNukeButton() {
        nukeDbButton.setOnClickListener {
            MaterialAlertDialogBuilder(requireContext())
                .setTitle(R.string.dialog_confirmation_required_title)
                .setMessage(R.string.dialog_nuke_db_message)
                .setNegativeButton(R.string.dialog_cancel, null)
                .setPositiveButton(R.string.dialog_confirm_nuke) { _, _ ->
                    listener?.onNukeDatabaseRequested()
                    dismiss()
                }
                .show()
        }
    }

    private fun loadForgeQueenModels() {
        val modelsDir = File(requireContext().filesDir, "imported_models")
        val modelFiles = if (modelsDir.exists() && modelsDir.isDirectory) {
            modelsDir.listFiles { _, name -> name.endsWith(".task") }?.toList()?.sortedBy { it.name } ?: emptyList()
        } else {
            emptyList()
        }
        val selectedQueenName = prefs.getString(KEY_SELECTED_FORGE_QUEEN, null)
        queenSelectorAdapter.updateSelection(modelFiles, selectedQueenName)
    }

    private fun loadQueenManagementModels() {
        val modelsDir = File(requireContext().filesDir, "imported_models")
        if (modelsDir.exists() && modelsDir.isDirectory) {
            val modelFiles = modelsDir.listFiles { _, name -> name.endsWith(".task") }?.toList() ?: emptyList()
            queenManagementAdapter.updateModels(modelFiles.sortedBy { it.name })
        } else {
            queenManagementAdapter.updateModels(emptyList())
        }
        loadForgeQueenModels()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsViewModel.kt ---

package be.heyman.android.ai.kikko


import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.data.Model
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ToolsUiState(
    val isLoading: Boolean = false,
    val models: List<Model> = emptyList(),
    val errorMessage: String? = null
)


class ToolsViewModel @Inject constructor(
    // private val modelRepository: ModelRepository // Sera injecté plus tard
) : ViewModel() {

    private val _uiState = MutableStateFlow(ToolsUiState())
    val uiState = _uiState.asStateFlow()

    fun loadModels() = viewModelScope.launch {
        _uiState.update { it.copy(isLoading = true) }
        // TODO: Remplacer par un véritable appel au repository pour lister les modèles disponibles et locaux
        val dummyModels = listOf(
            Model(name = "gemma-3n-E2B-it-int4.task", url = "...", downloadFileName = "gemma-3n-E2B-it-int4.task", sizeInBytes = 1_200_000_000, llmSupportImage = true),
            Model(name = "gemma-3n-E4B-it-int4.task", url = "...", downloadFileName = "gemma-3n-E4B-it-int4.task", sizeInBytes = 2_500_000_000, llmSupportImage = true)
        )
        _uiState.update { it.copy(isLoading = false, models = dummyModels) }
    }

    fun downloadModel(model: Model) = viewModelScope.launch {
        // TODO: Implémenter la logique de téléchargement du modèle
        _uiState.update { it.copy(errorMessage = "La fonctionnalité de téléchargement n'est pas encore implémentée.") }
    }

    fun deleteModel(model: Model) = viewModelScope.launch {
        // TODO: Implémenter la logique de suppression du modèle
        _uiState.update { it.copy(errorMessage = "La fonctionnalité de suppression n'est pas encore implémentée.") }
    }

    fun clearError() {
        _uiState.update { it.copy(errorMessage = null) }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ToolsViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/TtsService.kt ---

package be.heyman.android.ai.kikko

import android.content.Context
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.Locale
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue

object TtsService : TextToSpeech.OnInitListener {

    private const val TAG = "TtsService"

    private var tts: TextToSpeech? = null
    private var isTtsInitialized = false

    private val _isSpeaking = MutableStateFlow(false)
    val isSpeaking = _isSpeaking.asStateFlow()

    private data class SpeakRequest(val utteranceId: String, val text: String, val locale: Locale, val onDone: (() -> Unit)?)
    private val directSpeakQueue = ConcurrentLinkedQueue<SpeakRequest>()

    fun initialize(context: Context) {
        if (tts == null) {
            Log.d(TAG, "Initialisation du moteur TTS...")
            tts = TextToSpeech(context.applicationContext, this)
            tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) {
                    _isSpeaking.value = true
                    Log.d(TAG, "TTS a commencé à parler: $utteranceId")
                }

                override fun onDone(utteranceId: String?) {
                    Log.d(TAG, "TTS a fini de parler: $utteranceId")
                    _isSpeaking.value = false
                    val completedRequest = directSpeakQueue.poll()
                    completedRequest?.onDone?.invoke()
                    processDirectSpeakQueue()
                }

                override fun onError(utteranceId: String?) {
                    Log.e(TAG, "Erreur TTS pour: $utteranceId")
                    _isSpeaking.value = false
                    directSpeakQueue.poll()
                    processDirectSpeakQueue()
                }
            })
        }
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isTtsInitialized = true
            Log.d(TAG, "Moteur TTS initialisé avec succès.")
            tts?.language = Locale.getDefault()
            processDirectSpeakQueue()
        } else {
            isTtsInitialized = false
            Log.e(TAG, "Échec de l'initialisation du moteur TTS. Statut: $status")
        }
    }

    fun speak(text: String, locale: Locale, onDone: (() -> Unit)? = null) {
        // BOURDON'S CRITICAL FIX: Nettoyage du texte avant de le parler.
        val cleanedText = text.replace("*", "")

        val utteranceId = "KikkoDirectSpeak-${UUID.randomUUID()}"
        val request = SpeakRequest(utteranceId, cleanedText, locale, onDone)
        directSpeakQueue.add(request)

        if (isTtsInitialized) {
            processDirectSpeakQueue()
        }
    }

    private fun processDirectSpeakQueue() {
        if (_isSpeaking.value || !isTtsInitialized || directSpeakQueue.isEmpty()) {
            return
        }

        val request = directSpeakQueue.peek() ?: return
        tts?.language = request.locale
        tts?.speak(request.text, TextToSpeech.QUEUE_ADD, null, request.utteranceId)
    }

    fun stopAndClearQueue() {
        tts?.stop()
        directSpeakQueue.clear()
        _isSpeaking.value = false
        Log.d(TAG, "TTS arrêté et file d'attente vidée.")
    }

    fun shutdown() {
        stopAndClearQueue()
        tts?.shutdown()
        tts = null
        isTtsInitialized = false
        Log.d(TAG, "Moteur TTS libéré.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/TtsService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/VoskModelAdapter.kt ---

package be.heyman.android.ai.kikko

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import java.io.File

/**
 * Adaptateur pour afficher une liste de modèles Vosk (reconnaissance vocale).
 * Déplacé depuis le package `debug` car il est utilisé par `ToolsDialogFragment`
 * pour gérer les modèles STT.
 *
 * @param models La liste mutable des fichiers de modèle Vosk à afficher.
 * @param onTestModel Callback lorsqu'un modèle est testé.
 * @param onDeleteModel Callback lorsqu'un modèle est supprimé.
 */
class VoskModelAdapter(
    private var models: MutableList<File>,
    private val onTestModel: (File) -> Unit,
    private val onDeleteModel: (File) -> Unit
) : RecyclerView.Adapter<VoskModelAdapter.ModelViewHolder>() {

    private var isListening = false

    class ModelViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val modelName: TextView = view.findViewById(R.id.vosk_model_name)
        val testButton: ImageButton = view.findViewById(R.id.button_test_vosk_model)
        val deleteButton: ImageButton = view.findViewById(R.id.button_delete_vosk_model)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ModelViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_vosk_model, parent, false)
        return ModelViewHolder(view)
    }

    override fun onBindViewHolder(holder: ModelViewHolder, position: Int) {
        val modelFile = models[position]
        holder.modelName.text = modelFile.name

        // BOURDON'S FIX: Change l'icône en fonction de l'état d'écoute.
        if (isListening) {
            holder.testButton.setImageResource(android.R.drawable.ic_media_pause) // ou une icône "stop"
        } else {
            holder.testButton.setImageResource(android.R.drawable.ic_media_play)
        }

        holder.testButton.setOnClickListener { onTestModel(modelFile) }
        holder.deleteButton.setOnClickListener { onDeleteModel(modelFile) }
    }

    override fun getItemCount() = models.size

    fun updateModels(newModels: List<File>) {
        models.clear()
        models.addAll(newModels)
        notifyDataSetChanged()
    }

    // BOURDON'S FIX: Méthode pour que le fragment puisse informer l'adaptateur de l'état.
    fun setIsListening(listening: Boolean) {
        isListening = listening
        notifyDataSetChanged() // Redessine toute la liste pour mettre à jour les icônes.
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/VoskModelAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashP2pModels.kt ---

package be.heyman.android.ai.kikko.clash.data

import android.graphics.Color

/**
 * BOURDON'S NOTE:
 * Ce fichier contient les data classes utilisées spécifiquement pour la phase de DÉCOUVERTE P2P.
 * Elles sont une copie de celles du prototype et servent de "carte de visite" légère
 * qu'un joueur envoie pour se présenter sur le réseau. Elles sont distinctes de l'entité
 * principale `KnowledgeCard` qui est bien plus riche.
 */

/**
 * Représente un seul deck de cartes dans le catalogue partiel d'un joueur pour la découverte.
 */
data class Deck(
    val name: String,
    val cardCount: Int
)

/**
 * Représente le catalogue partiel d'un joueur, encodé dans l'endpointName de Nearby.
 */
data class PlayerCatalogue(
    val playerName: String,
    val decks: List<Deck>,
    val latitude: Double? = null,
    val longitude: Double? = null,
    val wins: Int = 0,
    val losses: Int = 0,
    var color: Int = Color.WHITE
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashP2pModels.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashSettings.kt ---

package be.heyman.android.ai.kikko.clash.data

/**
 * Data class pour contenir tous les paramètres de configuration du Clash.
 */
data class ClashSettings(
    val queenModelName: String,
    val brain: String = "CPU",
    val temperature: Float = 0.44f,
    val isTtsEnabled: Boolean = true,
    val showSetupOnLaunch: Boolean = true
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashSettings.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashState.kt ---

package be.heyman.android.ai.kikko.clash.data

import be.heyman.android.ai.kikko.model.KnowledgeCard

/**
 * Représente l'état complet d'un seul duel dans l'Arène.
 * Contient les cartes combattantes, la question, le statut, les raisonnements et le verdict.
 */
data class ClashState(
    val deckName: String,
    val player1Card: KnowledgeCard,
    val player2Card: KnowledgeCard,
    var status: ClashStatus = ClashStatus.PENDING,
    var question: String? = null,
    var winner: String = "tie",
    var rawReasoning: String = "",
    var streamingReasoning: String? = "",
    var translatedReasoning: String? = "",
    // BOURDON'S REFACTOR: Ajout du champ pour le script TTS généré par l'IA.
    var ttsScript: String? = "",
    var errorMessage: String? = "",
    // BOURDON'S FIX V6: Ajout du drapeau pour le contrôle du TTS.
    var ttsHasBeenPlayed: Boolean = false,
    // BOURDON'S FIX V7: Ajout du drapeau pour le TTS de la question.
    var ttsQuestionHasBeenPlayed: Boolean = false
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashState.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashStatus.kt ---

package be.heyman.android.ai.kikko.clash.data

/**
 * Représente les différents états possibles pour un seul duel dans le tournoi.
 *
 * - PENDING: Le duel est en attente, l'inférence n'a pas encore été lancée.
 * - INFERRING: Le Juge IA (LLM) est en train de délibérer sur le verdict.
 * - TRANSLATING: Le raisonnement brut est reçu, la traduction est en cours.
 * - COMPLETED: Le verdict et le raisonnement traduit sont finaux et prêts à être affichés.
 * - ERROR: Une erreur est survenue durant l'inférence ou la traduction.
 */
enum class ClashStatus {
    PENDING,
    INFERRING,
    TRANSLATING,
    COMPLETED,
    ERROR
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/ClashStatus.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/P2pPayload.kt ---

package be.heyman.android.ai.kikko.clash.data

import be.heyman.android.ai.kikko.clash.helpers.LocalizedQuestion
import be.heyman.android.ai.kikko.model.KnowledgeCard

sealed class P2pPayload {
    // Échangé par les deux joueurs pendant la sélection.
    // BOURDON'S FIX : Ajout de l'ID du payload de l'image. La carte sera "allégée" (sans imagePath).
    data class CardSelectionPayload(
        val deckName: String,
        val selectedCard: KnowledgeCard,
        val imagePayloadId: Long? = null
    ) : P2pPayload()

    // Envoyé par l'Hôte pour démarrer le Clash sur les deux appareils.
    data class StartClashPayload(val command: String = "START_CLASH") : P2pPayload()

    // Envoyé par l'Hôte à l'Invité pour synchroniser la question du duel.
    data class QuestionPayload(val deckName: String, val question: LocalizedQuestion) : P2pPayload()

    // Envoyé par l'Hôte à l'Invité avec le résultat de chaque duel.
    data class DuelResultPayload(val deckName: String, val winner: String, val reasoning: String, val ttsScript: String) : P2pPayload()

    // Envoyé par l'Hôte pour passer au duel suivant.
    data class NextDuelPayload(val command: String = "NEXT_DUEL") : P2pPayload()
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/data/P2pPayload.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashLlmHelper.kt ---

// app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashLlmHelper.kt

package be.heyman.android.ai.kikko.clash.helpers

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.data.Accelerator
import be.heyman.android.ai.kikko.data.Model
import com.google.mediapipe.tasks.genai.llminference.GraphOptions
import com.google.mediapipe.tasks.genai.llminference.LlmInference
import com.google.mediapipe.tasks.genai.llminference.LlmInferenceSession
import javax.inject.Inject

private const val TAG = "ClashLlmHelper"

typealias ResultListener = (partialResult: String, done: Boolean) -> Unit

class ClashLlmHelper @Inject constructor(
    val context: Context
) {
    private var llmInference: LlmInference? = null
    private var session: LlmInferenceSession? = null
    private var currentSessionTemperature: Float? = null

    fun initialize(model: Model, accelerator: String): String? {
        Log.d(TAG, "INITIALISATION ...")
        cleanUp()
        try {
            Log.d(TAG, "INITIALISATION BRUTE DU MOTEUR...")
            val optionsBuilder = LlmInference.LlmInferenceOptions.builder()
                .setModelPath(model.url)
                .setMaxTokens(4096)
                .setPreferredBackend(
                    if (accelerator == Accelerator.GPU.label) LlmInference.Backend.GPU
                    else LlmInference.Backend.CPU
                )
            val options = optionsBuilder.build()
            llmInference = LlmInference.createFromOptions(context, options)
            Log.d(TAG, "MOTEUR CRÉÉ AVEC SUCCÈS.")

            // On crée la session initiale IMMÉDIATEMENT.
            session = createNewSession(0.44f) // Température par défaut
            if (session == null) {
                throw IllegalStateException("Échec de la création de la session LlmInference.")
            }
            Log.d(TAG, "SESSION CRÉÉE AVEC SUCCÈS.")
            return null // Succès
        } catch (e: Exception) {
            val errorMsg = e.message ?: "Erreur inconnue pendant l'initialisation"
            Log.e(TAG, "L'initialisation du ClashLlmHelper a échoué: $errorMsg", e)
            cleanUp()
            return errorMsg
        }
    }

    private fun createNewSession(temperature: Float): LlmInferenceSession? {
        val inferenceEngine = llmInference ?: return null

        return try {
            Log.d(TAG, "Création d'une nouvelle session avec température: $temperature")
            currentSessionTemperature = temperature

            val sessionOptions = LlmInferenceSession.LlmInferenceSessionOptions.builder()
                .setTemperature(temperature)
                .setTopK(40)
                .setGraphOptions(
                    GraphOptions.builder()
                        .setEnableVisionModality(false)
                        .build()
                )
                .build()

            LlmInferenceSession.createFromOptions(inferenceEngine, sessionOptions)
        } catch (e: Exception) {
            Log.e(TAG, "Échec de la création de la nouvelle session", e)
            null
        }
    }

    fun resetSession() {
        Log.d(TAG, "Réinitialisation de la session du Juge.")
        session?.close()
        session = createNewSession(currentSessionTemperature ?: 0.44f)
    }

    fun generateResponse(
        prompt: String,
        temperature: Float,
        resultListener: ResultListener
    ) {
        if (currentSessionTemperature != temperature) {
            session?.close()
            session = createNewSession(temperature)
        }

        val currentSession = session ?: run {
            val errorMsg = "Erreur Critique: La session est nulle."
            Log.e(TAG, errorMsg)
            resultListener(errorMsg, true)
            return
        }

        try {
            currentSession.addQueryChunk(prompt)
            currentSession.generateResponseAsync(resultListener)
        } catch (e: Exception) {
            Log.e(TAG, "Erreur durant l'inférence dans le Clash", e)
            resultListener(e.message ?: "Error during inference", true)
        }
    }

    fun cleanUp() {
        session?.close()
        llmInference?.close()
        session = null
        llmInference = null
        currentSessionTemperature = null
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashLlmHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashPromptGenerator.kt ---

package be.heyman.android.ai.kikko.clash.helpers

import android.content.Context
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.prompt.PromptManager
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.IOException
import java.util.Locale

data class LocalizedQuestion(val en: String, val fr: String, val ja: String)

object ClashPromptGenerator {

    private var clashQuestionBank: Map<String, List<LocalizedQuestion>> = emptyMap()
    private var isQuestionBankLoaded = false

    fun loadClashQuestions(context: Context) {
        if (isQuestionBankLoaded) return

        try {
            val jsonString = context.assets.open("clash_questions_i18n.json").bufferedReader().use { it.readText() }
            val type = object : TypeToken<Map<String, List<LocalizedQuestion>>>() {}.type
            clashQuestionBank = Gson().fromJson(jsonString, type)
            isQuestionBankLoaded = true
        } catch (ioException: IOException) {
            ioException.printStackTrace()
        }
    }

    fun getRandomClashQuestionSet(deckName: String): LocalizedQuestion? {
        if (!isQuestionBankLoaded) return null
        return clashQuestionBank[deckName]?.randomOrNull()
    }

    fun getLocalizedQuestion(question: LocalizedQuestion): String {
        return when (Locale.getDefault().language) {
            "fr" -> question.fr
            "ja" -> question.ja
            else -> question.en
        }
    }

    fun generateClashVerdictPrompt(question: String, card1: KnowledgeCard, card2: KnowledgeCard): String {
        val player1Json = Gson().toJson(card1.stats?.items ?: emptyMap<String, String>())
        val player2Json = Gson().toJson(card2.stats?.items ?: emptyMap<String, String>())

        val deviceLanguage = when (Locale.getDefault().language) {
            "fr" -> "French"
            "ja" -> "Japanese"
            else -> "English"
        }

        // BOURDON'S FINAL REFACTOR: Le générateur récupère le prompt brut et effectue le formatage.
        val rawPrompt = PromptManager.getPrompt("clash_verdict")
        return String.format(
            rawPrompt,
            question,
            deviceLanguage,
            card1.specificName,
            player1Json,
            card2.specificName,
            player2Json
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashPromptGenerator.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashTranslationHelper.kt ---

package be.heyman.android.ai.kikko.clash.helpers

import android.util.Log
import com.google.android.gms.tasks.Tasks
import com.google.mlkit.common.model.DownloadConditions
import com.google.mlkit.nl.languageid.LanguageIdentification
import com.google.mlkit.nl.translate.Translation
import com.google.mlkit.nl.translate.Translator
import com.google.mlkit.nl.translate.TranslatorOptions
import java.util.Locale

/**
 * Un helper pour encapsuler la logique de traduction de ML Kit pour le Clash.
 */
object ClashTranslationHelper {

    private const val TAG = "ClashTranslationHelper"

    private var translator: Translator? = null
    private var lastOptions: TranslatorOptions? = null
    private val languageIdentifier = LanguageIdentification.getClient()

    /**
     * Traduit un texte donné vers la langue cible spécifiée.
     * Détecte automatiquement la langue source.
     */
    suspend fun translate(textToTranslate: String, targetLanguage: String): String {
        if (textToTranslate.isBlank()) {
            return ""
        }

        return try {
            val languageCode = Tasks.await(languageIdentifier.identifyLanguage(textToTranslate))
            if (languageCode == "und") {
                return "[Erreur: Langue non détectée]"
            }

            if (languageCode == targetLanguage) {
                val langName = Locale.forLanguageTag(languageCode).displayName
                return "[Texte déjà en ${langName}]"
            }

            Log.d(TAG, "Langue détectée: $languageCode, Cible: $targetLanguage")
            executeTranslation(textToTranslate, languageCode, targetLanguage)
        } catch (e: Exception) {
            Log.e(TAG, "L'identification ou la traduction a échoué", e)
            "[Erreur: ${e.message}]"
        }
    }

    private suspend fun executeTranslation(textToTranslate: String, sourceLanguage: String, targetLanguage: String): String {
        val options = TranslatorOptions.Builder()
            .setSourceLanguage(sourceLanguage)
            .setTargetLanguage(targetLanguage)
            .build()

        // Réutilise ou crée un nouveau traducteur si les options ont changé
        if (lastOptions != options) {
            closeTranslator()
            lastOptions = options
            translator = Translation.getClient(options)
        }
        val localTranslator = translator ?: return "[Erreur: Client de traduction non initialisé]"

        // Télécharge le modèle si nécessaire
        val conditions = DownloadConditions.Builder().requireWifi().build()
        Tasks.await(localTranslator.downloadModelIfNeeded(conditions))
        Log.d(TAG, "Modèle de traduction prêt.")

        // Effectue la traduction
        return Tasks.await(localTranslator.translate(textToTranslate))
    }

    fun closeTranslator() {
        translator?.close()
        translator = null
        lastOptions = null
        Log.d(TAG, "Client de traduction fermé.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/ClashTranslationHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/TtsService.kt ---

package be.heyman.android.ai.kikko.clash.helpers

import android.content.Context
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import java.util.Locale
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue

object TtsService : TextToSpeech.OnInitListener {

    private const val TAG = "KikkoTtsService"

    private var tts: TextToSpeech? = null
    private var isTtsInitialized = false
    private var isSpeaking = false

    private data class SpeakRequest(val utteranceId: String, val text: String, val locale: Locale, val onDone: (() -> Unit)?)
    private val directSpeakQueue = ConcurrentLinkedQueue<SpeakRequest>()

    fun initialize(context: Context) {
        if (tts == null) {
            Log.d(TAG, "Initialisation du moteur TTS...")
            tts = TextToSpeech(context.applicationContext, this)
            tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) {
                    isSpeaking = true
                    Log.d(TAG, "TTS a commencé à parler: $utteranceId")
                }

                override fun onDone(utteranceId: String?) {
                    Log.d(TAG, "TTS a fini de parler: $utteranceId")
                    isSpeaking = false
                    val completedRequest = directSpeakQueue.poll()
                    completedRequest?.onDone?.invoke()
                    processDirectSpeakQueue()
                }

                override fun onError(utteranceId: String?) {
                    Log.e(TAG, "Erreur TTS pour: $utteranceId")
                    isSpeaking = false
                    directSpeakQueue.poll()
                    processDirectSpeakQueue()
                }
            })
        }
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isTtsInitialized = true
            Log.d(TAG, "Moteur TTS initialisé avec succès.")
            tts?.language = Locale.getDefault()
            processDirectSpeakQueue()
        } else {
            isTtsInitialized = false
            Log.e(TAG, "Échec de l'initialisation du moteur TTS. Statut: $status")
        }
    }

    fun speak(text: String, locale: Locale, onDone: (() -> Unit)? = null) {
        val utteranceId = "KikkoSpeak-${UUID.randomUUID()}"
        val request = SpeakRequest(utteranceId, text, locale, onDone)
        directSpeakQueue.add(request)

        if (isTtsInitialized) {
            processDirectSpeakQueue()
        }
    }

    private fun processDirectSpeakQueue() {
        if (isSpeaking || !isTtsInitialized || directSpeakQueue.isEmpty()) {
            return
        }

        val request = directSpeakQueue.peek() ?: return
        tts?.language = request.locale
        tts?.speak(request.text, TextToSpeech.QUEUE_ADD, null, request.utteranceId)
    }

    fun stopAndClearQueue() {
        tts?.stop()
        directSpeakQueue.clear()
        isSpeaking = false
        Log.d(TAG, "TTS arrêté et file d'attente vidée.")
    }

    fun shutdown() {
        stopAndClearQueue()
        tts?.shutdown()
        tts = null
        isTtsInitialized = false
        Log.d(TAG, "Moteur TTS libéré.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/helpers/TtsService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/services/ClashArenaService.kt ---

package be.heyman.android.ai.kikko.clash.services

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.Deck
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import com.google.android.gms.nearby.Nearby
import com.google.android.gms.nearby.connection.*
import com.google.android.gms.tasks.OnFailureListener
import java.nio.charset.StandardCharsets
import java.util.Locale
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.math.abs

@Singleton
class ClashArenaService @Inject constructor(
    private val context: Context
) {
    private val TAG = "ClashArenaService"
    private val connectionsClient: ConnectionsClient = Nearby.getConnectionsClient(context)

    private val STRATEGY = Strategy.P2P_STAR
    private val SERVICE_ID = "be.heyman.android.ai.kikko.SERVICE_ID"

    private var listener: ClashArenaListener? = null
    private var myName: String = "KikkoUser${(100..999).random()}"
    private val turtleColorPalette: List<Int> = context.resources.getIntArray(R.array.turtle_colors).toList()

    private val incomingFilePayloads = mutableMapOf<Long, Payload>()

    interface ClashArenaListener {
        fun onStatusUpdate(message: String)
        fun onEndpointFound(endpointId: String, catalogue: PlayerCatalogue)
        fun onEndpointLost(endpointId: String)
        fun onConnectionInitiated(endpointId: String, opponentName: String, authDigits: String)
        fun onConnectionResult(endpointId: String, isSuccess: Boolean)
        fun onDisconnected(endpointId: String)
        fun onPayloadReceived(endpointId: String, payloadString: String)
        fun onFilePayloadReceived(endpointId: String, payload: Payload)
        fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate)
    }

    fun setListener(listener: ClashArenaListener) {
        this.listener = listener
    }

    private fun detailedFailureListener(action: String): OnFailureListener {
        return OnFailureListener { e ->
            val errorMessage = "Erreur $action: ${e.localizedMessage}"
            Log.e(TAG, errorMessage, e)
            listener?.onStatusUpdate(errorMessage)
        }
    }

    fun startAdvertising(myCatalogue: PlayerCatalogue) {
        listener?.onStatusUpdate("Devenir visible...")
        val advertisingOptions = AdvertisingOptions.Builder().setStrategy(STRATEGY).build()
        val endpointNameCompact = buildEndpointName(myCatalogue)

        connectionsClient.startAdvertising(endpointNameCompact, SERVICE_ID, connectionLifecycleCallback, advertisingOptions)
            .addOnSuccessListener { listener?.onStatusUpdate("Vous êtes maintenant visible.") }
            .addOnFailureListener(detailedFailureListener("publicité"))
    }

    fun stopAdvertising() {
        connectionsClient.stopAdvertising()
        listener?.onStatusUpdate("Visibilité arrêtée.")
    }

    fun startDiscovery() {
        listener?.onStatusUpdate("Recherche d'adversaires...")
        val discoveryOptions = DiscoveryOptions.Builder().setStrategy(STRATEGY).build()
        connectionsClient.startDiscovery(SERVICE_ID, endpointDiscoveryCallback, discoveryOptions)
            .addOnSuccessListener { listener?.onStatusUpdate("Recherche en cours...") }
            .addOnFailureListener(detailedFailureListener("découverte"))
    }

    fun stopDiscovery() {
        connectionsClient.stopDiscovery()
        listener?.onStatusUpdate("Recherche arrêtée.")
    }

    fun requestConnection(endpointId: String) {
        connectionsClient.requestConnection(myName, endpointId, connectionLifecycleCallback)
            .addOnFailureListener(detailedFailureListener("demande de connexion"))
    }

    fun acceptConnection(endpointId: String) {
        connectionsClient.acceptConnection(endpointId, payloadCallback)
            .addOnFailureListener(detailedFailureListener("acceptation de connexion"))
    }

    fun rejectConnection(endpointId: String) {
        connectionsClient.rejectConnection(endpointId)
            .addOnFailureListener(detailedFailureListener("refus de connexion"))
    }

    fun sendPayload(endpointId: String, payloadString: String) {
        val payload = Payload.fromBytes(payloadString.toByteArray(StandardCharsets.UTF_8))
        connectionsClient.sendPayload(endpointId, payload)
            .addOnFailureListener(detailedFailureListener("envoi de payload"))
    }

    fun sendPayload(endpointId: String, payload: Payload) {
        connectionsClient.sendPayload(endpointId, payload)
            .addOnFailureListener(detailedFailureListener("envoi de payload fichier"))
    }

    fun disconnect(endpointId: String) {
        connectionsClient.disconnectFromEndpoint(endpointId)
    }

    fun stopAllEndpoints() {
        connectionsClient.stopAllEndpoints()
    }

    private fun buildEndpointName(myCatalogue: PlayerCatalogue): String {
        val deckCountsCsv = GameConstants.MASTER_DECK_LIST.joinToString(",") { deckName ->
            myCatalogue.decks.find { it.name == deckName }?.cardCount?.toString() ?: "0"
        }
        val recordCsv = "${myCatalogue.wins},${myCatalogue.losses}"
        val latFormatted = String.format(Locale.US, "%.6f", myCatalogue.latitude ?: 0.0)
        val lonFormatted = String.format(Locale.US, "%.6f", myCatalogue.longitude ?: 0.0)
        return "$myName|$deckCountsCsv|$recordCsv|$latFormatted $lonFormatted"
    }

    private val endpointDiscoveryCallback = object : EndpointDiscoveryCallback() {
        override fun onEndpointFound(endpointId: String, info: DiscoveredEndpointInfo) {
            try {
                val parts = info.endpointName.split('|')
                if (parts.size == 4) {
                    val name = parts[0]
                    val deckCountsCsv = parts[1].split(',')
                    val recordParts = parts[2].split(',')
                    val locationParts = parts[3].split(' ')

                    val wins = recordParts.getOrNull(0)?.toIntOrNull() ?: 0
                    val losses = recordParts.getOrNull(1)?.toIntOrNull() ?: 0
                    val lat = locationParts.getOrNull(0)?.toDoubleOrNull()
                    val lon = locationParts.getOrNull(1)?.toDoubleOrNull()

                    val reconstructedDecks = GameConstants.MASTER_DECK_LIST.mapIndexedNotNull { index, deckName ->
                        val count = deckCountsCsv.getOrNull(index)?.toIntOrNull() ?: 0
                        if (count > 0) Deck(deckName, count) else null
                    }
                    val colorIndex = abs(endpointId.hashCode()) % turtleColorPalette.size
                    val assignedColor = turtleColorPalette[colorIndex]
                    val partialCatalogue = PlayerCatalogue(name, reconstructedDecks, lat, lon, wins, losses, assignedColor)
                    listener?.onEndpointFound(endpointId, partialCatalogue)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erreur parsing endpointName: ${info.endpointName}", e)
            }
        }
        override fun onEndpointLost(endpointId: String) { listener?.onEndpointLost(endpointId) }
    }

    private val connectionLifecycleCallback = object : ConnectionLifecycleCallback() {
        override fun onConnectionInitiated(endpointId: String, info: ConnectionInfo) {
            val opponentName = info.endpointName.split('|').firstOrNull() ?: "Adversaire"
            listener?.onConnectionInitiated(endpointId, opponentName, info.authenticationDigits)
        }
        override fun onConnectionResult(endpointId: String, result: ConnectionResolution) {
            val isSuccess = result.status.statusCode == ConnectionsStatusCodes.STATUS_OK
            if (!isSuccess) {
                Log.e(TAG, "Échec de connexion. Code: ${result.status.statusCode} - ${result.status.statusMessage}")
            }
            listener?.onConnectionResult(endpointId, isSuccess)
        }
        override fun onDisconnected(endpointId: String) { listener?.onDisconnected(endpointId) }
    }

    private val payloadCallback = object : PayloadCallback() {
        override fun onPayloadReceived(endpointId: String, payload: Payload) {
            when (payload.type) {
                Payload.Type.BYTES -> {
                    val receivedJson = String(payload.asBytes()!!, StandardCharsets.UTF_8)
                    Log.i(TAG, "[P2P RECV] Payload de type BYTES (métadonnées JSON) reçu de $endpointId.")
                    listener?.onPayloadReceived(endpointId, receivedJson)
                }
                Payload.Type.FILE -> {
                    Log.i(TAG, "[P2P RECV] Payload de type FILE (image) reçu de $endpointId. En attente du transfert complet. Payload ID: ${payload.id}")
                    incomingFilePayloads[payload.id] = payload
                }
                Payload.Type.STREAM -> { /* Non utilisé */ }
            }
        }

        override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
            val payloadId = update.payloadId
            if (update.status == PayloadTransferUpdate.Status.SUCCESS) {
                val payload = incomingFilePayloads.remove(payloadId)
                if (payload != null && payload.type == Payload.Type.FILE) {
                    Log.i(TAG, "[P2P RECV] Transfert du payload ID $payloadId terminé avec succès. Notification du listener pour le traitement du fichier.")
                    listener?.onFilePayloadReceived(endpointId, payload)
                }
            } else if (update.status == PayloadTransferUpdate.Status.FAILURE) {
                Log.e(TAG, "[P2P RECV] Échec du transfert pour le payload ID $payloadId. Suppression du payload en attente.")
                incomingFilePayloads.remove(payloadId)
            }
            listener?.onPayloadTransferUpdate(endpointId, update)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/services/ClashArenaService.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashActivity.kt ---

package be.heyman.android.ai.kikko.clash.ui

import android.Manifest
import android.animation.ObjectAnimator
import android.content.Context
import android.content.Intent
import android.content.pm.ActivityInfo
import android.content.pm.PackageManager
import android.graphics.BitmapFactory
import android.location.Location
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Looper
import android.util.Log
import android.view.View
import android.view.WindowInsets
import android.view.WindowInsetsController
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.Group
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.viewpager2.widget.ViewPager2
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.clash.ui.adapter.PlayerAdapter
import be.heyman.android.ai.kikko.clash.ui.dialogs.ClashSetupDialogFragment
import be.heyman.android.ai.kikko.clash.viewmodel.ClashFlowState
import be.heyman.android.ai.kikko.clash.viewmodel.ClashMode
import be.heyman.android.ai.kikko.clash.viewmodel.ClashUiState
import be.heyman.android.ai.kikko.clash.viewmodel.ClashViewModel
import be.heyman.android.ai.kikko.clash.viewmodel.DialogState
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.ui.adapters.CardPreviewAdapter
import com.google.android.gms.location.*
import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
import kotlinx.coroutines.launch
import java.io.File


class ClashActivity : AppCompatActivity(),
    ClashSetupDialogFragment.ClashSetupListener {

    private val TAG = "ClashActivity"
    private val viewModel: ClashViewModel by viewModels()

    private lateinit var setupGroup: Group
    private lateinit var viewPager: ViewPager2
    private lateinit var backgroundPlayerView: PlayerView
    private var exoPlayer: ExoPlayer? = null

    private lateinit var randomButton: ImageButton
    private lateinit var settingsButton: ImageButton
    private lateinit var radarButton: ImageButton
    private lateinit var startSoloButton: ExtendedFloatingActionButton
    private lateinit var queenStatusTextView: TextView
    private lateinit var judgeLoadingContainer: View

    private lateinit var p1SlotFood: FrameLayout
    private lateinit var p1SlotPlant: FrameLayout
    private lateinit var p1SlotInsect: FrameLayout
    private lateinit var p1SlotBird: FrameLayout
    private lateinit var p2SlotFood: FrameLayout
    private lateinit var p2SlotPlant: FrameLayout
    private lateinit var p2SlotInsect: FrameLayout
    private lateinit var p2SlotBird: FrameLayout

    private lateinit var p2pPanel: View
    private lateinit var p2pPanelCloseButton: ImageButton
    private lateinit var p2pPanelRadarView: be.heyman.android.ai.kikko.clash.ui.views.RadarView
    private lateinit var p2pPanelStatusText: TextView
    private lateinit var p2pPanelRecyclerView: RecyclerView
    private lateinit var p2pPanelPlayerAdapter: PlayerAdapter

    private lateinit var cardSelectorPanel: View
    private lateinit var selectorDeckIcon: ImageView
    private lateinit var selectorDeckName: TextView
    private lateinit var selectorCloseButton: ImageButton
    private lateinit var selectorRecyclerView: RecyclerView
    private lateinit var selectorAdapter: CardPreviewAdapter

    private var pagerAdapter: ClashPagerAdapter? = null
    private var clashDialog: AlertDialog? = null
    private var connectionRequestDialog: AlertDialog? = null

    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient
    private var myLocation: Location? = null
    private val locationCallback: LocationCallback

    init {
        locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.lastLocation?.let {
                    myLocation = it
                    if (p2pPanel.translationX == 0f) {
                        viewModel.uiState.value.let { state ->
                            p2pPanelPlayerAdapter.updatePlayers(state.discoveredPlayers, myLocation)
                            p2pPanelRadarView.updatePlayers(state.discoveredPlayers, myLocation)
                        }
                    }
                }
            }
        }
    }

    private val requestMultiplePermissions =
        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->
            if (permissions.all { it.value }) {
                startP2PWithLocation()
            } else {
                Toast.makeText(this, R.string.p2p_permissions_required, Toast.LENGTH_LONG).show()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
        setContentView(R.layout.activity_clash_arena)
        hideSystemUI()

        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)

        bindViews()
        setupListeners()
        observeViewModel()
        setupViewPagerOnce()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
    }

    override fun onStop() {
        super.onStop()
        releasePlayer()
    }


    override fun onWindowFocusChanged(hasFocus: Boolean) {
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus) {
            hideSystemUI()
        }
    }

    private fun hideSystemUI() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            window.insetsController?.let {
                it.hide(WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars())
                it.systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
            }
        } else {
            @Suppress("DEPRECATION")
            window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_FULLSCREEN)
        }
    }

    private fun bindViews() {
        setupGroup = findViewById(R.id.clash_setup_group)
        viewPager = findViewById(R.id.tournament_viewpager)
        backgroundPlayerView = findViewById(R.id.clash_background_video_view)

        randomButton = findViewById(R.id.clash_button_random)
        settingsButton = findViewById(R.id.clash_button_settings)
        radarButton = findViewById(R.id.clash_button_radar)
        startSoloButton = findViewById(R.id.clash_button_start_solo)
        queenStatusTextView = findViewById(R.id.clash_queen_status)
        judgeLoadingContainer = findViewById(R.id.clash_judge_loading_container)


        p1SlotFood = findViewById(R.id.p1_slot_food)
        p1SlotPlant = findViewById(R.id.p1_slot_plant)
        p1SlotInsect = findViewById(R.id.p1_slot_insect)
        p1SlotBird = findViewById(R.id.p1_slot_bird)
        p2SlotFood = findViewById(R.id.p2_slot_food)
        p2SlotPlant = findViewById(R.id.p2_slot_plant)
        p2SlotInsect = findViewById(R.id.p2_slot_insect)
        p2SlotBird = findViewById(R.id.p2_slot_bird)

        cardSelectorPanel = findViewById(R.id.card_selector_panel_include)
        selectorDeckIcon = cardSelectorPanel.findViewById(R.id.selector_panel_deck_icon)
        selectorDeckName = cardSelectorPanel.findViewById(R.id.selector_panel_deck_name)
        selectorCloseButton = cardSelectorPanel.findViewById(R.id.selector_panel_close_button)
        selectorRecyclerView = cardSelectorPanel.findViewById(R.id.selector_panel_recyclerview)

        p2pPanel = findViewById(R.id.p2p_panel)
        p2pPanelCloseButton = findViewById(R.id.p2p_panel_close_button)
        p2pPanelRadarView = findViewById(R.id.p2p_panel_radar_view)
        p2pPanelStatusText = findViewById(R.id.p2p_panel_status_text)
        p2pPanelRecyclerView = findViewById(R.id.p2p_panel_recycler_view)

        p2pPanelPlayerAdapter = PlayerAdapter(emptyMap(), null) { endpointId ->
            viewModel.connectToPlayer(endpointId)
        }
        p2pPanelRecyclerView.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)
        p2pPanelRecyclerView.adapter = p2pPanelPlayerAdapter
    }

    private fun setupListeners() {
        startSoloButton.setOnClickListener { viewModel.confirmSetupAndStartSoloClash() }
        settingsButton.setOnClickListener { showClashSetupDialog() }
        randomButton.setOnClickListener { viewModel.generateRandomTeams() }

        radarButton.setOnClickListener {
            if (p2pPanel.translationX > 0f) {
                showP2pPanel()
            } else {
                hideP2pPanel()
            }
        }
        p2pPanelCloseButton.setOnClickListener { hideP2pPanel() }


        p1SlotFood.setOnClickListener { onDeckSlotClicked("Food", 1) }
        p1SlotPlant.setOnClickListener { onDeckSlotClicked("Plant", 1) }
        p1SlotInsect.setOnClickListener { onDeckSlotClicked("Insect", 1) }
        p1SlotBird.setOnClickListener { onDeckSlotClicked("Bird", 1) }

        p2SlotFood.setOnClickListener { onDeckSlotClicked("Food", 2) }
        p2SlotPlant.setOnClickListener { onDeckSlotClicked("Plant", 2) }
        p2SlotInsect.setOnClickListener { onDeckSlotClicked("Insect", 2) }
        p2SlotBird.setOnClickListener { onDeckSlotClicked("Bird", 2) }

        selectorCloseButton.setOnClickListener { hideCardSelector() }
    }

    private fun initializePlayer() {
        exoPlayer = ExoPlayer.Builder(this).build().also { player ->
            backgroundPlayerView.player = player
            val videoUri = Uri.parse("android.resource://$packageName/${R.raw.kikko_clash}")
            val mediaItem = MediaItem.fromUri(videoUri)
            player.setMediaItem(mediaItem)
            player.repeatMode = Player.REPEAT_MODE_ONE
            player.volume = 0f
            player.playWhenReady = true
            player.prepare()
        }
    }

    private fun releasePlayer() {
        exoPlayer?.release()
        exoPlayer = null
    }

    private fun showP2pPanel() {
        val panelWidth = p2pPanel.width.toFloat()
        ObjectAnimator.ofFloat(p2pPanel, "translationX", panelWidth, 0f).apply {
            duration = 300
            start()
        }
        checkPermissionsAndStartDiscovery()
    }

    private fun hideP2pPanel() {
        val panelWidth = p2pPanel.width.toFloat()
        ObjectAnimator.ofFloat(p2pPanel, "translationX", 0f, panelWidth).apply {
            duration = 300
            start()
        }
        if (viewModel.uiState.value.clashMode == ClashMode.P2P_DISCOVERING) {
            viewModel.stopP2P()
        }
    }

    private fun onDeckSlotClicked(deckName: String, playerIndex: Int) {
        Log.d(TAG, "Deck slot clicked: $deckName for player $playerIndex")

        if (viewModel.uiState.value.clashMode != ClashMode.SOLO && playerIndex == 2) {
            Toast.makeText(this, R.string.clash_waiting_for_opponent, Toast.LENGTH_SHORT).show()
            return
        }

        if (viewModel.uiState.value.isJudgeInitializing) {
            Toast.makeText(this, R.string.clash_waiting_for_judge, Toast.LENGTH_SHORT).show()
            return
        }

        lifecycleScope.launch {
            val cards = viewModel.getCardsForDeck(deckName)
            if (cards.isEmpty()) {
                Toast.makeText(this@ClashActivity, getString(R.string.clash_no_cards_in_deck, deckName), Toast.LENGTH_SHORT).show()
                return@launch
            }
            showCardSelectorForDeck(deckName, cards, playerIndex)
        }
    }

    private fun showCardSelectorForDeck(deckName: String, cards: List<KnowledgeCard>, playerIndex: Int) {
        selectorDeckName.text = getString(R.string.clash_selector_title_format, playerIndex, deckName)
        selectorDeckIcon.setImageResource(getDeckIcon(deckName))

        selectorAdapter = CardPreviewAdapter(cards.toMutableList()) { selectedCard ->
            viewModel.handleChampionSelection(deckName, selectedCard, playerIndex)
            hideCardSelector()
        }
        selectorRecyclerView.layoutManager = GridLayoutManager(this, 4)
        selectorRecyclerView.adapter = selectorAdapter

        cardSelectorPanel.visibility = View.VISIBLE
    }

    private fun hideCardSelector() {
        cardSelectorPanel.visibility = View.GONE
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    viewModel.uiState.collect { state ->
                        Log.d(TAG, "Nouvel état UI reçu: flowState=${state.flowState}, clashMode=${state.clashMode}, isJudgeInitializing=${state.isJudgeInitializing}")
                        when (state.flowState) {
                            ClashFlowState.SETUP -> showSetupUI(state)
                            ClashFlowState.DUELING -> showDuelingUI(state)
                            ClashFlowState.FINISHED -> showFinishedUI()
                        }
                        handleDialogState(state.dialogState)
                        state.errorMessage?.let {
                            Toast.makeText(this@ClashActivity, it, Toast.LENGTH_LONG).show()
                            viewModel.clearErrorMessage()
                        }
                    }
                }

                launch {
                    viewModel.p2pEvent.collect { event ->
                        when (event) {
                            is ClashViewModel.P2pEvent.ShowConnectionDialog -> {
                                showConnectionRequestDialog(event.endpointId, event.opponentName, event.authCode)
                            }
                        }
                    }
                }
            }
        }
    }

    private fun showSetupUI(state: ClashUiState) {
        setupGroup.visibility = View.VISIBLE
        viewPager.visibility = View.GONE

        judgeLoadingContainer.visibility = if (state.isJudgeInitializing) View.VISIBLE else View.GONE
        val isUiEnabled = !state.isJudgeInitializing

        if (state.clashMode == ClashMode.P2P_CARD_SELECTION && p2pPanel.translationX == 0f) {
            hideP2pPanel()
        }

        queenStatusTextView.text = state.clashSettings?.let {
            getString(R.string.clash_judge_status_format, it.queenModelName, it.brain, it.temperature)
        } ?: getString(R.string.clash_judge_status_placeholder)

        startSoloButton.isEnabled = state.isReadyToClash && isUiEnabled
        randomButton.isEnabled = isUiEnabled
        settingsButton.isEnabled = isUiEnabled
        radarButton.isEnabled = isUiEnabled

        updateAllSelectionSlots(state)

        val isPlayer1Clickable = isUiEnabled
        val isPlayer2Clickable = (state.clashMode == ClashMode.SOLO) && isUiEnabled

        p1SlotFood.isClickable = isPlayer1Clickable
        p1SlotPlant.isClickable = isPlayer1Clickable
        p1SlotInsect.isClickable = isPlayer1Clickable
        p1SlotBird.isClickable = isPlayer1Clickable

        p2SlotFood.isClickable = isPlayer2Clickable
        p2SlotPlant.isClickable = isPlayer2Clickable
        p2SlotInsect.isClickable = isPlayer2Clickable
        p2SlotBird.isClickable = isPlayer2Clickable

        p2pPanelStatusText.text = state.p2pStatus
        p2pPanelPlayerAdapter.updatePlayers(state.discoveredPlayers, myLocation)
        p2pPanelRadarView.updatePlayers(state.discoveredPlayers, myLocation)
    }

    private fun updateAllSelectionSlots(state: ClashUiState) {
        updateSelectionSlot(p1SlotFood, state.myChampions["Food"])
        updateSelectionSlot(p1SlotPlant, state.myChampions["Plant"])
        updateSelectionSlot(p1SlotInsect, state.myChampions["Insect"])
        updateSelectionSlot(p1SlotBird, state.myChampions["Bird"])

        updateSelectionSlot(p2SlotFood, state.opponentChampions["Food"])
        updateSelectionSlot(p2SlotPlant, state.opponentChampions["Plant"])
        updateSelectionSlot(p2SlotInsect, state.opponentChampions["Insect"])
        updateSelectionSlot(p2SlotBird, state.opponentChampions["Bird"])
    }

    private fun updateSelectionSlot(slotView: FrameLayout, card: KnowledgeCard?) {
        val placeholderButton = slotView.getChildAt(0)
        val cardThumbnail = slotView.getChildAt(1)

        if (card == null) {
            placeholderButton.visibility = View.VISIBLE
            cardThumbnail.visibility = View.GONE
        } else {
            placeholderButton.visibility = View.GONE
            cardThumbnail.visibility = View.VISIBLE
            val cardNameView: TextView = cardThumbnail.findViewById(R.id.card_thumbnail_name)
            val cardImageView: ImageView = cardThumbnail.findViewById(R.id.card_thumbnail_image)
            cardNameView.text = card.specificName
            card.imagePath?.let { path ->
                val imgFile = File(path)
                if (imgFile.exists()) {
                    cardImageView.setImageBitmap(BitmapFactory.decodeFile(imgFile.absolutePath))
                } else {
                    cardImageView.setImageResource(R.drawable.ic_placeholder_card)
                }
            } ?: cardImageView.setImageResource(R.drawable.ic_placeholder_card)
        }
    }


    private fun showDuelingUI(state: ClashUiState) {
        Log.d(TAG, "showDuelingUI: Passage à l'écran de duel.")
        setupGroup.visibility = View.GONE
        viewPager.visibility = View.VISIBLE

        if (pagerAdapter == null || pagerAdapter?.itemCount != state.clashStates.size) {
            pagerAdapter = ClashPagerAdapter(this, state.clashStates.size)
            viewPager.adapter = pagerAdapter
        }

        if (viewPager.currentItem != state.currentDuelIndex && state.currentDuelIndex != -1) {
            viewPager.setCurrentItem(state.currentDuelIndex, true)
        }
    }


    private fun showFinishedUI() {
        Toast.makeText(this, R.string.clash_tournament_finished, Toast.LENGTH_LONG).show()
        lifecycleScope.launch {
            kotlinx.coroutines.delay(2000)
            viewModel.stopP2P()
            finish()
        }
    }

    private fun checkPermissionsAndStartDiscovery() {
        val requiredPermissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            arrayOf(Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_ADVERTISE, Manifest.permission.BLUETOOTH_CONNECT, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.NEARBY_WIFI_DEVICES)
        } else {
            arrayOf(Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_ADVERTISE, Manifest.permission.BLUETOOTH_CONNECT, Manifest.permission.ACCESS_FINE_LOCATION)
        }
        val missingPermissions = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }
        if (missingPermissions.isEmpty()) {
            startP2PWithLocation()
        } else {
            requestMultiplePermissions.launch(missingPermissions.toTypedArray())
        }
    }


    private fun startP2PWithLocation() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }
        fusedLocationProviderClient.lastLocation.addOnSuccessListener { location: Location? ->
            myLocation = location
            viewModel.startP2PDiscovery(myLocation)
        }
        startLocationUpdates()
    }


    private fun startLocationUpdates() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }
        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000).build()
        fusedLocationProviderClient.requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper())
    }

    private fun stopLocationUpdates() {
        fusedLocationProviderClient.removeLocationUpdates(locationCallback)
    }

    private fun setupViewPagerOnce() {
        viewPager.isUserInputEnabled = true
        viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                super.onPageSelected(position)
                viewModel.onDuelSelected(position)
            }
        })
    }

    private fun showClashSetupDialog() {
        if (supportFragmentManager.findFragmentByTag(ClashSetupDialogFragment.TAG) == null) {
            val currentState = viewModel.uiState.value
            val dialog = ClashSetupDialogFragment.newInstance(
                availableModels = currentState.availableModels,
                currentSettings = currentState.clashSettings
            )
            dialog.show(supportFragmentManager, ClashSetupDialogFragment.TAG)
        }
    }

    private fun handleDialogState(dialogState: DialogState) {
        if (dialogState == DialogState.None) {
            clashDialog?.dismiss()
            clashDialog = null
            return
        }
        if (clashDialog != null) { return }
        when (dialogState) {
            DialogState.ReadyToClash -> {
                clashDialog = AlertDialog.Builder(this@ClashActivity, R.style.KikkoAlertDialogTheme)
                    .setTitle(R.string.dialog_arena_ready_title)
                    .setMessage(R.string.dialog_arena_ready_message)
                    .setPositiveButton(R.string.dialog_launch) { _, _ -> viewModel.confirmAndStartP2pClash() }
                    .setNegativeButton(R.string.dialog_cancel) { _, _ -> viewModel.dismissDialog() }
                    .setOnDismissListener { clashDialog = null }
                    .setCancelable(false)
                    .show()
            }
            DialogState.WaitingForHost -> {
                clashDialog = AlertDialog.Builder(this@ClashActivity, R.style.KikkoAlertDialogTheme)
                    .setTitle(R.string.dialog_teams_complete_title)
                    .setMessage(R.string.dialog_waiting_for_host_message)
                    .setCancelable(false)
                    .setOnDismissListener { clashDialog = null }
                    .show()
            }
            else -> {}
        }
    }

    private fun showConnectionRequestDialog(endpointId: String, opponentName: String, authCode: String) {
        connectionRequestDialog?.dismiss()
        connectionRequestDialog = AlertDialog.Builder(this, R.style.KikkoAlertDialogTheme)
            .setTitle(getString(R.string.dialog_connection_title, opponentName))
            .setMessage(getString(R.string.dialog_connection_message, authCode))
            .setPositiveButton(R.string.dialog_accept) { _, _ ->
                viewModel.acceptConnection(endpointId)
            }
            .setNegativeButton(R.string.dialog_decline) { _, _ ->
                viewModel.rejectConnection(endpointId)
            }
            .setOnDismissListener { connectionRequestDialog = null }
            .setCancelable(false)
            .show()
    }

    private fun getDeckIcon(deckName: String): Int {
        return when (deckName) {
            "Food" -> R.drawable.ic_deck_food
            "Plant" -> R.drawable.ic_deck_plant
            "Insect" -> R.drawable.ic_deck_insect
            "Bird" -> R.drawable.ic_deck_bird
            else -> R.drawable.ic_deck_default
        }
    }

    override fun onClashSettingsConfirmed(settings: ClashSettings) {
        viewModel.updateClashSettings(settings)
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy: L'activité de Clash est détruite.")
        clashDialog?.dismiss()
        connectionRequestDialog?.dismiss()
        viewModel.stopP2P()
        stopLocationUpdates()
    }

    companion object {
        fun newIntent(context: Context): Intent {
            return Intent(context, ClashActivity::class.java)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashDuelFragment.kt ---

package be.heyman.android.ai.kikko.clash.ui

import android.animation.AnimatorSet
import android.animation.ObjectAnimator
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.animation.AccelerateDecelerateInterpolator
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.ClashStatus
import be.heyman.android.ai.kikko.clash.viewmodel.ClashMode
import be.heyman.android.ai.kikko.clash.viewmodel.ClashUiState
import be.heyman.android.ai.kikko.clash.viewmodel.ClashViewModel
import be.heyman.android.ai.kikko.model.KnowledgeCard
import com.google.android.material.progressindicator.CircularProgressIndicator
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import java.io.File

private const val ARG_DUEL_INDEX = "duel_index"

class ClashDuelFragment : Fragment() {

    private var duelIndex: Int = 0
    private val viewModel: ClashViewModel by activityViewModels()

    private lateinit var playerView: PlayerView
    private var exoPlayer: ExoPlayer? = null

    private lateinit var questionTextView: TextView
    private lateinit var player1CardView: View
    private lateinit var player2CardView: View
    private lateinit var reasoningTextView: TextView
    private lateinit var streamingReasoningTextView: TextView
    private lateinit var loadingIndicator: CircularProgressIndicator
    private lateinit var previousButton: Button
    private lateinit var nextButton: Button
    private lateinit var finishButton: Button
    private lateinit var navSpacer: View


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            duelIndex = it.getInt(ARG_DUEL_INDEX)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_duel_page, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        bindViews(view)
        observeViewModel()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
    }

    override fun onStop() {
        super.onStop()
        releasePlayer()
    }

    override fun onResume() {
        super.onResume()
        val currentState = viewModel.uiState.value
        val duelState = currentState.clashStates.getOrNull(duelIndex)
        if (duelState != null && currentState.currentDuelIndex == duelIndex && duelState.status == ClashStatus.PENDING) {
            if (currentState.isArbitrator || currentState.clashMode == ClashMode.SOLO) {
                viewModel.runInferenceForCurrentDuel()
            }
        }
    }

    private fun bindViews(view: View) {
        playerView = view.findViewById(R.id.duel_background_video_view)
        questionTextView = view.findViewById(R.id.duel_question_textview)
        player1CardView = view.findViewById(R.id.duel_player1_card)
        player2CardView = view.findViewById(R.id.duel_player2_card)
        reasoningTextView = view.findViewById(R.id.duel_reasoning_textview)
        streamingReasoningTextView = view.findViewById(R.id.duel_streaming_reasoning_textview)
        loadingIndicator = view.findViewById(R.id.duel_loading_indicator)
        previousButton = view.findViewById(R.id.duel_previous_button)
        nextButton = view.findViewById(R.id.duel_next_button)
        finishButton = view.findViewById(R.id.duel_finish_button)
        navSpacer = view.findViewById(R.id.duel_nav_spacer)

        previousButton.setOnClickListener { viewModel.proceedToPreviousDuel() }
        nextButton.setOnClickListener { viewModel.proceedToNextDuel() }
        finishButton.setOnClickListener { viewModel.proceedToNextDuel() }
    }

    private fun initializePlayer() {
        exoPlayer = ExoPlayer.Builder(requireContext()).build().also { player ->
            playerView.player = player
            val videoUri = Uri.parse("android.resource://${requireContext().packageName}/${R.raw.kikko_question}")
            val mediaItem = MediaItem.fromUri(videoUri)
            player.setMediaItem(mediaItem)
            player.repeatMode = Player.REPEAT_MODE_ONE
            player.volume = 0f
            player.playWhenReady = true
            player.prepare()
        }
    }

    private fun releasePlayer() {
        exoPlayer?.release()
        exoPlayer = null
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collectLatest { state ->
                state.clashStates.getOrNull(duelIndex)?.let {
                    updateUi(state)
                }
            }
        }
    }

    private fun updateUi(state: ClashUiState) {
        val duelState = state.clashStates.getOrNull(duelIndex) ?: return
        val totalDuels = state.clashStates.size

        questionTextView.text = duelState.question ?: getString(R.string.clash_duel_question_placeholder)
        bindCard(player1CardView, duelState.player1Card)
        bindCard(player2CardView, duelState.player2Card)

        if (state.clashSettings?.isTtsEnabled == true) {
            viewModel.requestTtsForQuestion(duelIndex, autoPlay = true)
        }

        val isHost = state.isArbitrator || state.clashMode == ClashMode.SOLO
        val isCompleted = duelState.status == ClashStatus.COMPLETED || duelState.status == ClashStatus.ERROR

        previousButton.visibility = if (isHost && isCompleted && duelIndex > 0) View.VISIBLE else View.GONE
        nextButton.visibility = if (isHost && isCompleted && duelIndex < totalDuels - 1) View.VISIBLE else View.GONE
        finishButton.visibility = if (isHost && isCompleted && duelIndex == totalDuels - 1) View.VISIBLE else View.GONE
        navSpacer.visibility = if (previousButton.visibility == View.VISIBLE && (nextButton.visibility == View.VISIBLE || finishButton.visibility == View.VISIBLE)) View.VISIBLE else View.GONE
        loadingIndicator.visibility = if (duelState.status == ClashStatus.INFERRING || duelState.status == ClashStatus.TRANSLATING) View.VISIBLE else View.GONE

        streamingReasoningTextView.visibility = if (duelState.status == ClashStatus.INFERRING) View.VISIBLE else View.GONE
        streamingReasoningTextView.text = duelState.streamingReasoning
        reasoningTextView.visibility = if (isCompleted) View.VISIBLE else View.INVISIBLE

        if (isCompleted) {
            reasoningTextView.text = duelState.translatedReasoning ?: duelState.errorMessage ?: ""
            animateWinner(duelState.winner)
            if (state.clashSettings?.isTtsEnabled == true && !duelState.ttsHasBeenPlayed) {
                viewModel.requestTtsForReasoning(duelIndex, autoPlay = true)
            }
        }
    }

    private fun bindCard(cardView: View, card: KnowledgeCard) {
        val cardTitle = cardView.findViewById<TextView>(R.id.card_title)
        val cardDeckName = cardView.findViewById<TextView>(R.id.card_deck_name)
        val cardImage = cardView.findViewById<ImageView>(R.id.card_image)

        cardTitle.text = card.specificName
        cardDeckName.text = card.deckName

        card.imagePath?.let {
            val imgFile = File(it)
            if (imgFile.exists()) {
                val myBitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                cardImage.setImageBitmap(myBitmap)
            }
        }
    }

    private fun animateWinner(winner: String?) {
        val winnerScale = 1.05f
        val loserScale = 0.95f
        val winnerElevation = 16f
        val loserElevation = 4f
        val duration = 500L

        val (winnerView, loserView) = when (winner) {
            "player1" -> player1CardView to player2CardView
            "player2" -> player2CardView to player1CardView
            else -> null to null
        }

        if (winnerView != null && loserView != null) {
            winnerView.bringToFront()

            // BOURDON'S FIX: Remplacement de "cardElevation" par la propriété universelle "elevation".
            val winnerScaleX = ObjectAnimator.ofFloat(winnerView, "scaleX", winnerScale)
            val winnerScaleY = ObjectAnimator.ofFloat(winnerView, "scaleY", winnerScale)
            val winnerElevationAnim = ObjectAnimator.ofFloat(winnerView, "elevation", winnerElevation)

            val loserScaleX = ObjectAnimator.ofFloat(loserView, "scaleX", loserScale)
            val loserScaleY = ObjectAnimator.ofFloat(loserView, "scaleY", loserScale)
            val loserElevationAnim = ObjectAnimator.ofFloat(loserView, "elevation", loserElevation)

            val animatorSet = AnimatorSet().apply {
                playTogether(winnerScaleX, winnerScaleY, winnerElevationAnim, loserScaleX, loserScaleY, loserElevationAnim)
                this.duration = duration
                interpolator = AccelerateDecelerateInterpolator()
            }
            animatorSet.start()
        }
    }

    companion object {
        @JvmStatic
        fun newInstance(duelIndex: Int) =
            ClashDuelFragment().apply {
                arguments = Bundle().apply {
                    putInt(ARG_DUEL_INDEX, duelIndex)
                }
            }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashDuelFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashPagerAdapter.kt ---

package be.heyman.android.ai.kikko.clash.ui

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter

/**
 * L'adaptateur pour le ViewPager2 de l'arène de Clash.
 * Il est responsable de la création d'un ClashDuelFragment pour chaque duel.
 *
 * @param fa L'activité hôte du fragment.
 * @param duelCount Le nombre total de duels à afficher.
 */
class ClashPagerAdapter(
    fa: FragmentActivity,
    private val duelCount: Int
) : FragmentStateAdapter(fa) {

    /**
     * Retourne le nombre total de pages (duels).
     */
    override fun getItemCount(): Int = duelCount

    /**
     * Crée et retourne un nouveau fragment pour la position donnée.
     * Chaque fragment représente un seul duel.
     */
    override fun createFragment(position: Int): Fragment {
        // Passe la position (index du duel) au fragment pour qu'il sache quelles données afficher.
        return ClashDuelFragment.newInstance(position)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/ClashPagerAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/PlayerAdapter.kt ---

package be.heyman.android.ai.kikko.clash.ui.adapter

import android.content.Context
import android.graphics.PorterDuff
import android.location.Location
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue

class PlayerAdapter(
    private var players: Map<String, PlayerCatalogue>,
    private var currentUserLocation: Location?,
    private val onClick: (endpointId: String) -> Unit
) : RecyclerView.Adapter<PlayerAdapter.PlayerViewHolder>() {

    private val TAG = "PlayerAdapter"

    class PlayerViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val playerIcon: ImageView = view.findViewById(R.id.player_icon)
        val playerNameText: TextView = view.findViewById(R.id.player_name_text)
        val decksColumn1Text: TextView = view.findViewById(R.id.decks_column_1_text)
        val decksColumn2Text: TextView = view.findViewById(R.id.decks_column_2_text)
        val playerDistanceText: TextView = view.findViewById(R.id.player_distance_text)
        val playerRecordText: TextView = view.findViewById(R.id.player_record_text)
    }

    fun updatePlayers(newPlayers: Map<String, PlayerCatalogue>, location: Location?) {
        this.players = newPlayers
        this.currentUserLocation = location
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PlayerViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_player_card, parent, false)
        return PlayerViewHolder(view)
    }

    override fun onBindViewHolder(holder: PlayerViewHolder, position: Int) {
        val (endpointId, catalogue) = players.entries.toList()[position]
        val context = holder.itemView.context

        holder.playerNameText.text = catalogue.playerName

        val column1Decks = StringBuilder()
        val column2Decks = StringBuilder()

        catalogue.decks.forEach { deck ->
            val emoji = GameConstants.DECK_EMOJIS[deck.name] ?: "❓"
            val deckString = "$emoji(${deck.cardCount})\n"
            when (deck.name) {
                GameConstants.MASTER_DECK_LIST[0], GameConstants.MASTER_DECK_LIST[1] -> column1Decks.append(deckString)
                GameConstants.MASTER_DECK_LIST[2], GameConstants.MASTER_DECK_LIST[3] -> column2Decks.append(deckString)
            }
        }

        holder.decksColumn1Text.text = column1Decks.toString().trim()
        holder.decksColumn2Text.text = column2Decks.toString().trim()

        holder.playerRecordText.text = context.getString(R.string.card_record_format, catalogue.wins, catalogue.losses)

        if (currentUserLocation != null && catalogue.latitude != null && catalogue.longitude != null) {
            val playerLocation = Location("player").apply {
                latitude = catalogue.latitude
                longitude = catalogue.longitude
            }

            val distance = currentUserLocation!!.distanceTo(playerLocation)

            if (distance < 1.0f) {
                val distanceInCm = distance * 100
                holder.playerDistanceText.text = context.getString(R.string.card_distance_format_cm, distanceInCm)
            } else {
                holder.playerDistanceText.text = context.getString(R.string.card_distance_format_m, distance)
            }
        } else {
            holder.playerDistanceText.text = "?? m"
        }

        holder.playerIcon.setColorFilter(catalogue.color, PorterDuff.Mode.SRC_IN)
        holder.itemView.setOnClickListener { onClick(endpointId) }
    }

    override fun getItemCount() = players.size
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/PlayerAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/CardSelectionDialogFragment.kt ---

package be.heyman.android.ai.kikko.clash.ui.dialogs

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.EditText
import android.widget.Spinner
import androidx.core.widget.addTextChangedListener
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.viewmodel.ClashViewModel
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.ui.adapters.KnowledgeCardAdapter
import com.google.android.material.appbar.MaterialToolbar
import kotlinx.coroutines.launch

class CardSelectionDialogFragment : DialogFragment() {

    private val viewModel: ClashViewModel by activityViewModels()
    private lateinit var adapter: KnowledgeCardAdapter
    private var isPlayerOne: Boolean = true

    // BOURDON'S FIX: Le dialog va chercher ses propres données pour l'instant.
    private val cardDao: CardDao by lazy {
        (requireActivity().application as KikkoApplication).cardDao
    }

    private lateinit var toolbar: MaterialToolbar
    private lateinit var searchEditText: EditText
    private lateinit var sortSpinner: Spinner
    private lateinit var recyclerView: RecyclerView


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        isPlayerOne = arguments?.getBoolean(ARG_IS_PLAYER_ONE) ?: true
        setStyle(STYLE_NORMAL, R.style.Theme_Kikko_FullScreenDialog)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val view = inflater.inflate(R.layout.dialog_card_selection, container, false)
        toolbar = view.findViewById(R.id.card_selection_toolbar)
        searchEditText = view.findViewById(R.id.card_selection_search_edittext)
        sortSpinner = view.findViewById(R.id.card_selection_sort_spinner)
        recyclerView = view.findViewById(R.id.card_selection_recyclerview)
        return view
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupToolbar()
        setupRecyclerView()
        loadCards() // BOURDON'S FIX: Chargement des cartes
        setupSearchAndSort()
    }

    private fun setupToolbar() {
        toolbar.setNavigationOnClickListener { dismiss() }
        toolbar.title = if (isPlayerOne) "Sélectionnez votre Champion (Joueur 1)" else "Sélectionnez votre Champion (Joueur 2)"
    }

    private fun setupRecyclerView() {
        adapter = KnowledgeCardAdapter { card ->
            viewModel.selectCardForClash(card, isPlayerOne)
            dismiss()
        }
        recyclerView.adapter = adapter
        recyclerView.layoutManager = GridLayoutManager(context, 3)
    }

    // BOURDON'S FIX: Nouvelle méthode pour charger les cartes depuis le DAO
    private fun loadCards() {
        viewLifecycleOwner.lifecycleScope.launch {
            val cards = cardDao.getAll()
            adapter.submitList(cards)
        }
    }

    private fun setupSearchAndSort() {
        searchEditText.addTextChangedListener { text ->
            // viewModel.searchCards(text.toString()) // Logique à implémenter dans le ViewModel
        }

        // BOURDON'S NOTE: Il faudra créer un fichier res/values/arrays.xml pour que R.array.sort_options fonctionne.
        ArrayAdapter.createFromResource(
            requireContext(),
            R.array.sort_options,
            android.R.layout.simple_spinner_item
        ).also { adapter ->
            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            sortSpinner.adapter = adapter
        }

        sortSpinner.onItemSelectedListener = object : android.widget.AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: android.widget.AdapterView<*>?, view: View?, position: Int, id: Long) {
                val sortBy = parent?.getItemAtPosition(position).toString()
                // viewModel.sortCards(sortBy) // Logique à implémenter dans le ViewModel
            }

            override fun onNothingSelected(parent: android.widget.AdapterView<*>?) {
                // Rien à faire
            }
        }
    }

    companion object {
        private const val ARG_IS_PLAYER_ONE = "is_player_one"
        const val TAG = "CardSelectionDialog"

        @JvmStatic
        fun newInstance(isPlayerOne: Boolean) =
            CardSelectionDialogFragment().apply {
                arguments = Bundle().apply {
                    putBoolean(ARG_IS_PLAYER_ONE, isPlayerOne)
                }
            }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/CardSelectionDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/ClashSetupDialogFragment.kt ---

package be.heyman.android.ai.kikko.clash.ui.dialogs

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.CheckBox
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.Spinner
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.data.Model
import com.google.android.material.slider.Slider
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.util.Locale

class ClashSetupDialogFragment : DialogFragment() {

    interface ClashSetupListener {
        fun onClashSettingsConfirmed(settings: ClashSettings)
    }

    private var listener: ClashSetupListener? = null

    private lateinit var modelSpinner: Spinner
    private lateinit var acceleratorRadioGroup: RadioGroup
    private lateinit var temperatureLabel: TextView
    private lateinit var temperatureSlider: Slider
    private lateinit var ttsSwitch: com.google.android.material.switchmaterial.SwitchMaterial
    private lateinit var dontShowAgainCheckbox: CheckBox
    private lateinit var confirmButton: Button

    private var availableModels: List<Model> = emptyList()
    private var currentSettings: ClashSettings? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = parentFragment as? ClashSetupListener ?: context as? ClashSetupListener
        if (listener == null) {
            throw ClassCastException("$context must implement ClashSetupListener")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            val modelsJson = it.getString(ARG_MODELS)
            val settingsJson = it.getString(ARG_SETTINGS)
            val gson = Gson()
            val modelListType = object : TypeToken<List<Model>>() {}.type
            availableModels = gson.fromJson(modelsJson, modelListType)
            currentSettings = gson.fromJson(settingsJson, ClashSettings::class.java)
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_clash_setup, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle("Préparation au Clash")

        bindViews(view)
        setupViews()
        setupListeners()
    }

    private fun bindViews(view: View) {
        modelSpinner = view.findViewById(R.id.clash_setup_model_spinner)
        acceleratorRadioGroup = view.findViewById(R.id.clash_setup_accelerator_radiogroup)
        temperatureLabel = view.findViewById(R.id.clash_setup_temperature_label)
        temperatureSlider = view.findViewById(R.id.clash_setup_temperature_slider)
        ttsSwitch = view.findViewById(R.id.clash_setup_tts_switch)
        dontShowAgainCheckbox = view.findViewById(R.id.clash_setup_dont_show_again_checkbox)
        confirmButton = view.findViewById(R.id.clash_setup_confirm_button)
    }

    private fun setupViews() {
        // Model Spinner
        val modelNames = availableModels.map { it.name }
        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, modelNames)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        modelSpinner.adapter = adapter

        // Set initial values from currentSettings
        currentSettings?.let {
            val modelIndex = availableModels.indexOfFirst { model -> model.name == it.queenModelName }
            if (modelIndex != -1) modelSpinner.setSelection(modelIndex)

            if (it.brain == "CPU") {
                acceleratorRadioGroup.check(R.id.clash_setup_cpu_radio)
            } else {
                acceleratorRadioGroup.check(R.id.clash_setup_gpu_radio)
            }

            temperatureSlider.value = it.temperature
            temperatureLabel.text = "Tempérament du Juge (${String.format(Locale.US, "%.2f", it.temperature)})"

            ttsSwitch.isChecked = it.isTtsEnabled
            dontShowAgainCheckbox.isChecked = !it.showSetupOnLaunch
        }
    }

    private fun setupListeners() {
        temperatureSlider.addOnChangeListener { _, value, _ ->
            temperatureLabel.text = "Tempérament du Juge (${String.format(Locale.US, "%.2f", value)})"
        }

        confirmButton.setOnClickListener {
            val selectedModel = availableModels[modelSpinner.selectedItemPosition]
            val selectedAcceleratorId = acceleratorRadioGroup.checkedRadioButtonId
            val selectedAccelerator = if (selectedAcceleratorId == R.id.clash_setup_cpu_radio) "CPU" else "GPU"
            val selectedTemperature = temperatureSlider.value
            val isTtsEnabled = ttsSwitch.isChecked
            val shouldShowAgain = !dontShowAgainCheckbox.isChecked

            val newSettings = ClashSettings(
                queenModelName = selectedModel.name,
                brain = selectedAccelerator,
                temperature = selectedTemperature,
                isTtsEnabled = isTtsEnabled,
                showSetupOnLaunch = shouldShowAgain
            )

            listener?.onClashSettingsConfirmed(newSettings)
            dismiss()
        }
    }

    companion object {
        const val TAG = "ClashSetupDialog"
        private const val ARG_MODELS = "available_models"
        private const val ARG_SETTINGS = "current_settings"

        fun newInstance(availableModels: List<Model>, currentSettings: ClashSettings?): ClashSetupDialogFragment {
            val fragment = ClashSetupDialogFragment()
            val args = Bundle()
            val gson = Gson()
            args.putString(ARG_MODELS, gson.toJson(availableModels))
            args.putString(ARG_SETTINGS, gson.toJson(currentSettings))
            fragment.arguments = args
            return fragment
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/dialogs/ClashSetupDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/views/RadarView.kt ---

package be.heyman.android.ai.kikko.clash.ui.views

import android.content.Context
import android.graphics.*
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.location.Location
import android.util.AttributeSet
import android.util.Log
import android.util.TypedValue
import android.view.View
import androidx.annotation.AttrRes
import androidx.appcompat.content.res.AppCompatResources
import androidx.core.graphics.drawable.toBitmap
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import kotlin.math.cos
import kotlin.math.min
import kotlin.math.sin

class RadarView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr), SensorEventListener {

    private val TAG = "RadarView"
    private val TURTLE_ICON_SIZE_DP = 36f
    private val CARDINAL_POINTS_RADIUS_OFFSET_DP = 25f
    private val DISTANCE_LABEL_VERTICAL_OFFSET_DP = 7f
    private val PLAYER_NAME_VERTICAL_OFFSET_DP = 12f

    private val turtleIconSizePx: Int
    private val cardinalPointsRadiusOffsetPx: Float
    private val distanceLabelVerticalOffsetPx: Float
    private val playerNameVerticalOffsetPx: Float

    private val playerTextPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val cardinalPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val labelPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val turtleBitmap: Bitmap

    private val sensorManager: SensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    private val accelerometerReading = FloatArray(3)
    private val magnetometerReading = FloatArray(3)
    private var smoothedAccelerometerReading = FloatArray(3)
    private var smoothedMagnetometerReading = FloatArray(3)
    private val rotationMatrix = FloatArray(9)
    private val orientationAngles = FloatArray(3)
    private var azimuth: Float = 0f
    private var players: Map<String, PlayerCatalogue> = emptyMap()
    private var userLocation: Location? = null
    private val maxDistanceMeters = 20f
    private val cardinalPoints = mapOf("N" to 0f, "E" to 90f, "S" to 180f, "O" to 270f)
    private val alpha: Float = 0.1f

    init {
        val density = context.resources.displayMetrics.density
        turtleIconSizePx = (TURTLE_ICON_SIZE_DP * density).toInt()
        cardinalPointsRadiusOffsetPx = CARDINAL_POINTS_RADIUS_OFFSET_DP * density
        distanceLabelVerticalOffsetPx = DISTANCE_LABEL_VERTICAL_OFFSET_DP * density
        playerNameVerticalOffsetPx = PLAYER_NAME_VERTICAL_OFFSET_DP * density

        val primaryColor = resolveThemeColor(com.google.android.material.R.attr.colorPrimary)
        val onSurfaceColor = resolveThemeColor(com.google.android.material.R.attr.colorOnSurface)

        playerTextPaint.color = onSurfaceColor
        playerTextPaint.textSize = 28f
        playerTextPaint.textAlign = Paint.Align.CENTER

        cardinalPaint.color = primaryColor
        cardinalPaint.textSize = 52f
        cardinalPaint.textAlign = Paint.Align.CENTER
        cardinalPaint.isFakeBoldText = true

        labelPaint.color = onSurfaceColor
        labelPaint.textSize = 30f
        labelPaint.textAlign = Paint.Align.CENTER
        labelPaint.isFakeBoldText = true

        val turtleDrawable = AppCompatResources.getDrawable(context, R.drawable.ic_turtle)
        turtleBitmap = turtleDrawable?.toBitmap(turtleIconSizePx, turtleIconSizePx, Bitmap.Config.ARGB_8888)!!
    }

    private fun resolveThemeColor(@AttrRes attr: Int): Int {
        val typedValue = TypedValue()
        context.theme.resolveAttribute(attr, typedValue, true)
        return typedValue.data
    }

    fun updatePlayers(newPlayers: Map<String, PlayerCatalogue>, currentUserLocation: Location?) {
        this.players = newPlayers
        this.userLocation = currentUserLocation
        invalidate() // Redessine la vue
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        val centerX = width / 2f
        val centerY = height / 2f
        val radius = min(centerX, centerY) * 0.55f

        // Dessin des labels de distance
        val distances = listOf(5f, 10f, 15f, 20f)
        distances.forEach { distance ->
            val circleRadius = (distance / maxDistanceMeters) * radius
            canvas.drawText(
                "${distance.toInt()}m",
                centerX,
                centerY - circleRadius + labelPaint.textSize + distanceLabelVerticalOffsetPx,
                labelPaint
            )
        }

        // Dessin des points cardinaux
        val textRadius = radius + cardinalPointsRadiusOffsetPx
        cardinalPoints.forEach { (point, angle) ->
            val angleOnRadar = (angle - Math.toDegrees(azimuth.toDouble())).toFloat()
            val angleInRad = Math.toRadians(angleOnRadar.toDouble())
            val x = centerX + (textRadius * sin(angleInRad)).toFloat()
            val y = centerY - (textRadius * cos(angleInRad)).toFloat() + (cardinalPaint.textSize / 2)
            canvas.drawText(point, x, y, cardinalPaint)
        }

        // Dessin des joueurs
        val currentUserLoc = userLocation ?: return

        for (player in players.values) {
            val lat = player.latitude
            val lon = player.longitude
            if (lat != null && lon != null) {
                val playerLocation = Location("player").apply { latitude = lat; longitude = lon }
                val distance = currentUserLoc.distanceTo(playerLocation)

                if (distance <= maxDistanceMeters) {
                    val bearing = currentUserLoc.bearingTo(playerLocation)
                    val angleOnRadar = (bearing - Math.toDegrees(azimuth.toDouble())).toFloat()
                    val angleInRad = Math.toRadians(angleOnRadar.toDouble())
                    val distanceOnRadar = (distance / maxDistanceMeters) * radius
                    val playerX = centerX + (distanceOnRadar * sin(angleInRad)).toFloat()
                    val playerY = centerY - (distanceOnRadar * cos(angleInRad)).toFloat()

                    val paint = Paint()
                    paint.colorFilter = PorterDuffColorFilter(player.color, PorterDuff.Mode.SRC_IN)
                    canvas.drawBitmap(turtleBitmap, playerX - turtleBitmap.width / 2, playerY - turtleBitmap.height / 2, paint)
                    canvas.drawText(player.playerName, playerX, playerY + turtleBitmap.height / 2 + playerNameVerticalOffsetPx, playerTextPaint)
                }
            }
        }
    }

    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
        sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        sensorManager.unregisterListener(this)
    }

    override fun onSensorChanged(event: SensorEvent) {
        if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {
            smoothedAccelerometerReading = lowPass(event.values, smoothedAccelerometerReading)
        } else if (event.sensor.type == Sensor.TYPE_MAGNETIC_FIELD) {
            smoothedMagnetometerReading = lowPass(event.values, smoothedMagnetometerReading)
        }
        updateOrientationAngles()
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}

    private fun lowPass(input: FloatArray, output: FloatArray): FloatArray {
        for (i in input.indices) {
            output[i] = output[i] + alpha * (input[i] - output[i])
        }
        return output
    }

    private fun updateOrientationAngles() {
        SensorManager.getRotationMatrix(rotationMatrix, null, smoothedAccelerometerReading, smoothedMagnetometerReading)
        SensorManager.getOrientation(rotationMatrix, orientationAngles)
        azimuth = orientationAngles[0]
        invalidate()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/ui/views/RadarView.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashUiState.kt ---

// app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashUiState.kt

package be.heyman.android.ai.kikko.clash.viewmodel

import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.clash.data.ClashState
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import be.heyman.android.ai.kikko.clash.helpers.LocalizedQuestion
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.KnowledgeCard

enum class ClashFlowState { SETUP, DUELING, FINISHED }
enum class ClashMode { SOLO, P2P_DISCOVERING, P2P_AWAITING_SETUP, P2P_CARD_SELECTION, P2P_DUELING }

sealed class DialogState {
    data object None : DialogState()
    data object ReadyToClash : DialogState()
    data object WaitingForHost : DialogState()
}

data class ClashUiState(
    // --- FLUX GLOBAL ---
    val flowState: ClashFlowState = ClashFlowState.SETUP,
    val clashMode: ClashMode = ClashMode.SOLO,
    val errorMessage: String? = null,
    val dialogState: DialogState = DialogState.None,

    // --- CONFIGURATION ---
    val availableModels: List<Model> = emptyList(),
    // BOURDON'S DEFINITIVE FIX: Ajout du champ manquant pour le modèle sélectionné
    val selectedModel: Model? = null,
    val clashSettings: ClashSettings? = null,
    val isJudgeInitializing: Boolean = false,
    val myChampions: Map<String, KnowledgeCard> = emptyMap(),
    val opponentChampions: Map<String, KnowledgeCard> = emptyMap(),
    val isReadyToClash: Boolean = false,

    // BOURDON'S FIX V5: Ajout d'un set pour suivre la réception des images des champions.
    val opponentChampionImagesReady: Set<String> = emptySet(), // Contient les deckNames des champions dont l'image est prête.

    // --- P2P ---
    val p2pStatus: String = "Arène P2P inactive.",
    val isArbitrator: Boolean = false,
    val discoveredPlayers: Map<String, PlayerCatalogue> = emptyMap(),
    val connectedEndpointId: String? = null,
    val duelQuestions: Map<String, LocalizedQuestion> = emptyMap(),

    // --- DUEL ---
    val clashStates: List<ClashState> = emptyList(),
    val currentDuelIndex: Int = -1
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashUiState.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashViewModel.kt ---

// app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashViewModel.kt

package be.heyman.android.ai.kikko.clash.viewmodel

import android.app.Application
import android.content.Context
import android.location.Location
import android.os.ParcelFileDescriptor
import android.util.Log
import android.widget.Toast
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.clash.data.ClashSettings
import be.heyman.android.ai.kikko.clash.data.ClashState
import be.heyman.android.ai.kikko.clash.data.ClashStatus
import be.heyman.android.ai.kikko.clash.data.Deck
import be.heyman.android.ai.kikko.clash.data.P2pPayload
import be.heyman.android.ai.kikko.clash.data.PlayerCatalogue
import be.heyman.android.ai.kikko.forge.ForgeLlmHelper
import be.heyman.android.ai.kikko.clash.helpers.ClashPromptGenerator
import be.heyman.android.ai.kikko.TtsService
import be.heyman.android.ai.kikko.clash.services.ClashArenaService
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.persistence.CardDao
import com.google.android.gms.nearby.connection.Payload
import com.google.android.gms.nearby.connection.PayloadTransferUpdate
import com.google.gson.Gson
import com.google.gson.JsonParser
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.util.Locale

class ClashViewModel(application: Application) : AndroidViewModel(application), ClashArenaService.ClashArenaListener {

    private val cardDao: CardDao = (application as KikkoApplication).cardDao
    private val llmHelper: ForgeLlmHelper = (application as KikkoApplication).forgeLlmHelper
    private val arenaService: ClashArenaService = (application as KikkoApplication).clashArenaService

    private val TAG = "ClashViewModel"
    private val gson = Gson()

    private val _uiState = MutableStateFlow(ClashUiState())
    val uiState = _uiState.asStateFlow()

    private val _p2pEvent = MutableSharedFlow<P2pEvent>()
    val p2pEvent = _p2pEvent.asSharedFlow()
    sealed class P2pEvent {
        data class ShowConnectionDialog(val endpointId: String, val opponentName: String, val authCode: String) : P2pEvent()
    }

    private var inferenceJob: Job? = null
    private var judgeInitializationJob: Job? = null
    private val pendingImageTransfers = mutableMapOf<Long, KnowledgeCard>()
    private var allCardsCache: List<KnowledgeCard> = emptyList()

    init {
        arenaService.setListener(this)
        TtsService.initialize(getApplication())
        ClashPromptGenerator.loadClashQuestions(getApplication())
        loadInitialData()
    }

    private fun loadInitialData() {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                allCardsCache = cardDao.getAll()
            }
            loadAvailableModelsAndInitializeJudge()
        }
    }

    suspend fun getCardsForDeck(deckName: String): List<KnowledgeCard> {
        return withContext(Dispatchers.Default) {
            allCardsCache.filter { it.deckName == deckName }
        }
    }

    fun selectCardForClash(card: KnowledgeCard, isPlayerOne: Boolean) {
        val deckName = card.deckName
        handleChampionSelection(deckName, card, if (isPlayerOne) 1 else 2)
    }

    fun handleChampionSelection(deckName: String, card: KnowledgeCard, playerIndex: Int = 1) {
        if (_uiState.value.clashMode != ClashMode.SOLO && playerIndex == 1) {
            sendCardSelectionToOpponent(deckName, card)
        }

        _uiState.update { currentState ->
            val updatedChampions = if (playerIndex == 1) {
                currentState.myChampions.toMutableMap()
            } else {
                currentState.opponentChampions.toMutableMap()
            }
            updatedChampions[deckName] = card

            if (playerIndex == 1) {
                currentState.copy(myChampions = updatedChampions)
            } else {
                currentState.copy(opponentChampions = updatedChampions)
            }
        }
        checkReadyState()
    }

    private fun sendCardSelectionToOpponent(deckName: String, card: KnowledgeCard) {
        _uiState.value.connectedEndpointId?.let { endpointId ->
            var imagePayloadId: Long? = null
            card.imagePath?.let { path ->
                val imageFile = File(path)
                if (imageFile.exists()) {
                    val filePayload = Payload.fromFile(imageFile)
                    imagePayloadId = filePayload.id
                    Log.i(TAG, "[P2P SEND] Envoi du payload image pour '${card.specificName}' (Payload ID: ${filePayload.id}) vers $endpointId")
                    arenaService.sendPayload(endpointId, filePayload)
                }
            }
            val lightweightCard = card.copy(imagePath = null)
            val metadataPayload = P2pPayload.CardSelectionPayload(deckName, lightweightCard, imagePayloadId)
            val payloadJson = gson.toJson(metadataPayload)
            Log.i(TAG, "[P2P SEND] Envoi du payload de métadonnées pour '${card.specificName}' (associé à l'image ID: $imagePayloadId) vers $endpointId")
            arenaService.sendPayload(endpointId, payloadJson)
        }
    }

    fun startP2PDiscovery(myLocation: Location?) {
        viewModelScope.launch {
            _uiState.update { it.copy(clashMode = ClashMode.P2P_DISCOVERING, discoveredPlayers = emptyMap()) }
            val myCatalogue = withContext(Dispatchers.IO) {
                val decks = allCardsCache.groupBy { it.deckName }.map { (deckName, cards) -> Deck(deckName, cards.size) }
                val defaultPlayerName = getApplication<Application>().getString(R.string.p2p_default_player_name, (100..999).random())
                PlayerCatalogue(defaultPlayerName, decks, myLocation?.latitude, myLocation?.longitude, 15, 4)
            }
            arenaService.startAdvertising(myCatalogue)
            arenaService.startDiscovery()
        }
    }

    fun stopP2P() {
        arenaService.stopAllEndpoints()
        _uiState.update { it.copy(
            clashMode = ClashMode.SOLO, isArbitrator = false, discoveredPlayers = emptyMap(),
            connectedEndpointId = null, p2pStatus = getApplication<Application>().getString(R.string.p2p_status_inactive)
        )}
    }

    fun connectToPlayer(endpointId: String) {
        _uiState.update { it.copy(isArbitrator = true) }
        arenaService.requestConnection(endpointId)
    }

    fun acceptConnection(endpointId: String) {
        if (!_uiState.value.isArbitrator) {
            _uiState.update { it.copy(isArbitrator = false) }
        }
        arenaService.acceptConnection(endpointId)
    }

    fun rejectConnection(endpointId: String) {
        arenaService.rejectConnection(endpointId)
    }

    override fun onStatusUpdate(message: String) {
        _uiState.update { it.copy(p2pStatus = message) }
    }

    override fun onEndpointFound(endpointId: String, catalogue: PlayerCatalogue) {
        _uiState.update {
            val updatedPlayers = it.discoveredPlayers.toMutableMap().apply { put(endpointId, catalogue) }
            it.copy(discoveredPlayers = updatedPlayers)
        }
    }

    override fun onEndpointLost(endpointId: String) {
        _uiState.update {
            val updatedPlayers = it.discoveredPlayers.toMutableMap().apply { remove(endpointId) }
            it.copy(discoveredPlayers = updatedPlayers)
        }
    }

    override fun onConnectionInitiated(endpointId: String, opponentName: String, authDigits: String) {
        viewModelScope.launch { _p2pEvent.emit(P2pEvent.ShowConnectionDialog(endpointId, opponentName, authDigits)) }
    }

    override fun onConnectionResult(endpointId: String, isSuccess: Boolean) {
        if (isSuccess) {
            _uiState.update { it.copy(
                discoveredPlayers = emptyMap(),
                clashMode = ClashMode.P2P_CARD_SELECTION,
                connectedEndpointId = endpointId,
                p2pStatus = getApplication<Application>().getString(R.string.p2p_status_connected)
            )}
        } else {
            _uiState.update { it.copy(
                p2pStatus = getApplication<Application>().getString(R.string.p2p_status_connection_failed),
                clashMode = ClashMode.P2P_DISCOVERING,
                isArbitrator = false)
            }
        }
    }

    override fun onDisconnected(endpointId: String) {
        _uiState.update { it.copy(
            connectedEndpointId = null,
            p2pStatus = getApplication<Application>().getString(R.string.p2p_status_disconnected),
            clashMode = ClashMode.SOLO)
        }
    }

    override fun onPayloadReceived(endpointId: String, payloadString: String) {
        try {
            val jsonObject = JsonParser.parseString(payloadString).asJsonObject
            when {
                jsonObject.has("selectedCard") -> handleCardSelectionPayload(payloadString)
                jsonObject.has("question") -> handleQuestionPayload(payloadString)
                jsonObject.has("winner") -> handleDuelResultPayload(payloadString)
                jsonObject.has("command") -> {
                    val command = jsonObject.get("command").asString
                    Log.i(TAG, "[P2P RECV] Commande '$command' reçue de $endpointId.")
                    when (command) {
                        "START_CLASH" -> startDuels()
                        "NEXT_DUEL" -> proceedToNextDuel()
                        "PREVIOUS_DUEL" -> proceedToPreviousDuel()
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erreur de désérialisation du payload", e)
        }
    }

    override fun onFilePayloadReceived(endpointId: String, payload: Payload) {
        Log.i(TAG, "[P2P RECV] Fichier complet reçu (Payload ID: ${payload.id}). Traitement de l'image...")
        val cardToUpdate = pendingImageTransfers.remove(payload.id)
        if (cardToUpdate != null) {
            processAndSaveImage(payload, cardToUpdate)
        } else {
            Log.w(TAG, "[P2P RECV] Fichier reçu (Payload ID: ${payload.id}) mais aucune carte en attente trouvée.")
        }
    }

    override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
        if (update.status == PayloadTransferUpdate.Status.FAILURE || update.status == PayloadTransferUpdate.Status.CANCELED) {
            Log.e(TAG, "[P2P RECV] Echec du transfert pour le payload ID ${update.payloadId}. Annulation de l'attente.")
            pendingImageTransfers.remove(update.payloadId)
            checkReadyState()
        }
    }

    private fun handleCardSelectionPayload(payloadString: String) {
        val payload = gson.fromJson(payloadString, P2pPayload.CardSelectionPayload::class.java)
        if (payload.imagePayloadId != null) {
            Log.i(TAG, "[P2P RECV] Métadonnées reçues pour '${payload.selectedCard.specificName}'. En attente de l'image (Payload ID: ${payload.imagePayloadId}).")
            pendingImageTransfers[payload.imagePayloadId] = payload.selectedCard
        } else {
            Log.i(TAG, "[P2P RECV] Métadonnées reçues pour '${payload.selectedCard.specificName}'. Aucune image associée.")
        }
        _uiState.update { it.copy(opponentChampions = it.opponentChampions.toMutableMap().apply { set(payload.deckName, payload.selectedCard) }) }
        checkReadyState()
    }

    private fun processAndSaveImage(filePayload: Payload, card: KnowledgeCard) {
        viewModelScope.launch(Dispatchers.IO) {
            val pfd: ParcelFileDescriptor? = filePayload.asFile()?.asParcelFileDescriptor()
            if (pfd != null) {
                val inputStream = FileInputStream(pfd.fileDescriptor)
                val destDir = File(getApplication<Application>().filesDir, "clash_images")
                if (!destDir.exists()) destDir.mkdirs()
                val newFile = File(destDir, "clash_${card.id}_${System.currentTimeMillis()}.png")
                try {
                    FileOutputStream(newFile).use { it.write(inputStream.readBytes()) }
                    Log.i(TAG, "[P2P RECV] Image pour '${card.specificName}' sauvegardée vers : ${newFile.absolutePath}")
                } finally {
                    inputStream.close()
                    pfd.close()
                }
                val updatedCard = card.copy(imagePath = newFile.absolutePath)
                withContext(Dispatchers.Main) {
                    _uiState.update { state ->
                        val key = state.opponentChampions.entries.find { it.value.id == card.id }?.key
                        state.copy(opponentChampions = state.opponentChampions.toMutableMap().apply { if(key!=null) set(key, updatedCard) })
                    }
                    checkReadyState()
                }
            }
        }
    }

    private fun checkReadyState() {
        _uiState.update { currentState ->
            val isReady = currentState.myChampions.size == GameConstants.MASTER_DECK_LIST.size &&
                    currentState.opponentChampions.size == GameConstants.MASTER_DECK_LIST.size

            var newDialogState = currentState.dialogState
            if (currentState.clashMode != ClashMode.SOLO) {
                val allImagesReady = pendingImageTransfers.isEmpty()
                if (isReady && allImagesReady) {
                    Log.i(TAG, "[P2P STATUS] Toutes les cartes et images sont prêtes. Mode: ${if (currentState.isArbitrator) "Hôte" else "Invité"}")
                }
                if(isReady && allImagesReady && currentState.dialogState == DialogState.None) {
                    newDialogState = if (currentState.isArbitrator) DialogState.ReadyToClash else DialogState.WaitingForHost
                } else if (!isReady || !allImagesReady) {
                    newDialogState = DialogState.None
                }
            }
            currentState.copy(isReadyToClash = isReady, dialogState = newDialogState)
        }
    }

    fun dismissDialog() {
        _uiState.update { it.copy(dialogState = DialogState.None) }
    }

    fun confirmAndStartP2pClash() {
        _uiState.value.connectedEndpointId?.let {
            if (_uiState.value.isArbitrator) {
                arenaService.sendPayload(it, gson.toJson(P2pPayload.StartClashPayload()))
            }
        }
        startDuels()
    }

    fun confirmSetupAndStartSoloClash() {
        if (!_uiState.value.isReadyToClash) return
        if (_uiState.value.isJudgeInitializing) {
            _uiState.update { it.copy(errorMessage = getApplication<Application>().getString(R.string.judge_awakening_please_wait)) }
            return
        }
        _uiState.update { it.copy(clashMode = ClashMode.SOLO) }
        startDuels()
    }

    private fun startDuels() {
        viewModelScope.launch {
            judgeInitializationJob?.join()
            if (_uiState.value.errorMessage != null) {
                return@launch
            }

            _uiState.update { currentState ->
                val duelStates = GameConstants.MASTER_DECK_LIST.mapNotNull { deck ->
                    val p1 = currentState.myChampions[deck]
                    val p2 = currentState.opponentChampions[deck]
                    if (p1 != null && p2 != null) ClashState(deck, p1, p2) else null
                }
                currentState.copy(flowState = ClashFlowState.DUELING, clashStates = duelStates, currentDuelIndex = 0, dialogState = DialogState.None)
            }
        }
    }

    fun runInferenceForCurrentDuel() {
        if (!_uiState.value.isArbitrator && _uiState.value.clashMode != ClashMode.SOLO) return
        inferenceJob?.cancel()
        val clashIndex = _uiState.value.currentDuelIndex.takeIf { it != -1 } ?: return
        val clashState = _uiState.value.clashStates.getOrNull(clashIndex)?.takeIf { it.status == ClashStatus.PENDING } ?: return

        inferenceJob = viewModelScope.launch(Dispatchers.IO) {
            val settings = _uiState.value.clashSettings ?: return@launch
            val questionSet = ClashPromptGenerator.getRandomClashQuestionSet(clashState.deckName)!!

            withContext(Dispatchers.Main) {
                updateClashState(clashIndex) { it.copy(status = ClashStatus.INFERRING, question = ClashPromptGenerator.getLocalizedQuestion(questionSet)) }
                _uiState.value.connectedEndpointId?.let {
                    arenaService.sendPayload(it, gson.toJson(P2pPayload.QuestionPayload(clashState.deckName, questionSet)))
                }
            }

            try {
                llmHelper.resetSession(
                    model = _uiState.value.selectedModel!!,
                    isMultimodal = false,
                    temperature = settings.temperature,
                    topK = 40
                )
                val prompt = ClashPromptGenerator.generateClashVerdictPrompt(ClashPromptGenerator.getLocalizedQuestion(questionSet), clashState.player1Card, clashState.player2Card)
                Log.d(TAG, "[PROMPT ENVOYÉ AU JUGE]:\n$prompt")
                val responseBuilder = StringBuilder()

                llmHelper.runInference(prompt, emptyList()) { partial, done ->
                    responseBuilder.append(partial)

                    viewModelScope.launch(Dispatchers.Main) {
                        updateClashState(clashIndex) { it.copy(streamingReasoning = responseBuilder.toString()) }
                    }

                    if (done) {
                        val rawResponse = responseBuilder.toString()
                        Log.d(TAG, "[RÉPONSE BRUTE DU JUGE]:\n$rawResponse")
                        val (winner, reasoning, ttsScript) = parseVerdict(rawResponse)

                        viewModelScope.launch(Dispatchers.Main) {
                            updateClashState(clashIndex) { it.copy(winner = winner, rawReasoning = reasoning, translatedReasoning = reasoning, ttsScript = ttsScript, status = ClashStatus.COMPLETED, streamingReasoning = null) }
                            _uiState.value.connectedEndpointId?.let {
                                val resultPayload = P2pPayload.DuelResultPayload(clashState.deckName, winner, reasoning, ttsScript)
                                arenaService.sendPayload(it, gson.toJson(resultPayload))
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    val errorMessage = e.message ?: getApplication<Application>().getString(R.string.inference_error_generic)
                    updateClashState(clashIndex) { it.copy(status = ClashStatus.ERROR, errorMessage = errorMessage) }
                }
            }
        }
    }

    private fun handleQuestionPayload(payloadString: String) {
        val payload = gson.fromJson(payloadString, P2pPayload.QuestionPayload::class.java)
        val duelIndex = _uiState.value.clashStates.indexOfFirst { it.deckName == payload.deckName }
        if (duelIndex != -1) updateClashState(duelIndex) { it.copy(question = ClashPromptGenerator.getLocalizedQuestion(payload.question), status = ClashStatus.INFERRING) }
    }

    private fun handleDuelResultPayload(payloadString: String) {
        val payload = gson.fromJson(payloadString, P2pPayload.DuelResultPayload::class.java)
        val duelIndex = _uiState.value.clashStates.indexOfFirst { it.deckName == payload.deckName }
        if (duelIndex != -1) {
            val winner = when(payload.winner) { "player1" -> "player2"; "player2" -> "player1"; else -> "tie" }
            updateClashState(duelIndex) { it.copy(winner = winner, rawReasoning = payload.reasoning, translatedReasoning = payload.reasoning, ttsScript = payload.ttsScript, status = ClashStatus.COMPLETED) }
        }
    }

    private suspend fun loadAvailableModelsAndInitializeJudge() {
        withContext(Dispatchers.IO) {
            val modelsDir = File(getApplication<Application>().filesDir, "imported_models")
            val modelFiles = modelsDir.listFiles { _, name -> name.endsWith(".task") } ?: emptyArray()
            val llmModels = modelFiles.map { Model(name = it.name, downloadFileName = it.name, url = it.absolutePath, sizeInBytes = it.length(), imported = true, llmSupportImage = it.name.contains("gemma-3n", ignoreCase = true)) }.sortedBy { it.name }

            withContext(Dispatchers.Main) {
                val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                val savedModelName = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null)
                val savedAccelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!

                val currentSettings = _uiState.value.clashSettings ?: ClashSettings(
                    queenModelName = savedModelName ?: llmModels.firstOrNull()?.name ?: "",
                    brain = savedAccelerator
                )
                _uiState.update { it.copy(
                    availableModels = llmModels,
                    clashSettings = currentSettings,
                    selectedModel = llmModels.find { m -> m.name == currentSettings.queenModelName }
                )}

                initializeJudge()
            }
        }
    }

    fun updateClashSettings(settings: ClashSettings) {
        val oldSettings = _uiState.value.clashSettings
        if (settings != oldSettings) {
            _uiState.update { it.copy(
                clashSettings = settings,
                selectedModel = it.availableModels.find { m -> m.name == settings.queenModelName }
            ) }
            judgeInitializationJob?.cancel()
            judgeInitializationJob = null
            viewModelScope.launch {
                withContext(Dispatchers.IO) { llmHelper.cleanUp() }
                initializeJudge()
            }
        }
    }

    private fun initializeJudge() {
        if (judgeInitializationJob != null) return

        val settings = _uiState.value.clashSettings ?: return
        val model = _uiState.value.selectedModel ?: run {
            _uiState.update { it.copy(errorMessage = getApplication<Application>().getString(R.string.error_no_model_selected)) }
            return
        }

        _uiState.update { it.copy(isJudgeInitializing = true) }
        judgeInitializationJob = viewModelScope.launch {
            Log.i(TAG, "Lancement de l'initialisation du Juge IA pour le Clash...")
            val error = withContext(Dispatchers.IO) {
                llmHelper.initialize(model, settings.brain, isMultimodal = false)
            }
            if (error == null) {
                Log.i(TAG, "Initialisation du Juge IA terminée avec succès pour le Clash.")
                withContext(Dispatchers.Main) {
                    Toast.makeText(getApplication(), getApplication<Application>().getString(R.string.judge_ready_toast, model.name), Toast.LENGTH_SHORT).show()
                }
                _uiState.update { it.copy(isJudgeInitializing = false) }
            } else {
                Log.e(TAG, "Échec de l'initialisation du Juge IA: $error")
                _uiState.update { it.copy(isJudgeInitializing = false, errorMessage = getApplication<Application>().getString(R.string.judge_error_toast, error)) }
            }
        }
    }

    fun generateRandomTeams() {
        viewModelScope.launch(Dispatchers.IO) {
            val p1Champions = mutableMapOf<String, KnowledgeCard>()
            val p2Champions = mutableMapOf<String, KnowledgeCard>()
            var errorDeck = ""
            for (deckName in GameConstants.MASTER_DECK_LIST) {
                val cardsInDeck = allCardsCache.filter { it.deckName == deckName }
                if (cardsInDeck.size < 2) { errorDeck = deckName; break }
                val shuffled = cardsInDeck.shuffled()
                p1Champions[deckName] = shuffled[0]
                p2Champions[deckName] = shuffled[1]
            }
            withContext(Dispatchers.Main) {
                if (errorDeck.isNotEmpty()) {
                    _uiState.update { it.copy(errorMessage = getApplication<Application>().getString(R.string.error_not_enough_cards_in_deck, errorDeck)) }
                } else {
                    _uiState.update { it.copy(myChampions = p1Champions, opponentChampions = p2Champions) }
                    checkReadyState()
                }
            }
        }
    }

    fun onDuelSelected(index: Int) {
        if (index != _uiState.value.currentDuelIndex) _uiState.update { it.copy(currentDuelIndex = index) }
    }

    fun proceedToPreviousDuel() {
        if (_uiState.value.isArbitrator || _uiState.value.clashMode == ClashMode.SOLO) {
            _uiState.value.connectedEndpointId?.let { endpointId ->
                val payloadJson = gson.toJson(mapOf("command" to "PREVIOUS_DUEL"))
                Log.i(TAG, "[P2P SEND] Envoi de la commande PREVIOUS_DUEL vers $endpointId")
                arenaService.sendPayload(endpointId, payloadJson)
            }
        }

        val previousIndex = _uiState.value.currentDuelIndex - 1
        if (previousIndex >= 0) {
            _uiState.update { it.copy(currentDuelIndex = previousIndex) }
        }
    }

    fun proceedToNextDuel() {
        if(_uiState.value.isArbitrator || _uiState.value.clashMode == ClashMode.SOLO) {
            _uiState.value.connectedEndpointId?.let { endpointId ->
                val payloadJson = gson.toJson(P2pPayload.NextDuelPayload())
                Log.i(TAG, "[P2P SEND] Envoi de la commande NEXT_DUEL vers $endpointId")
                arenaService.sendPayload(endpointId, payloadJson)
            }
        }
        val nextIndex = _uiState.value.currentDuelIndex + 1
        if (nextIndex < _uiState.value.clashStates.size) {
            _uiState.update { it.copy(currentDuelIndex = nextIndex) }
        } else {
            _uiState.update { it.copy(flowState = ClashFlowState.FINISHED) }
        }
    }

    private fun parseVerdict(rawResponse: String): Triple<String, String, String> {
        return try {
            val cleanJson = rawResponse.substringAfter("{").substringBeforeLast("}")
            val jsonObject = JsonParser.parseString("{$cleanJson}").asJsonObject
            val winner = jsonObject.get("winner")?.asString ?: "tie"
            val reasoning = jsonObject.get("reasoning")?.asString ?: getApplication<Application>().getString(R.string.verdict_parse_reasoning_fallback)
            val ttsScript = jsonObject.get("tts_script")?.asString ?: getApplication<Application>().getString(R.string.verdict_parse_tts_fallback_script)
            Triple(winner, reasoning, ttsScript)
        } catch (e: Exception) {
            Log.e(TAG, "Erreur de parsing du verdict: '$rawResponse'", e)
            Triple("tie", getApplication<Application>().getString(R.string.verdict_parse_error_reasoning), getApplication<Application>().getString(R.string.verdict_parse_error_tts))
        }
    }

    private fun updateClashState(index: Int, updateAction: (ClashState) -> ClashState) {
        _uiState.update { currentState ->
            val updatedClashes = currentState.clashStates.toMutableList()
            if (index in updatedClashes.indices) updatedClashes[index] = updateAction(updatedClashes[index])
            currentState.copy(clashStates = updatedClashes)
        }
    }

    fun requestTtsForQuestion(clashIndex: Int, autoPlay: Boolean = false) {
        val clash = uiState.value.clashStates.getOrNull(clashIndex) ?: return
        val settings = uiState.value.clashSettings
        val questionToSpeak = clash.question

        if (!questionToSpeak.isNullOrBlank() && (settings?.isTtsEnabled == true || !autoPlay) && !clash.ttsQuestionHasBeenPlayed) {
            TtsService.speak(questionToSpeak, Locale.getDefault())
            updateClashState(clashIndex) { it.copy(ttsQuestionHasBeenPlayed = true) }
        }
    }

    fun requestTtsForReasoning(clashIndex: Int, autoPlay: Boolean = false) {
        val clash = uiState.value.clashStates.getOrNull(clashIndex) ?: return
        val settings = uiState.value.clashSettings

        if (!clash.ttsHasBeenPlayed) {
            val scriptToSpeak = clash.ttsScript
            if (clash.status == ClashStatus.COMPLETED && !scriptToSpeak.isNullOrBlank() && (settings?.isTtsEnabled == true || !autoPlay)) {
                TtsService.speak(scriptToSpeak, Locale.getDefault())
                updateClashState(clashIndex) { it.copy(ttsHasBeenPlayed = true) }
            }
        }
    }

    fun clearErrorMessage() {
        _uiState.update { it.copy(errorMessage = null) }
    }

    override fun onCleared() {
        super.onCleared()
        arenaService.stopAllEndpoints()
        llmHelper.cleanUp()
        TtsService.shutdown()
        inferenceJob?.cancel()
        judgeInitializationJob?.cancel()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/clash/viewmodel/ClashViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Types.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.common

import androidx.compose.ui.graphics.Color

interface LatencyProvider {
  val latencyMs: Float
}

data class Classification(val label: String, val score: Float, val color: Color)

data class JsonObjAndTextContent<T>(val jsonObj: T, val textContent: String)

class AudioClip(val audioData: ByteArray, val sampleRate: Int)


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Types.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Utils.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.common

import android.content.Context
import android.net.Uri
import android.util.Log
import be.heyman.android.ai.kikko.data.SAMPLE_RATE
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File
import java.net.HttpURLConnection
import java.net.URL
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.floor

data class LaunchInfo(val ts: Long)

private const val TAG = "AGUtils"
private const val LAUNCH_INFO_FILE_NAME = "launch_info"
private const val START_THINKING = "***Thinking...***"
private const val DONE_THINKING = "***Done thinking***"



fun cleanUpMediapipeTaskErrorMessage(message: String): String {
  val index = message.indexOf("=== Source Location Trace")
  if (index >= 0) {
    return message.substring(0, index)
  }
  return message
}

fun processLlmResponse(response: String): String {
  // Add "thinking" and "done thinking" around the thinking content.
  var newContent =
    response.replace("<think>", "$START_THINKING\n").replace("</think>", "\n$DONE_THINKING")

  // Remove empty thinking content.
  val endThinkingIndex = newContent.indexOf(DONE_THINKING)
  if (endThinkingIndex >= 0) {
    val thinkingContent =
      newContent
        .substring(0, endThinkingIndex + DONE_THINKING.length)
        .replace(START_THINKING, "")
        .replace(DONE_THINKING, "")
    if (thinkingContent.isBlank()) {
      newContent = newContent.substring(endThinkingIndex + DONE_THINKING.length)
    }
  }

  newContent = newContent.replace("\\n", "\n")

  return newContent
}

fun writeLaunchInfo(context: Context) {
  try {
    val gson = Gson()
    val launchInfo = LaunchInfo(ts = System.currentTimeMillis())
    val jsonString = gson.toJson(launchInfo)
    val file = File(context.getExternalFilesDir(null), LAUNCH_INFO_FILE_NAME)
    file.writeText(jsonString)
  } catch (e: Exception) {
    Log.e(TAG, "Failed to write launch info", e)
  }
}

inline fun <reified T> getJsonResponse(url: String): JsonObjAndTextContent<T>? {
  try {
    val connection = URL(url).openConnection() as HttpURLConnection
    connection.requestMethod = "GET"
    connection.connect()

    val responseCode = connection.responseCode
    if (responseCode == HttpURLConnection.HTTP_OK) {
      val inputStream = connection.inputStream
      val response = inputStream.bufferedReader().use { it.readText() }

      val gson = Gson()
      val type = object : TypeToken<T>() {}.type
      val jsonObj = gson.fromJson<T>(response, type)
      return JsonObjAndTextContent(jsonObj = jsonObj, textContent = response)
    } else {
      Log.e("AGUtils", "HTTP error: $responseCode")
    }
  } catch (e: Exception) {
    Log.e("AGUtils", "Error when getting json response: ${e.message}")
    e.printStackTrace()
  }

  return null
}

fun convertWavToMonoWithMaxSeconds(
  context: Context,
  stereoUri: Uri,
  maxSeconds: Int = 30,
): AudioClip? {
  Log.d(TAG, "Start to convert wav file to mono channel")

  try {
    val inputStream = context.contentResolver.openInputStream(stereoUri) ?: return null
    val originalBytes = inputStream.readBytes()
    inputStream.close()

    // Read WAV header
    if (originalBytes.size < 44) {
      // Not a valid WAV file
      Log.e(TAG, "Not a valid wav file")
      return null
    }

    val headerBuffer = ByteBuffer.wrap(originalBytes, 0, 44).order(ByteOrder.LITTLE_ENDIAN)
    val channels = headerBuffer.getShort(22)
    var sampleRate = headerBuffer.getInt(24)
    val bitDepth = headerBuffer.getShort(34)
    Log.d(TAG, "File metadata: channels: $channels, sampleRate: $sampleRate, bitDepth: $bitDepth")

    // Normalize audio to 16-bit.
    val audioDataBytes = originalBytes.copyOfRange(fromIndex = 44, toIndex = originalBytes.size)
    var sixteenBitBytes: ByteArray =
      if (bitDepth.toInt() == 8) {
        Log.d(TAG, "Converting 8-bit audio to 16-bit.")
        convert8BitTo16Bit(audioDataBytes)
      } else {
        // Assume 16-bit or other format that can be handled directly
        audioDataBytes
      }

    // Convert byte array to short array for processing
    val shortBuffer =
      ByteBuffer.wrap(sixteenBitBytes).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer()
    var pcmSamples = ShortArray(shortBuffer.remaining())
    shortBuffer.get(pcmSamples)

    // Resample if sample rate is less than 16000 Hz ---
    if (sampleRate < SAMPLE_RATE) {
      Log.d(TAG, "Resampling from $sampleRate Hz to $SAMPLE_RATE Hz.")
      pcmSamples = resample(pcmSamples, sampleRate, SAMPLE_RATE, channels.toInt())
      sampleRate = SAMPLE_RATE
      Log.d(TAG, "Resampling complete. New sample count: ${pcmSamples.size}")
    }

    // Convert stereo to mono if necessary
    var monoSamples =
      if (channels.toInt() == 2) {
        Log.d(TAG, "Converting stereo to mono.")
        val mono = ShortArray(pcmSamples.size / 2)
        for (i in mono.indices) {
          val left = pcmSamples[i * 2]
          val right = pcmSamples[i * 2 + 1]
          mono[i] = ((left + right) / 2).toShort()
        }
        mono
      } else {
        Log.d(TAG, "Audio is already mono. No channel conversion needed.")
        pcmSamples
      }

    // Trim the audio to maxSeconds ---
    val maxSamples = maxSeconds * sampleRate
    if (monoSamples.size > maxSamples) {
      Log.d(TAG, "Trimming clip from ${monoSamples.size} samples to $maxSamples samples.")
      monoSamples = monoSamples.copyOfRange(0, maxSamples)
    }

    val monoByteBuffer = ByteBuffer.allocate(monoSamples.size * 2).order(ByteOrder.LITTLE_ENDIAN)
    monoByteBuffer.asShortBuffer().put(monoSamples)
    return AudioClip(audioData = monoByteBuffer.array(), sampleRate = sampleRate)
  } catch (e: Exception) {
    Log.e(TAG, "Failed to convert wav to mono", e)
    return null
  }
}

/** Converts 8-bit unsigned PCM audio data to 16-bit signed PCM. */
private fun convert8BitTo16Bit(eightBitData: ByteArray): ByteArray {
  // The new 16-bit data will be twice the size
  val sixteenBitData = ByteArray(eightBitData.size * 2)
  val buffer = ByteBuffer.wrap(sixteenBitData).order(ByteOrder.LITTLE_ENDIAN)

  for (byte in eightBitData) {
    // Convert the unsigned 8-bit byte (0-255) to a signed 16-bit short (-32768 to 32767)
    // 1. Get the unsigned value by masking with 0xFF
    // 2. Subtract 128 to center the waveform around 0 (range becomes -128 to 127)
    // 3. Scale by 256 to expand to the 16-bit range
    val unsignedByte = byte.toInt() and 0xFF
    val sixteenBitSample = ((unsignedByte - 128) * 256).toShort()
    buffer.putShort(sixteenBitSample)
  }
  return sixteenBitData
}

/** Resamples PCM audio data from an original sample rate to a target sample rate. */
private fun resample(
  inputSamples: ShortArray,
  originalSampleRate: Int,
  targetSampleRate: Int,
  channels: Int,
): ShortArray {
  if (originalSampleRate == targetSampleRate) {
    return inputSamples
  }

  val ratio = targetSampleRate.toDouble() / originalSampleRate
  val outputLength = (inputSamples.size * ratio).toInt()
  val resampledData = ShortArray(outputLength)

  if (channels == 1) { // Mono
    for (i in resampledData.indices) {
      val position = i / ratio
      val index1 = floor(position).toInt()
      val index2 = index1 + 1
      val fraction = position - index1

      val sample1 = if (index1 < inputSamples.size) inputSamples[index1].toDouble() else 0.0
      val sample2 = if (index2 < inputSamples.size) inputSamples[index2].toDouble() else 0.0

      resampledData[i] = (sample1 * (1 - fraction) + sample2 * fraction).toInt().toShort()
    }
  }

  return resampledData
}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/common/Utils.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Config.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

import kotlin.math.abs

/**
 * The types of configuration editors available.
 *
 * This enum defines the different UI components used to edit configuration values. Each type
 * corresponds to a specific editor widget, such as a slider or a switch.
 */
enum class ConfigEditorType {
  LABEL,
  NUMBER_SLIDER,
  BOOLEAN_SWITCH,
  DROPDOWN,
}

/** The data types of configuration values. */
enum class ValueType {
  INT,
  FLOAT,
  DOUBLE,
  STRING,
  BOOLEAN,
}

enum class ConfigKey(val label: String) {
  MAX_TOKENS("Max tokens"),
  TOPK("TopK"),
  TOPP("TopP"),
  TEMPERATURE("Temperature"),
  DEFAULT_MAX_TOKENS("Default max tokens"),
  DEFAULT_TOPK("Default TopK"),
  DEFAULT_TOPP("Default TopP"),
  DEFAULT_TEMPERATURE("Default temperature"),
  SUPPORT_IMAGE("Support image"),
  SUPPORT_AUDIO("Support audio"),
  MAX_RESULT_COUNT("Max result count"),
  USE_GPU("Use GPU"),
  ACCELERATOR("Choose accelerator"),
  COMPATIBLE_ACCELERATORS("Compatible accelerators"),
  WARM_UP_ITERATIONS("Warm up iterations"),
  BENCHMARK_ITERATIONS("Benchmark iterations"),
  ITERATIONS("Iterations"),
  THEME("Theme"),
  NAME("Name"),
  MODEL_TYPE("Model type"),
}

/**
 * Base class for configuration settings.
 *
 * @param type The type of configuration editor.
 * @param key The unique key for the configuration setting.
 * @param defaultValue The default value for the configuration setting.
 * @param valueType The data type of the configuration value.
 * @param needReinitialization Indicates whether the model needs to be reinitialized after changing
 *   this config.
 */
open class Config(
  val type: ConfigEditorType,
  open val key: ConfigKey,
  open val defaultValue: Any,
  open val valueType: ValueType,
  open val needReinitialization: Boolean = true,
)

/** Configuration setting for a label. */
class LabelConfig(override val key: ConfigKey, override val defaultValue: String = "") :
  Config(
    type = ConfigEditorType.LABEL,
    key = key,
    defaultValue = defaultValue,
    valueType = ValueType.STRING,
  )

/**
 * Configuration setting for a number slider.
 *
 * @param sliderMin The minimum value of the slider.
 * @param sliderMax The maximum value of the slider.
 */
class NumberSliderConfig(
  override val key: ConfigKey,
  val sliderMin: Float,
  val sliderMax: Float,
  override val defaultValue: Float,
  override val valueType: ValueType,
  override val needReinitialization: Boolean = true,
) :
  Config(
    type = ConfigEditorType.NUMBER_SLIDER,
    key = key,
    defaultValue = defaultValue,
    valueType = valueType,
  )

/** Configuration setting for a boolean switch. */
class BooleanSwitchConfig(
  override val key: ConfigKey,
  override val defaultValue: Boolean,
  override val needReinitialization: Boolean = true,
) :
  Config(
    type = ConfigEditorType.BOOLEAN_SWITCH,
    key = key,
    defaultValue = defaultValue,
    valueType = ValueType.BOOLEAN,
  )

/** Configuration setting for a dropdown. */
class SegmentedButtonConfig(
  override val key: ConfigKey,
  override val defaultValue: String,
  val options: List<String>,
  val allowMultiple: Boolean = false,
) :
  Config(
    type = ConfigEditorType.DROPDOWN,
    key = key,
    defaultValue = defaultValue,
    // The emitted value will be comma-separated labels when allowMultiple=true.
    valueType = ValueType.STRING,
  )

fun convertValueToTargetType(value: Any, valueType: ValueType): Any {
  return when (valueType) {
    ValueType.INT ->
      when (value) {
        is Int -> value
        is Float -> value.toInt()
        is Double -> value.toInt()
        is String -> value.toIntOrNull() ?: ""
        is Boolean -> if (value) 1 else 0
        else -> ""
      }

    ValueType.FLOAT ->
      when (value) {
        is Int -> value.toFloat()
        is Float -> value
        is Double -> value.toFloat()
        is String -> value.toFloatOrNull() ?: ""
        is Boolean -> if (value) 1f else 0f
        else -> ""
      }

    ValueType.DOUBLE ->
      when (value) {
        is Int -> value.toDouble()
        is Float -> value.toDouble()
        is Double -> value
        is String -> value.toDoubleOrNull() ?: ""
        is Boolean -> if (value) 1.0 else 0.0
        else -> ""
      }

    ValueType.BOOLEAN ->
      when (value) {
        is Int -> value == 0
        is Boolean -> value
        is Float -> abs(value) > 1e-6
        is Double -> abs(value) > 1e-6
        is String -> value.isNotEmpty()
        else -> false
      }

    ValueType.STRING -> value.toString()
  }
}

fun createLlmChatConfigs(
  defaultMaxToken: Int = DEFAULT_MAX_TOKEN,
  defaultTopK: Int = DEFAULT_TOPK,
  defaultTopP: Float = DEFAULT_TOPP,
  defaultTemperature: Float = DEFAULT_TEMPERATURE,
  accelerators: List<Accelerator> = DEFAULT_ACCELERATORS,
): List<Config> {
  return listOf(
    LabelConfig(key = ConfigKey.MAX_TOKENS, defaultValue = "$defaultMaxToken"),
    NumberSliderConfig(
      key = ConfigKey.TOPK,
      sliderMin = 5f,
      sliderMax = 100f,
      defaultValue = defaultTopK.toFloat(),
      valueType = ValueType.INT,
    ),
    NumberSliderConfig(
      key = ConfigKey.TOPP,
      sliderMin = 0.0f,
      sliderMax = 1.0f,
      defaultValue = defaultTopP,
      valueType = ValueType.FLOAT,
    ),
    NumberSliderConfig(
      key = ConfigKey.TEMPERATURE,
      sliderMin = 0.0f,
      sliderMax = 2.0f,
      defaultValue = defaultTemperature,
      valueType = ValueType.FLOAT,
    ),
    SegmentedButtonConfig(
      key = ConfigKey.ACCELERATOR,
      defaultValue = accelerators[0].label,
      options = accelerators.map { it.label },
    ),
  )
}

fun getConfigValueString(value: Any, config: Config): String {
  var strNewValue = "$value"
  if (config.valueType == ValueType.FLOAT) {
    strNewValue = "%.2f".format(value)
  }
  return strNewValue
}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Config.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Consts.kt ---

package be.heyman.android.ai.kikko.data

// Keys used to send/receive data to Work.
const val KEY_MODEL_URL = "KEY_MODEL_URL"
const val KEY_MODEL_NAME = "KEY_MODEL_NAME"
const val KEY_MODEL_VERSION = "KEY_MODEL_VERSION"
const val KEY_MODEL_DOWNLOAD_MODEL_DIR = "KEY_MODEL_DOWNLOAD_MODEL_DIR"
const val KEY_MODEL_DOWNLOAD_FILE_NAME = "KEY_MODEL_DOWNLOAD_FILE_NAME"
const val KEY_MODEL_TOTAL_BYTES = "KEY_MODEL_TOTAL_BYTES"
const val KEY_MODEL_DOWNLOAD_RECEIVED_BYTES = "KEY_MODEL_DOWNLOAD_RECEIVED_BYTES"
const val KEY_MODEL_DOWNLOAD_RATE = "KEY_MODEL_DOWNLOAD_RATE"
const val KEY_MODEL_DOWNLOAD_REMAINING_MS = "KEY_MODEL_DOWNLOAD_REMAINING_SECONDS"
const val KEY_MODEL_DOWNLOAD_ERROR_MESSAGE = "KEY_MODEL_DOWNLOAD_ERROR_MESSAGE"
const val KEY_MODEL_DOWNLOAD_ACCESS_TOKEN = "KEY_MODEL_DOWNLOAD_ACCESS_TOKEN"
const val KEY_MODEL_DOWNLOAD_APP_TS = "KEY_MODEL_DOWNLOAD_APP_TS"
const val KEY_MODEL_EXTRA_DATA_URLS = "KEY_MODEL_EXTRA_DATA_URLS"
const val KEY_MODEL_EXTRA_DATA_DOWNLOAD_FILE_NAMES = "KEY_MODEL_EXTRA_DATA_DOWNLOAD_FILE_NAMES"
const val KEY_MODEL_IS_ZIP = "KEY_MODEL_IS_ZIP"
const val KEY_MODEL_UNZIPPED_DIR = "KEY_MODEL_UNZIPPED_DIR"
const val KEY_MODEL_START_UNZIPPING = "KEY_MODEL_START_UNZIPPING"

// Default values for LLM models.
const val DEFAULT_MAX_TOKEN = 1024
const val DEFAULT_TOPK = 40
const val DEFAULT_TOPP = 0.9f
const val DEFAULT_TEMPERATURE = 1.0f
val DEFAULT_ACCELERATORS = listOf(Accelerator.GPU)

// Max number of images allowed in a "ask image" session.
const val MAX_IMAGE_COUNT = 10

// Max number of audio clip in an "ask audio" session.
const val MAX_AUDIO_CLIP_COUNT = 1

// Max audio clip duration in seconds.
const val MAX_AUDIO_CLIP_DURATION_SEC = 30

// Audio-recording related consts.
const val SAMPLE_RATE = 16000

// BOURDON'S FIX: Constantes de débogage qui sont maintenant utilisées dans l'application principale.
const val DEFAULT_MAX_TOKENS_DEBUG = 2048

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Consts.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Model.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

import android.content.Context
import java.io.File

data class ModelDataFile(
  val name: String,
  val url: String,
  val downloadFileName: String,
  val sizeInBytes: Long,
)

const val IMPORTS_DIR = "__imports"
private val NORMALIZE_NAME_REGEX = Regex("[^a-zA-Z0-9]")

data class PromptTemplate(val title: String, val description: String, val prompt: String)

/** A model for a task */
data class Model(
  /** The name (for display purpose) of the model. */
  val name: String,

  /** The version of the model. */
  val version: String = "_",

  /**
   * The name of the downloaded model file.
   *
   * The final file path of the downloaded model will be:
   * {context.getExternalFilesDir}/{normalizedName}/{version}/{downloadFileName}
   */
  val downloadFileName: String,

  /** The URL to download the model from. */
  val url: String,

  /** The size of the model file in bytes. */
  val sizeInBytes: Long,

  /** A list of additional data files required by the model. */
  val extraDataFiles: List<ModelDataFile> = listOf(),

  /**
   * A description or information about the model.
   *
   * Will be shown at the start of the chat session and in the expanded model item.
   */
  val info: String = "",

  /** The url to jump to when clicking "learn more" in expanded model item. */
  val learnMoreUrl: String = "",

  /** A list of configurable parameters for the model. */
  val configs: List<Config> = listOf(),

  /** Whether to show the "run again" button in the UI. */
  val showRunAgainButton: Boolean = true,

  /** Whether to show the "benchmark" button in the UI. */
  val showBenchmarkButton: Boolean = true,

  /** Indicates whether the model is a zip file. */
  val isZip: Boolean = false,

  /** The name of the directory to unzip the model to (if it's a zip file). */
  val unzipDir: String = "",

  /** The prompt templates for the model (only for LLM). */
  val llmPromptTemplates: List<PromptTemplate> = listOf(),

  /** Whether the LLM model supports image input. */
  val llmSupportImage: Boolean = false,

  /** Whether the LLM model supports audio input. */
  val llmSupportAudio: Boolean = false,

  /** Whether the model is imported or not. */
  val imported: Boolean = false,

  // The following fields are managed by the app. Don't need to set manually.
  var normalizedName: String = "",
  var instance: Any? = null,
  var initializing: Boolean = false,
  // TODO(jingjin): use a "queue" system to manage model init and cleanup.
  var cleanUpAfterInit: Boolean = false,
  var configValues: Map<String, Any> = mapOf(),
  var totalBytes: Long = 0L,
  var accessToken: String? = null,

  /** The estimated peak memory in byte to run the model. */
  val estimatedPeakMemoryInBytes: Long? = null,
) {
  init {
    normalizedName = NORMALIZE_NAME_REGEX.replace(name, "_")
  }

  fun preProcess() {
    val configValues: MutableMap<String, Any> = mutableMapOf()
    for (config in this.configs) {
      configValues[config.key.label] = config.defaultValue
    }
    this.configValues = configValues
    this.totalBytes = this.sizeInBytes + this.extraDataFiles.sumOf { it.sizeInBytes }
  }

  fun getPath(context: Context, fileName: String = downloadFileName): String {
    if (imported) {
      return listOf(context.getExternalFilesDir(null)?.absolutePath ?: "", fileName)
        .joinToString(File.separator)
    }

    val baseDir =
      listOf(context.getExternalFilesDir(null)?.absolutePath ?: "", normalizedName, version)
        .joinToString(File.separator)
    return if (this.isZip && this.unzipDir.isNotEmpty()) {
      "$baseDir/${this.unzipDir}"
    } else {
      "$baseDir/$fileName"
    }
  }

  fun getIntConfigValue(key: ConfigKey, defaultValue: Int = 0): Int {
    return getTypedConfigValue(key = key, valueType = ValueType.INT, defaultValue = defaultValue)
      as Int
  }

  fun getFloatConfigValue(key: ConfigKey, defaultValue: Float = 0.0f): Float {
    return getTypedConfigValue(key = key, valueType = ValueType.FLOAT, defaultValue = defaultValue)
      as Float
  }

  fun getBooleanConfigValue(key: ConfigKey, defaultValue: Boolean = false): Boolean {
    return getTypedConfigValue(
      key = key,
      valueType = ValueType.BOOLEAN,
      defaultValue = defaultValue,
    )
      as Boolean
  }

  fun getStringConfigValue(key: ConfigKey, defaultValue: String = ""): String {
    return getTypedConfigValue(key = key, valueType = ValueType.STRING, defaultValue = defaultValue)
      as String
  }

  fun getExtraDataFile(name: String): ModelDataFile? {
    return extraDataFiles.find { it.name == name }
  }

  private fun getTypedConfigValue(key: ConfigKey, valueType: ValueType, defaultValue: Any): Any {
    return convertValueToTargetType(
      value = configValues.getOrDefault(key.label, defaultValue),
      valueType = valueType,
    )
  }
}

enum class ModelDownloadStatusType {
  NOT_DOWNLOADED,
  PARTIALLY_DOWNLOADED,
  IN_PROGRESS,
  UNZIPPING,
  SUCCEEDED,
  FAILED,
}

data class ModelDownloadStatus(
  val status: ModelDownloadStatusType,
  val totalBytes: Long = 0,
  val receivedBytes: Long = 0,
  val errorMessage: String = "",
  val bytesPerSecond: Long = 0,
  val remainingMs: Long = 0,
)

////////////////////////////////////////////////////////////////////////////////////////////////////
// Configs.

val MOBILENET_CONFIGS: List<Config> =
  listOf(
    NumberSliderConfig(
      key = ConfigKey.MAX_RESULT_COUNT,
      sliderMin = 1f,
      sliderMax = 5f,
      defaultValue = 3f,
      valueType = ValueType.INT,
    ),
    BooleanSwitchConfig(key = ConfigKey.USE_GPU, defaultValue = false),
  )

val IMAGE_GENERATION_CONFIGS: List<Config> =
  listOf(
    NumberSliderConfig(
      key = ConfigKey.ITERATIONS,
      sliderMin = 5f,
      sliderMax = 50f,
      defaultValue = 10f,
      valueType = ValueType.INT,
      needReinitialization = false,
    )
  )

const val TEXT_CLASSIFICATION_INFO =
  "Model is trained on movie reviews dataset. Type a movie review below and see the scores of positive or negative sentiment."

const val TEXT_CLASSIFICATION_LEARN_MORE_URL =
  "https://ai.google.dev/edge/mediapipe/solutions/text/text_classifier"

const val IMAGE_CLASSIFICATION_INFO = ""

const val IMAGE_CLASSIFICATION_LEARN_MORE_URL = "https://ai.google.dev/edge/litert/android"

const val IMAGE_GENERATION_INFO =
  "Powered by [MediaPipe Image Generation API](https://ai.google.dev/edge/mediapipe/solutions/vision/image_generator/android)"

val MODEL_TEXT_CLASSIFICATION_MOBILEBERT: Model =
  Model(
    name = "MobileBert",
    downloadFileName = "bert_classifier.tflite",
    url =
      "https://storage.googleapis.com/mediapipe-models/text_classifier/bert_classifier/float32/latest/bert_classifier.tflite",
    sizeInBytes = 25707538L,
    info = TEXT_CLASSIFICATION_INFO,
    learnMoreUrl = TEXT_CLASSIFICATION_LEARN_MORE_URL,
  )

val MODEL_TEXT_CLASSIFICATION_AVERAGE_WORD_EMBEDDING: Model =
  Model(
    name = "Average word embedding",
    downloadFileName = "average_word_classifier.tflite",
    url =
      "https://storage.googleapis.com/mediapipe-models/text_classifier/average_word_classifier/float32/latest/average_word_classifier.tflite",
    sizeInBytes = 775708L,
    info = TEXT_CLASSIFICATION_INFO,
  )

val MODEL_IMAGE_CLASSIFICATION_MOBILENET_V1: Model =
  Model(
    name = "Mobilenet V1",
    downloadFileName = "mobilenet_v1.tflite",
    url = "https://storage.googleapis.com/tfweb/app_gallery_models/mobilenet_v1.tflite",
    sizeInBytes = 16900760L,
    extraDataFiles =
      listOf(
        ModelDataFile(
          name = "labels",
          url =
            "https://raw.githubusercontent.com/leferrad/tensorflow-mobilenet/refs/heads/master/imagenet/labels.txt",
          downloadFileName = "mobilenet_labels_v1.txt",
          sizeInBytes = 21685L,
        )
      ),
    configs = MOBILENET_CONFIGS,
    info = IMAGE_CLASSIFICATION_INFO,
    learnMoreUrl = IMAGE_CLASSIFICATION_LEARN_MORE_URL,
  )

val MODEL_IMAGE_CLASSIFICATION_MOBILENET_V2: Model =
  Model(
    name = "Mobilenet V2",
    downloadFileName = "mobilenet_v2.tflite",
    url = "https://storage.googleapis.com/tfweb/app_gallery_models/mobilenet_v2.tflite",
    sizeInBytes = 13978596L,
    extraDataFiles =
      listOf(
        ModelDataFile(
          name = "labels",
          url =
            "https://raw.githubusercontent.com/leferrad/tensorflow-mobilenet/refs/heads/master/imagenet/labels.txt",
          downloadFileName = "mobilenet_labels_v2.txt",
          sizeInBytes = 21685L,
        )
      ),
    configs = MOBILENET_CONFIGS,
    info = IMAGE_CLASSIFICATION_INFO,
  )

val MODEL_IMAGE_GENERATION_STABLE_DIFFUSION: Model =
  Model(
    name = "Stable diffusion",
    downloadFileName = "sd15.zip",
    isZip = true,
    unzipDir = "sd15",
    url = "https://storage.googleapis.com/tfweb/app_gallery_models/sd15.zip",
    sizeInBytes = 1906219565L,
    showRunAgainButton = false,
    showBenchmarkButton = false,
    info = IMAGE_GENERATION_INFO,
    configs = IMAGE_GENERATION_CONFIGS,
    learnMoreUrl = "https://huggingface.co/litert-community",
  )

val EMPTY_MODEL: Model =
  Model(name = "empty", downloadFileName = "empty.tflite", url = "", sizeInBytes = 0L)

////////////////////////////////////////////////////////////////////////////////////////////////////
// Model collections for different tasks.

val MODELS_TEXT_CLASSIFICATION: MutableList<Model> =
  mutableListOf(
    MODEL_TEXT_CLASSIFICATION_MOBILEBERT,
    MODEL_TEXT_CLASSIFICATION_AVERAGE_WORD_EMBEDDING,
  )

val MODELS_IMAGE_CLASSIFICATION: MutableList<Model> =
  mutableListOf(MODEL_IMAGE_CLASSIFICATION_MOBILENET_V1, MODEL_IMAGE_CLASSIFICATION_MOBILENET_V2)

val MODELS_IMAGE_GENERATION: MutableList<Model> =
  mutableListOf(MODEL_IMAGE_GENERATION_STABLE_DIFFUSION)


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Model.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/ModelCatalogue.kt ---

package be.heyman.android.ai.kikko.data

import be.heyman.android.ai.kikko.data.ConfigKey

/**
 * Catalogue des modèles LLM et Vosk disponibles pour l'application.
 * Ces modèles peuvent être téléchargés par l'utilisateur via la boîte à outils.
 * Initialement dans le package `debug`, il est déplacé ici car ses informations
 * sont utilisées par des fonctionnalités principales (ex: ToolsDialogFragment).
 */
object ModelCatalogue {

    val allModels: List<Model> = listOf(
        Model(
            name = "Gemma 3n E2B (kikko.be - zip)",
            downloadFileName = "gemma-3n-E2B-it-int4.task.zip",
            url = "https://www.kikko.be/model/gemma-3n-E2B-it-int4.task.zip",
            sizeInBytes = 2450829619,
            isZip = true,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3n E2B (.task direct)",
            downloadFileName = "gemma-3n-E2B-it-int4.task",
            url = "https://www.kikko.be/model/gemma-3n-E2B-it-int4.task",
            sizeInBytes = 3136226711,
            isZip = false,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3n E4B (kikko.be - zip)",
            downloadFileName = "gemma-3n-E4B-it-int4.task.zip",
            url = "https://www.kikko.be/model/gemma-3n-E4B-it-int4.task.zip",
            sizeInBytes = 3513918248,
            isZip = true,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3n E4B (.task direct)",
            downloadFileName = "gemma-3n-E4B-it-int4.task",
            url = "https://www.kikko.be/model/gemma-3n-E4B-it-int4.task",
            sizeInBytes = 4405655031,
            isZip = false,
            unzipDir = "",
            llmSupportImage = true,
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Gemma 3 1B (kikko.be)",
            downloadFileName = "gemma3-1B-it-int4.task.zip",
            url = "https://www.kikko.be/model/gemma3-1B-it-int4.task.zip",
            sizeInBytes = 392700000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 4096)
        ),
        Model(
            name = "Qwen 2.5 1.8B Chat (kikko.be)",
            downloadFileName = "Qwen2.5-1.5B-Instruct_multi-prefill-seq_q8_ekv1280.task.zip",
            url = "https://www.kikko.be/model/Qwen2.5-1.5B-Instruct_multi-prefill-seq_q8_ekv1280.task.zip",
            sizeInBytes = 1380000000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "Hammer 2.1 - 1.5B (kikko.be)",
            downloadFileName = "hammer2.1_1.5b_q8_ekv4096.task.zip",
            url = "https://www.kikko.be/model/hammer2.1_1.5b_q8_ekv4096.task.zip",
            sizeInBytes = 1380000000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "Hammer 2.1 - 0.5B (kikko.be)",
            downloadFileName = "hammer2p1_05b_.task",
            url = "https://www.kikko.be/model/hammer2p1_05b_.task",
            sizeInBytes = 1380000000,
            isZip = false,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "DeepSeek (kikko.be) Zip",
            downloadFileName = "deepseek_q8_ekv1280.task.zip",
            url = "https://www.kikko.be/model/deepseek_q8_ekv1280.task.zip",
            sizeInBytes = 1560000000,
            isZip = true,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "DeepSeek (kikko.be) task",
            downloadFileName = "deepseek_q8_ekv1280.task",
            url = "https://www.kikko.be/model/deepseek_q8_ekv1280.task",
            sizeInBytes = 1860000000,
            isZip = false,
            unzipDir = "",
            configValues = mapOf(ConfigKey.MAX_TOKENS.label to 2048)
        ),
        Model(
            name = "Vosk Small French (kikko.be)",
            downloadFileName = "vosk-model-small-fr-0.22.zip",
            url = "https://www.kikko.be/model/vosk-model-small-fr-0.22.zip",
            sizeInBytes = 42233323,
            isZip = true,
            unzipDir = "vosk-model-small-fr-0.22"
        ),
        Model(
            name = "Vosk Small English (kikko.be)",
            downloadFileName = "vosk-model-small-en-us-0.15.zip",
            url = "https://www.kikko.be/model/vosk-model-small-en-us-0.15.zip",
            sizeInBytes = 41205931,
            isZip = true,
            unzipDir = "vosk-model-small-en-us-0.15"
        ),
        Model(
            name = "Vosk Small Japanese (kikko.be)",
            downloadFileName = "vosk-model-small-ja-0.22.zip",
            url = "https://www.kikko.be/model/vosk-model-small-ja-0.22.zip",
            sizeInBytes = 49704573,
            isZip = true,
            unzipDir = "vosk-model-small-ja-0.22"
        )
    )
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/ModelCatalogue.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Types.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

enum class Accelerator(val label: String) {
  CPU(label = "CPU"),
  GPU(label = "GPU"),
}


--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/data/Types.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/CardDetailsDialogFragment.kt ---

package be.heyman.android.ai.kikko.deck

import android.content.Context
import android.graphics.BitmapFactory
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.royal_audience.RoyalAudienceActivity
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.chip.Chip
import java.io.File
import java.util.Locale

class CardDetailsDialogFragment : DialogFragment() {

    interface CardDetailsListener {
        fun onDeleteCard(card: KnowledgeCard)
        fun onLaunchQuiz(card: KnowledgeCard)
        fun onTranslateCard(card: KnowledgeCard)
    }

    private var listener: CardDetailsListener? = null
    private lateinit var card: KnowledgeCard

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = parentFragment as? CardDetailsListener ?: context as? CardDetailsListener
        if (listener == null) {
            android.util.Log.w("CardDetailsDialog", "$context must implement CardDetailsListener to handle actions.")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NORMAL, R.style.Theme_Kikko_FullScreenDialog)
        arguments?.let {
            @Suppress("DEPRECATION")
            card = it.getParcelable(ARG_CARD)!!
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.dialog_card_details, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val imageView: ImageView = view.findViewById(R.id.card_details_image)
        val specificNameTextView: TextView = view.findViewById(R.id.card_details_specific_name)
        val deckNameChip: Chip = view.findViewById(R.id.card_details_deck_name)
        val confidenceTextView: TextView = view.findViewById(R.id.card_details_confidence)
        val descriptionTextView: TextView = view.findViewById(R.id.card_details_description)
        val reasoningTextView: TextView = view.findViewById(R.id.card_details_reasoning)
        val statsTextView: TextView = view.findViewById(R.id.card_details_stats)
        val deleteButton: Button = view.findViewById(R.id.card_details_button_delete)
        val quizButton: Button = view.findViewById(R.id.card_details_button_quiz)
        val chatButton: Button = view.findViewById(R.id.card_details_button_chat)
        val translateButton: Button = view.findViewById(R.id.card_details_button_translate)

        val deviceLang = Locale.getDefault().language
        val translatedContent = card.translations?.get(deviceLang)

        val displayedName = card.specificName
        val displayedDescription = translatedContent?.description ?: card.description
        val displayedReasoning = translatedContent?.reasoning ?: card.reasoning
        val displayedQuiz = translatedContent?.quiz ?: card.quiz


        card.imagePath?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                val bitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                imageView.setImageBitmap(bitmap)
            }
        }

        specificNameTextView.text = displayedName
        deckNameChip.text = card.deckName
        confidenceTextView.text = getString(R.string.card_details_confidence_format, card.confidence)
        descriptionTextView.text = displayedDescription

        reasoningTextView.text = getString(
            R.string.card_details_reasoning_format,
            displayedReasoning.visualAnalysis,
            displayedReasoning.evidenceCorrelation
        )

        val statsText = card.stats?.items?.map { (key, value) ->
            "${key.replaceFirstChar { it.titlecase() }}: $value"
        }?.joinToString("\n") ?: getString(R.string.card_details_no_stats_available)
        statsTextView.text = statsText

        deleteButton.setOnClickListener {
            listener?.onDeleteCard(card)
            dismiss()
        }

        quizButton.setOnClickListener {
            listener?.onLaunchQuiz(card)
            dismiss()
        }
        // Le bouton de quiz est désactivé via le layout et ne sera pas réactivé ici
        // quizButton.isEnabled = !displayedQuiz.isNullOrEmpty()

        chatButton.setOnClickListener {
            val intent = RoyalAudienceActivity.newIntent(requireContext(), card.id)
            startActivity(intent)
            dismiss()
        }

        translateButton.setOnClickListener {
            listener?.onTranslateCard(card)
            dismiss()
        }
        // Le bouton de traduction est désactivé via le layout et ne sera pas réactivé ici.
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        private const val ARG_CARD = "card"

        fun newInstance(card: KnowledgeCard): CardDetailsDialogFragment {
            val fragment = CardDetailsDialogFragment()
            val args = Bundle()
            args.putParcelable(ARG_CARD, card)
            fragment.arguments = args
            return fragment
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/CardDetailsDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckCardAdapter.kt ---

package be.heyman.android.ai.kikko.deck

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import java.io.File

/**
 * BOURDON'S REFACTOR V3:
 * L'adaptateur utilise maintenant le layout correct `item_clash_deck_thumbnail.xml`
 * pour une présentation en grille élégante et compacte.
 *
 * @param onCardClicked Une fonction lambda appelée lorsqu'une carte est cliquée.
 */
class DeckCardAdapter(
    private var cards: List<KnowledgeCard>,
    private val onCardClicked: (KnowledgeCard) -> Unit
) : RecyclerView.Adapter<DeckCardAdapter.CardViewHolder>() {

    /**
     * ViewHolder dédié qui contient les vues pour la vignette de champion.
     */
    class CardViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        // BOURDON'S FIX: Les IDs sont maintenant ceux de `item_clash_deck_thumbnail.xml`
        val cardNameView: TextView = view.findViewById(R.id.card_thumbnail_name)
        val cardImageView: ImageView = view.findViewById(R.id.card_thumbnail_image)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CardViewHolder {
        // BOURDON'S FIX: Utilisation du nouveau layout correct.
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_clash_deck_thumbnail, parent, false)
        return CardViewHolder(view)
    }

    override fun onBindViewHolder(holder: CardViewHolder, position: Int) {
        val card = cards[position]
        holder.cardNameView.text = card.specificName

        card.imagePath?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                val myBitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                holder.cardImageView.setImageBitmap(myBitmap)
            } else {
                holder.cardImageView.setImageResource(R.drawable.ic_placeholder_card)
            }
        } ?: holder.cardImageView.setImageResource(R.drawable.ic_placeholder_card)

        holder.itemView.setOnClickListener {
            onCardClicked(card)
        }
    }

    override fun getItemCount(): Int = cards.size

    /**
     * Met à jour la liste des cartes affichées par l'adaptateur et notifie le changement.
     */
    fun updateCards(newCards: List<KnowledgeCard>) {
        this.cards = newCards
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckCardAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPageFragment.kt ---

package be.heyman.android.ai.kikko.deck

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
// BOURDON'S FIX: L'import a été corrigé pour pointer vers le package 'deck' au lieu de 'debug'.
import be.heyman.android.ai.kikko.deck.CardDetailsDialogFragment
import be.heyman.android.ai.kikko.model.KnowledgeCard

/**
 * Un Fragment qui affiche une grille de KnowledgeCards pour un seul deck.
 */
class DeckPageFragment : Fragment() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var deckCardAdapter: DeckCardAdapter
    private var cards: ArrayList<KnowledgeCard>? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Récupère les cartes passées en argument lors de la création du fragment.
        arguments?.let {
            @Suppress("DEPRECATION")
            cards = it.getParcelableArrayList(ARG_CARDS)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate le layout pour ce fragment.
        return inflater.inflate(R.layout.fragment_deck_page, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        recyclerView = view.findViewById(R.id.deck_page_recyclerview)
        setupRecyclerView()
    }

    private fun setupRecyclerView() {
        // Initialise l'adaptateur avec la liste de cartes (ou une liste vide).
        deckCardAdapter = DeckCardAdapter(cards ?: emptyList()) { card ->
            // Affiche le dialogue des détails de la carte lorsqu'une carte est cliquée.
            CardDetailsDialogFragment.newInstance(card).show(parentFragmentManager, "CardDetailsDialog")
        }
        recyclerView.apply {
            // Utilise un GridLayoutManager pour afficher les cartes en grille de 2 colonnes.
            layoutManager = GridLayoutManager(context, 2)
            adapter = deckCardAdapter
        }
    }

    companion object {
        private const val ARG_CARDS = "cards_for_deck"

        /**
         * Méthode factory pour créer une nouvelle instance de ce fragment
         * avec une liste spécifique de cartes.
         *
         * @param cards La liste des cartes à afficher.
         * @return Une nouvelle instance de DeckPageFragment.
         */
        @JvmStatic
        fun newInstance(cards: List<KnowledgeCard>) =
            DeckPageFragment().apply {
                arguments = Bundle().apply {
                    // Les objets personnalisés doivent être Parcelable pour être passés dans un Bundle.
                    putParcelableArrayList(ARG_CARDS, ArrayList(cards))
                }
            }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPageFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPagerAdapter.kt ---

package be.heyman.android.ai.kikko.deck

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import be.heyman.android.ai.kikko.model.KnowledgeCard

/**
 * Un adaptateur qui fournit des fragments (DeckPageFragment) pour chaque deck de cartes
 * à un ViewPager2.
 *
 * @param fa L'activité hôte du fragment.
 * @param decks La map contenant les decks, où la clé est le nom du deck et la valeur est la liste des cartes.
 */
class DeckPagerAdapter(fa: FragmentActivity, private val decks: Map<String, List<KnowledgeCard>>) : FragmentStateAdapter(fa) {

    // Crée une liste des noms de decks pour un accès par indice.
    private val deckNames = decks.keys.toList()

    /**
     * Retourne le nombre total de decks (et donc de pages).
     */
    override fun getItemCount(): Int {
        return decks.size
    }

    /**
     * Crée et retourne un DeckPageFragment pour la position donnée.
     */
    override fun createFragment(position: Int): Fragment {
        val deckName = deckNames[position]
        val cardsForDeck = decks[deckName] ?: emptyList()
        // Utilise la méthode factory du fragment pour lui passer la liste de cartes.
        return DeckPageFragment.newInstance(cardsForDeck)
    }

    /**
     * Retourne le titre du deck pour l'onglet à la position donnée.
     */
    fun getPageTitle(position: Int): CharSequence {
        return deckNames[position]
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckPagerAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerActivity.kt ---

package be.heyman.android.ai.kikko.deck

import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.view.View
import android.view.WindowInsets
import android.view.WindowInsetsController
import android.widget.LinearLayout
import android.widget.Toast
import android.widget.VideoView
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.quiz.QuizActivity
import kotlinx.coroutines.launch

class DeckViewerActivity : AppCompatActivity(), CardDetailsDialogFragment.CardDetailsListener {

    private val viewModel: DeckViewerViewModel by lazy {
        ViewModelProvider(this, ViewModelProvider.AndroidViewModelFactory(application))
            .get(DeckViewerViewModel::class.java)
    }

    private lateinit var backgroundVideoView: VideoView
    private lateinit var recyclerView: RecyclerView
    private lateinit var deckCardAdapter: DeckCardAdapter

    private lateinit var deckButtonFood: LinearLayout
    private lateinit var deckButtonPlant: LinearLayout
    private lateinit var deckButtonInsect: LinearLayout
    private lateinit var deckButtonBird: LinearLayout
    private lateinit var deckButtons: Map<String, View>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_deck_viewer)
        hideSystemUI()

        bindViews()
        setupBackgroundVideo()
        setupRecyclerView()
        setupDeckSelectionListeners()
        observeViewModel()
    }

    override fun onResume() {
        super.onResume()
        backgroundVideoView.start()
    }

    override fun onPause() {
        super.onPause()
        backgroundVideoView.stopPlayback()
    }

    private fun hideSystemUI() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            window.insetsController?.let {
                it.hide(WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars())
                it.systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
            }
        } else {
            @Suppress("DEPRECATION")
            window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    or View.SYSTEM_UI_FLAG_FULLSCREEN)
        }
    }

    private fun bindViews() {
        backgroundVideoView = findViewById(R.id.background_video_view)
        recyclerView = findViewById(R.id.deck_cards_recyclerview)
        deckButtonFood = findViewById(R.id.deck_button_food)
        deckButtonPlant = findViewById(R.id.deck_button_plant)
        deckButtonInsect = findViewById(R.id.deck_button_insect)
        deckButtonBird = findViewById(R.id.deck_button_bird)

        deckButtons = mapOf(
            GameConstants.MASTER_DECK_LIST[0] to deckButtonFood,
            GameConstants.MASTER_DECK_LIST[1] to deckButtonPlant,
            GameConstants.MASTER_DECK_LIST[2] to deckButtonInsect,
            GameConstants.MASTER_DECK_LIST[3] to deckButtonBird
        )
    }

    private fun setupBackgroundVideo() {
        val videoPath = "android.resource://" + packageName + "/" + R.raw.kikko_deck
        val uri = Uri.parse(videoPath)
        backgroundVideoView.setVideoURI(uri)
        backgroundVideoView.setOnPreparedListener { mediaPlayer ->
            mediaPlayer.isLooping = true
            mediaPlayer.setVolume(0f, 0f)
            mediaPlayer.start()
        }
    }

    private fun setupRecyclerView() {
        deckCardAdapter = DeckCardAdapter(emptyList()) { card ->
            CardDetailsDialogFragment.newInstance(card).show(supportFragmentManager, "CardDetailsDialog")
        }
        recyclerView.apply {
            layoutManager = GridLayoutManager(this@DeckViewerActivity, 3)
            adapter = deckCardAdapter
        }
    }

    private fun setupDeckSelectionListeners() {
        deckButtons.forEach { (deckName, buttonView) ->
            buttonView.setOnClickListener {
                viewModel.selectDeck(deckName)
            }
        }
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    if (state.isLoading) {
                        // Optionnel : Gérer l'état de chargement
                    } else {
                        deckCardAdapter.updateCards(state.filteredCards)
                        updateSelectedDeckButton(state.selectedDeck)
                    }
                }
            }
        }
    }

    private fun updateSelectedDeckButton(selectedDeckName: String) {
        deckButtons.forEach { (deckName, buttonView) ->
            if (deckName == selectedDeckName) {
                buttonView.setBackgroundColor(ContextCompat.getColor(this, R.color.kikko_gold_light))
                buttonView.alpha = 1.0f
            } else {
                buttonView.setBackgroundColor(ContextCompat.getColor(this, android.R.color.transparent))
                buttonView.alpha = 0.7f
            }
        }
    }

    override fun onDeleteCard(card: KnowledgeCard) {
        viewModel.deleteCard(card)
        Toast.makeText(this, getString(R.string.card_deleted_toast, card.specificName), Toast.LENGTH_SHORT).show()
    }

    override fun onLaunchQuiz(card: KnowledgeCard) {
        val intent = QuizActivity.newIntent(this, card)
        startActivity(intent)
    }

    override fun onTranslateCard(card: KnowledgeCard) {
        viewModel.requestTranslation(card)
        Toast.makeText(this, getString(R.string.translation_requested_toast, card.specificName), Toast.LENGTH_LONG).show()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerViewModel.kt ---

package be.heyman.android.ai.kikko.deck

import android.app.Application
import android.content.Context
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.Constraints
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import be.heyman.android.ai.kikko.worker.ForgeWorker
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

data class DeckUiState(
    val isLoading: Boolean = true,
    val allCards: Map<String, List<KnowledgeCard>> = emptyMap(),
    val selectedDeck: String = GameConstants.MASTER_DECK_LIST.first(),
    val filteredCards: List<KnowledgeCard> = emptyList()
)

class DeckViewerViewModel(application: Application) : AndroidViewModel(application) {

    private val cardDao: CardDao = (application as KikkoApplication).cardDao
    private val pollenGrainDao: PollenGrainDao = (application as KikkoApplication).pollenGrainDao
    private val workManager = WorkManager.getInstance(application)

    private val _uiState = MutableStateFlow(DeckUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadAllDecks()
    }

    fun selectDeck(deckName: String) {
        _uiState.update { currentState ->
            currentState.copy(
                selectedDeck = deckName,
                filteredCards = currentState.allCards[deckName] ?: emptyList()
            )
        }
    }

    fun deleteCard(card: KnowledgeCard) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                cardDao.delete(card)
            }
            loadAllDecks()
        }
    }

    fun requestTranslation(card: KnowledgeCard) {
        viewModelScope.launch(Dispatchers.IO) {
            val pollenGrain = pollenGrainDao.findByForgedCardId(card.id)
            if (pollenGrain != null) {
                Log.i("DeckViewerViewModel", "PollenGrain trouvé pour la carte ${card.id}. Statut mis à PENDING_TRANSLATION.")
                pollenGrainDao.updateStatus(pollenGrain.id, PollenStatus.PENDING_TRANSLATION)
                launchForgeWorker()
            } else {
                Log.w("DeckViewerViewModel", "Aucun PollenGrain trouvé pour la carte ${card.id}. La traduction ne peut être lancée.")
            }
        }
    }

    private fun loadAllDecks() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val groupedDecks = withContext(Dispatchers.IO) {
                cardDao.getAll()
            }.groupBy { it.deckName }
            _uiState.update { currentState ->
                currentState.copy(
                    isLoading = false,
                    allCards = groupedDecks,
                    filteredCards = groupedDecks[currentState.selectedDeck] ?: emptyList()
                )
            }
        }
    }

    private fun launchForgeWorker() {
        Log.d("DeckViewerViewModel", "Lancement du ForgeWorker pour la traduction.")

        val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
        val requiresCharging = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_CHARGING, false)
        val requiresIdle = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_IDLE, false)

        val constraints = Constraints.Builder()
            .setRequiresCharging(requiresCharging)
            .setRequiresDeviceIdle(requiresIdle)
            .setRequiredNetworkType(NetworkType.CONNECTED) // La traduction nécessite le réseau
            .build()

        val forgeRequest = OneTimeWorkRequestBuilder<ForgeWorker>()
            .setConstraints(constraints)
            .build()

        workManager.beginUniqueWork(
            "PollenForgeChain",
            ExistingWorkPolicy.APPEND_OR_REPLACE,
            forgeRequest
        ).enqueue()

        Log.i("DeckViewerViewModel", "ForgeWorker mis en file d'attente pour la traduction.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/deck/DeckViewerViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/AnalysisResultAdapter.kt ---

package be.heyman.android.ai.kikko.forge

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.ModelConfiguration
import com.google.android.material.chip.Chip
import com.google.gson.Gson

// BOURDON'S FIX: La classe DiffCallback est maintenant définie AVANT l'adaptateur qui l'utilise.
class AnalysisResultDiffCallback : DiffUtil.ItemCallback<AnalysisResult>() {
    override fun areItemsTheSame(oldItem: AnalysisResult, newItem: AnalysisResult): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: AnalysisResult, newItem: AnalysisResult): Boolean {
        return oldItem.status == newItem.status &&
                oldItem.rawResponse == newItem.rawResponse &&
                oldItem.streamingResponse == newItem.streamingResponse &&
                oldItem.errorMessage == newItem.errorMessage
    }
}

class AnalysisResultAdapter(
    private val onRun: (AnalysisResult) -> Unit,
    private val onCancel: (AnalysisResult) -> Unit,
    private val onRetry: (AnalysisResult) -> Unit,
    private val onViewError: (AnalysisResult) -> Unit,
    private val onValidate: (AnalysisResult) -> Unit
) : ListAdapter<AnalysisResult, AnalysisResultAdapter.ViewHolder>(AnalysisResultDiffCallback()) {

    private val gson = Gson()
    private val expandedItemIds = mutableSetOf<String>()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_analysis_result, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val task = getItem(position)
        val isExpanded = expandedItemIds.contains(task.id)
        holder.bind(task, isExpanded) {
            if (expandedItemIds.contains(task.id)) {
                expandedItemIds.remove(task.id)
            } else {
                expandedItemIds.add(task.id)
            }
            notifyItemChanged(position)
        }
    }

    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val analysisModelConfig: TextView = view.findViewById(R.id.analysis_model_config)
        val analysisStatusChip: Chip = view.findViewById(R.id.analysis_status_chip)
        val analysisRawResponse: TextView = view.findViewById(R.id.analysis_raw_response)
        val analysisErrorMessage: TextView = view.findViewById(R.id.analysis_error_message)
        val analysisRunButton: Button = view.findViewById(R.id.analysis_run_button)
        val analysisPauseButton: Button = view.findViewById(R.id.analysis_pause_button)
        val analysisCancelButton: Button = view.findViewById(R.id.analysis_cancel_button)
        val analysisRetryButton: Button = view.findViewById(R.id.analysis_retry_button)
        val analysisViewErrorButton: Button = view.findViewById(R.id.analysis_view_error_button)
        val analysisValidateButton: Button = view.findViewById(R.id.analysis_validate_button)

        val headerContainer: View = view.findViewById(R.id.analysis_header_container)
        val detailsContainer: View = view.findViewById(R.id.analysis_details_container)


        fun bind(task: AnalysisResult, isManuallyExpanded: Boolean, onHeaderClick: () -> Unit) {
            analysisStatusChip.text = task.status.name

            val title = when {
                task.status == AnalysisStatus.COMPLETED -> generateTitleFromResponse(task)
                else -> {
                    val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
                    "${config.modelName.replace(".task", "")} (${config.accelerator}, T:${config.temperature})"
                }
            }
            analysisModelConfig.text = title

            if (task.status == AnalysisStatus.RUNNING || isManuallyExpanded) {
                detailsContainer.visibility = View.VISIBLE
            } else {
                detailsContainer.visibility = View.GONE
            }
            headerContainer.setOnClickListener { onHeaderClick() }

            val showResponseText = when (task.status) {
                AnalysisStatus.RUNNING -> task.streamingResponse
                AnalysisStatus.COMPLETED -> task.rawResponse
                else -> null
            }

            if (!showResponseText.isNullOrEmpty()) {
                analysisRawResponse.visibility = View.VISIBLE
                analysisRawResponse.text = showResponseText
            } else {
                analysisRawResponse.visibility = View.GONE
            }

            analysisErrorMessage.visibility = if (task.status == AnalysisStatus.FAILED && task.errorMessage != null) {
                analysisErrorMessage.text = task.errorMessage
                View.VISIBLE
            } else {
                View.GONE
            }

            when (task.status) {
                AnalysisStatus.PENDING, AnalysisStatus.PAUSED, AnalysisStatus.CANCELLED -> showActions(run = true)
                AnalysisStatus.RUNNING -> showActions(pause = true, cancel = true)
                AnalysisStatus.FAILED -> showActions(viewError = true, retry = true)
                AnalysisStatus.COMPLETED -> {
                    showActions(validate = true)
                }
            }

            analysisRunButton.setOnClickListener { onRun(task) }
            analysisCancelButton.setOnClickListener { onCancel(task) }
            analysisRetryButton.setOnClickListener { onRetry(task) }
            analysisViewErrorButton.setOnClickListener { onViewError(task) }
            analysisValidateButton.setOnClickListener { onValidate(task) }
        }

        private fun generateTitleFromResponse(task: AnalysisResult): String {
            val rawResponse = task.rawResponse ?: return "Analyse terminée"
            val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
            val modelNickname = config.modelName.take(15)

            return when (task.propertyName) {
                "identification" -> {
                    try {
                        data class IdentificationTitle(val specificName: String?, val deckName: String?)
                        val cleanJson = rawResponse.substringAfter("{").substringBeforeLast("}")
                        val result = gson.fromJson("{$cleanJson}", IdentificationTitle::class.java)
                        if (!result.specificName.isNullOrBlank() && !result.deckName.isNullOrBlank()) {
                            "✅ ${result.deckName}: ${result.specificName}"
                        } else { "⚠️ Résultat partiel" }
                    } catch (e: Exception) {
                        val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
                        val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
                        if (name != null && deck != null) "✅ $deck: $name (via Regex)" else "⚠️ Résultat non-structuré"
                    }
                }
                "description" -> "✅ Description générée par $modelNickname"
                else -> "✅ Terminé - $modelNickname"
            }
        }

        private fun showActions(run: Boolean = false, pause: Boolean = false, cancel: Boolean = false, retry: Boolean = false, viewError: Boolean = false, validate: Boolean = false) {
            analysisRunButton.visibility = if (run) View.VISIBLE else View.GONE
            analysisPauseButton.visibility = if (pause) View.VISIBLE else View.GONE
            analysisCancelButton.visibility = if (cancel) View.VISIBLE else View.GONE
            analysisRetryButton.visibility = if (retry) View.VISIBLE else View.GONE
            analysisViewErrorButton.visibility = if (viewError) View.VISIBLE else View.GONE
            analysisValidateButton.visibility = if (validate) View.VISIBLE else View.GONE
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/AnalysisResultAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeLlmHelper.kt ---

package be.heyman.android.ai.kikko.forge

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import be.heyman.android.ai.kikko.data.Accelerator
import be.heyman.android.ai.kikko.data.MAX_IMAGE_COUNT
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.ModelConfiguration
import com.google.mediapipe.framework.image.BitmapImageBuilder
import com.google.mediapipe.tasks.genai.llminference.GraphOptions
import com.google.mediapipe.tasks.genai.llminference.LlmInference
import com.google.mediapipe.tasks.genai.llminference.LlmInferenceSession
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.resume

private const val TAG = "ForgeLlmHelper"

class ForgeLlmHelper(
    val context: Context,
) {
    private var llmInference: LlmInference? = null
    private var session: LlmInferenceSession? = null
    private var currentSessionTemperature: Float? = null
    private var currentSessionTopK: Int? = null
    private var currentSessionIsMultimodal: Boolean = false


    fun initialize(model: Model, accelerator: String, isMultimodal: Boolean): String? {
        cleanUp()
        return try {
            Log.d(TAG, "Initialisation LLM avec modèle: ${model.name}, accélérateur: $accelerator, multimodal: $isMultimodal")
            val optionsBuilder = LlmInference.LlmInferenceOptions.builder()
                .setModelPath(model.url)
                .setMaxTokens(4096)
                .setPreferredBackend(
                    if (accelerator == Accelerator.GPU.label) LlmInference.Backend.GPU
                    else LlmInference.Backend.CPU
                )
                .setMaxNumImages(if (isMultimodal && model.llmSupportImage) MAX_IMAGE_COUNT else 0)

            val options = optionsBuilder.build()
            llmInference = LlmInference.createFromOptions(context, options)
            // Ne pas créer de session par défaut. Elle sera créée à la demande.
            null
        } catch (e: Exception) {
            cleanUpMediapipeTaskErrorMessage(e.message ?: "Unknown error during initialization")
        }
    }

    private fun createNewSession(llmInference: LlmInference, temperature: Float, topK: Int, isMultimodal: Boolean): LlmInferenceSession? {
        return try {
            Log.d(TAG, "Création d'une nouvelle session avec température: $temperature, topK: $topK, multimodal: $isMultimodal")
            currentSessionTemperature = temperature
            currentSessionTopK = topK
            currentSessionIsMultimodal = isMultimodal
            val sessionOptionsBuilder = LlmInferenceSession.LlmInferenceSessionOptions.builder()
                .setTemperature(temperature)
                .setTopK(topK)
            sessionOptionsBuilder.setGraphOptions(
                GraphOptions.builder()
                    .setEnableVisionModality(isMultimodal)
                    .build()
            )
            LlmInferenceSession.createFromOptions(llmInference, sessionOptionsBuilder.build())
        } catch (e: Exception) {
            Log.e(TAG, "Failed to create new session", e)
            null
        }
    }

    fun resetSession(model: Model, isMultimodal: Boolean, temperature: Float = 0.2f, topK: Int = 40) {
        try {
            if (session != null && currentSessionTemperature == temperature && currentSessionTopK == topK && currentSessionIsMultimodal == isMultimodal) {
                Log.d(TAG, "Session déjà configurée avec les mêmes paramètres. Réutilisation.")
                return
            }
            Log.d(TAG, "Réinitialisation de la session pour modèle '${model.name}' avec temp: $temperature, topK: $topK, multimodal: $isMultimodal")
            session?.close()
            val inferenceEngine = llmInference ?: run {
                Log.e(TAG, "Cannot reset session, LlmInference engine is null.")
                initialize(model, Accelerator.GPU.label, isMultimodal)
                llmInference ?: return
            }
            session = createNewSession(inferenceEngine, temperature, topK, isMultimodal)
            if (session == null) {
                throw IllegalStateException("Failed to create LlmInferenceSession after reset.")
            }
            Log.d(TAG, "Session réinitialisée avec succès.")
        } catch(e: Exception) {
            Log.e(TAG, "Failed to reset session for '${model.name}': ${e.message}")
            cleanUp()
        }
    }

    private fun ensureSession(config: ModelConfiguration, isMultimodal: Boolean) {
        val inferenceEngine = llmInference ?: throw IllegalStateException("LlmInference engine not initialized.")
        if (session == null || currentSessionTemperature != config.temperature || currentSessionTopK != config.topK || currentSessionIsMultimodal != isMultimodal) {
            Log.d(TAG, "Configuration de session invalide ou inexistante. Création d'une nouvelle session.")
            session?.close()
            session = createNewSession(inferenceEngine, config.temperature, config.topK, isMultimodal)
                ?: throw IllegalStateException("Failed to create new LlmInferenceSession.")
        }
    }

    fun runInference(
        prompt: String,
        images: List<Bitmap>,
        resultListener: (partialResult: String, done: Boolean) -> Unit
    ) {
        val currentSession = session ?: run {
            resultListener("Erreur: Session non initialisée.", true)
            return
        }
        Log.d(TAG, "--- PROMPT ENVOYÉ À LA REINE ---\n$prompt")
        try {
            if (prompt.trim().isNotEmpty()) {
                currentSession.addQueryChunk(prompt)
            }
            if (images.isNotEmpty()) {
                for (image in images) {
                    val mpImage = BitmapImageBuilder(image).build()
                    currentSession.addImage(mpImage)
                }
            }
            currentSession.generateResponseAsync(resultListener)
        } catch (e: Exception) {
            Log.e(TAG, "Erreur durant l'inférence dans la Forge", e)
            resultListener(cleanUpMediapipeTaskErrorMessage(e.message ?: "Error during inference"), true)
        }
    }

    // BOURDON'S FIX: Restauration de la méthode pour les Workers
    suspend fun inferenceWithCoroutineAndConfig(prompt: String, images: List<Bitmap>, config: ModelConfiguration): String {
        ensureSession(config, images.isNotEmpty())
        return suspendCancellableCoroutine { continuation ->
            val responseBuilder = StringBuilder()
            runInference(prompt, images) { partialResult, done ->
                responseBuilder.append(partialResult)
                if (done) {
                    if (continuation.isActive) {
                        continuation.resume(responseBuilder.toString())
                    }
                }
            }
        }
    }

    fun runInferenceWithConfig(
        prompt: String,
        images: List<Bitmap>,
        config: ModelConfiguration,
        resultListener: (partialResult: String, done: Boolean) -> Unit
    ) {
        ensureSession(config, images.isNotEmpty())
        runInference(prompt, images, resultListener)
    }

    fun cleanUp() {
        session?.close()
        llmInference?.close()
        session = null
        llmInference = null
        currentSessionTemperature = null
        currentSessionTopK = null
        currentSessionIsMultimodal = false
    }
}

private fun cleanUpMediapipeTaskErrorMessage(message: String): String {
    val index = message.indexOf("=== Source Location Trace")
    if (index >= 0) {
        return message.substring(0, index).trim()
    }
    return message.trim()
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeLlmHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeMlKitHelper.kt ---

package be.heyman.android.ai.kikko.forge

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import be.heyman.android.ai.kikko.model.ImageAnalysisReport
import be.heyman.android.ai.kikko.model.OcrResult
import be.heyman.android.ai.kikko.model.SimpleDetectedObject
import be.heyman.android.ai.kikko.model.SimpleImageLabel
import be.heyman.android.ai.kikko.model.SwarmAnalysisResult
import com.google.android.gms.tasks.Tasks
import com.google.mlkit.common.model.LocalModel
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.label.ImageLabel
import com.google.mlkit.vision.label.ImageLabeler
import com.google.mlkit.vision.label.ImageLabeling
import com.google.mlkit.vision.label.custom.CustomImageLabelerOptions
import com.google.mlkit.vision.label.defaults.ImageLabelerOptions
import com.google.mlkit.vision.objects.DetectedObject
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.Closeable

/**
 * Helper pour orchestrer les analyses ML Kit sur une ou plusieurs images pour la Forge.
 * Déplacé depuis le package `debug` car c'est une fonctionnalité essentielle pour la Forge.
 * En tant qu'objet singleton, il n'a pas besoin d'injection Hilt pour son propre fonctionnement.
 */
object ForgeMlKitHelper {
    private const val TAG = "ForgeMlKitHelper"

    const val OCR = "ocr"
    const val OBJECT_DETECTION = "object_detection"
    const val DEFAULT_LABELING = "default_labeling"
    const val BIRDS_CLASSIFIER = "birds_classifier"
    const val INSECTS_CLASSIFIER = "insects_classifier"
    const val PLANTS_CLASSIFIER = "plants_classifier"
    const val FOOD_CLASSIFIER = "food_classifier"
    const val MOBILENET_V1 = "mobilenet_v1"
    const val EFFICIENTNET_LITE0 = "efficientnet_lite0"
    const val EFFICIENTNET_LITE1 = "efficientnet_lite1"
    const val EFFICIENTNET_LITE2 = "efficientnet_lite2"
    const val DEEP_OBJECT_ANALYSIS = "deep_object_analysis"

    /**
     * Exécute une analyse ML Kit complexe sur une liste de bitmaps.
     * Cette fonction agrège les résultats de plusieurs détecteurs/classifieurs.
     *
     * @param context Contexte de l'application.
     * @param images La liste des bitmaps à analyser.
     * @param enabledModels Une map des modèles à activer (ex: "ocr" -> true).
     * @param onResult Callback pour le résultat agrégé de l'essaim.
     */
    fun runAnalysis(
        context: Context, // Contexte nécessaire pour créer les clients ML Kit
        images: List<Bitmap>,
        enabledModels: Map<String, Boolean>,
        onResult: (SwarmAnalysisResult) -> Unit
    ) {
        Log.d(TAG, "Lancement de l'analyse de l'essaim pour ${images.size} images. Modèles activés: ${enabledModels.filter { it.value }.keys}")
        CoroutineScope(Dispatchers.Default).launch {
            val imageReports = mutableListOf<ImageAnalysisReport>()

            images.forEachIndexed { index, bitmap ->
                Log.d(TAG, "Analyse de l'image ${index + 1}/${images.size} de l'essaim...")
                val report = processSingleImage(context, bitmap, enabledModels)
                imageReports.add(report)
            }

            val swarmResult = SwarmAnalysisResult(reports = imageReports)
            Log.i(TAG, "Analyse complète de l'essaim terminée.")

            withContext(Dispatchers.Main) {
                onResult(swarmResult)
            }
        }
    }

    private suspend fun processSingleImage(context: Context, bitmap: Bitmap, enabledModels: Map<String, Boolean>): ImageAnalysisReport {
        Log.d(TAG, "Traitement d'une seule image...")
        val clientsToClose = mutableListOf<Closeable>()
        var detectedObjects = emptyList<SimpleDetectedObject>()
        val classifierResults = mutableMapOf<String, List<SimpleImageLabel>>()
        var ocrText = ""

        try {
            val image = InputImage.fromBitmap(bitmap, 0)
            val tasks = mutableListOf<com.google.android.gms.tasks.Task<*>>()
            val taskNames = mutableListOf<String>()

            if (enabledModels[OCR] == true) {
                Log.d(TAG, "Ajout de la tâche OCR à l'essaim.")
                // Le contexte est passé à la méthode `getClient`
                val recognizer = TextRecognition.getClient(JapaneseTextRecognizerOptions.Builder().build())
                clientsToClose.add(recognizer)
                tasks.add(recognizer.process(image))
                taskNames.add(OCR)
            }
            if (enabledModels[OBJECT_DETECTION] == true) {
                Log.d(TAG, "Ajout de la tâche de Détection d'Objets à l'essaim.")
                val options = ObjectDetectorOptions.Builder().setDetectorMode(ObjectDetectorOptions.SINGLE_IMAGE_MODE).enableMultipleObjects().enableClassification().build()
                // Le contexte est passé à la méthode `getClient`
                val detector = ObjectDetection.getClient(options)
                clientsToClose.add(detector)
                tasks.add(detector.process(image))
                taskNames.add(OBJECT_DETECTION)
            }
            if (enabledModels[DEFAULT_LABELING] == true) {
                Log.d(TAG, "Ajout de la tâche de Labellisation par Défaut à l'essaim.")
                // Le contexte est passé à la méthode `getClient`
                val labeler = ImageLabeling.getClient(ImageLabelerOptions.DEFAULT_OPTIONS)
                clientsToClose.add(labeler)
                tasks.add(labeler.process(image))
                taskNames.add("Labels (Défaut)")
            }

            // Les fonctions `addCustomClassifierTask` prennent déjà le contexte.
            addCustomClassifierTask(context, enabledModels, BIRDS_CLASSIFIER, "aiy-tflite-vision-classifier-birds-v1-v3.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, INSECTS_CLASSIFIER, "aiy-tflite-vision-classifier-insects-v1-v3.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, PLANTS_CLASSIFIER, "aiy-tflite-vision-classifier-plants-v1-v3.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, FOOD_CLASSIFIER, "aiy-tflite-vision-classifier-food-v1-v1.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, MOBILENET_V1, "mobilenet_v1_1.0_224_quantized_1_metadata_1.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, EFFICIENTNET_LITE0, "efficientnet_lite0.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, EFFICIENTNET_LITE1, "efficientnet_lite1_int8_2.tflite", image, tasks, taskNames, clientsToClose)
            addCustomClassifierTask(context, enabledModels, EFFICIENTNET_LITE2, "efficientnet_lite2_int8_2.tflite", image, tasks, taskNames, clientsToClose)


            if (tasks.isNotEmpty()) {
                val results = Tasks.await(Tasks.whenAllSuccess<Any>(tasks))
                Log.i(TAG, "${results.size} tâches ML Kit terminées avec succès.")

                results.forEachIndexed { index, result ->
                    val taskName = taskNames[index]
                    when (result) {
                        is Text -> ocrText = result.text
                        is List<*> -> {
                            if (result.all { it is DetectedObject }) {
                                detectedObjects = (result as List<DetectedObject>).map { obj ->
                                    SimpleDetectedObject(labels = obj.labels.map { SimpleImageLabel(it.text, it.confidence) })
                                }
                            } else if (result.all { it is ImageLabel }) {
                                classifierResults[taskName] = (result as List<ImageLabel>).map { SimpleImageLabel(it.text, it.confidence) }
                            }
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "L'une des tâches ML a échoué en mode complexe", e)
        } finally {
            Log.d(TAG, "Nettoyage de ${clientsToClose.size} clients ML Kit.")
            clientsToClose.forEach { it.close() }
        }

        // BOURDON'S FIX: On encapsule le String OCR dans l'objet OcrResult attendu par le modèle de données.
        return ImageAnalysisReport(detectedObjects, classifierResults, OcrResult(fullText = ocrText))
    }

    private fun addCustomClassifierTask(
        context: Context, // Contexte ajouté ici pour créer les clients
        enabledModels: Map<String, Boolean>,
        modelKey: String,
        assetPath: String,
        image: InputImage,
        tasks: MutableList<com.google.android.gms.tasks.Task<*>>,
        taskNames: MutableList<String>,
        clientsToClose: MutableList<Closeable>
    ) {
        if (enabledModels[modelKey] == true) {
            Log.d(TAG, "Ajout de la tâche du classifieur personnalisé '$modelKey' à l'essaim.")
            val localModel = LocalModel.Builder().setAssetFilePath(assetPath).build()
            val options = CustomImageLabelerOptions.Builder(localModel).setConfidenceThreshold(0.1f).build()
            // Le contexte est passé à la méthode `getClient`
            val labeler = ImageLabeling.getClient(options)
            clientsToClose.add(labeler)
            tasks.add(labeler.process(image))
            taskNames.add(modelKey.replace("_classifier", "").replaceFirstChar { it.titlecase() })
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeMlKitHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgePromptGenerator.kt ---

package be.heyman.android.ai.kikko.forge

import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.prompt.PromptManager
import com.google.gson.Gson
import java.util.Locale

object ForgePromptGenerator {

    // BOURDON'S ADDITION: Un GSON local pour la sérialisation des propositions.
    private val gson = Gson()

    /**
     * BOURDON'S FINAL REFACTOR: Le générateur récupère le prompt brut (maintenant en dur
     * dans le PromptManager) et effectue lui-même le formatage.
     */
    fun generateIdentificationTournamentPrompt(swarmReportJson: String): String {
        val rawPrompt = PromptManager.getPrompt("forge_identification")
        // Note: Le '$' dans %1$s est crucial pour éviter les ambiguïtés de formatage.
        return String.format(rawPrompt, swarmReportJson)
    }

    /**
     * BOURDON'S FINAL REFACTOR: La logique de formatage est de retour dans le générateur.
     */
    fun generatePropertyForgePrompt(
        propertyName: String,
        deckName: String,
        specificName: String,
        swarmReportJson: String,
        existingDescription: String?,
        dependencyDataJson: String? = null
    ): String {

        if (propertyName == "description") {
            // NOTE: Ceci est un prompt qui a été abandonné, mais je le garde pour la compatibilité.
            // Le système de forge actuel n'utilise plus ce chemin.
            val rawPrompt = PromptManager.getPrompt("forge_description_multimodal")
            return String.format(
                rawPrompt,
                specificName,
                deckName,
                swarmReportJson
            )
        }

        // NOTE: Ce prompt est également obsolète et n'est plus appelé par le worker monolithique.
        val rawPrompt = PromptManager.getPrompt("forge_property_base")
        val formattedDescription = if (existingDescription != null) "\n[NATIVE DESCRIPTION]:\n$existingDescription" else ""
        val formattedDependency = if (dependencyDataJson != null) "\n[DEPENDENCY DATA (PREVIOUSLY FORGED)]:\n$dependencyDataJson" else ""

        return String.format(
            rawPrompt,
            deckName,
            specificName,
            propertyName,
            swarmReportJson,
            formattedDescription,
            formattedDependency
        )
    }

    /**
     * BOURDON'S ADDITION: La nouvelle méthode pour forger le prompt de l'Arbitre.
     * Elle prend les résultats d'un tournoi, les sérialise en JSON et les injecte dans le
     * prompt 'forge_judgment_arbiter'.
     *
     * @param propertyName Le nom de la propriété jugée (ex: "description").
     * @param proposals La liste des tâches 'AnalysisResult' terminées à soumettre à l'Arbitre.
     * @return Le prompt complet et formaté pour l'inférence de l'Arbitre.
     */
    fun generateJudgmentPrompt(propertyName: String, proposals: List<AnalysisResult>): String {
        val rawPrompt = PromptManager.getPrompt("forge_judgment_arbiter")
        val proposalsJson = gson.toJson(proposals)
        return String.format(rawPrompt, propertyName, proposalsJson)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgePromptGenerator.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeRepository.kt ---

package be.heyman.android.ai.kikko.forge

import android.util.Log
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.AnalysisResultDao
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository pour le flux de travail de la Forge.
 * Agit comme une façade pour les différents DAOs liés au processus de forge.
 * C'est la seule source de vérité pour le ForgeWorkshopViewModel.
 */
@Singleton
class ForgeRepository @Inject constructor(
    private val pollenGrainDao: PollenGrainDao,
    private val cardDao: CardDao,
    private val analysisResultDao: AnalysisResultDao
) {
    private val gson = Gson()
    private val stringListType = object : TypeToken<List<String>>() {}.type

    /**
     * Récupère tous les grains de pollen qui ne sont pas encore complètement forgés.
     */
    suspend fun getGrainsForWorkshop(): List<PollenGrain> {
        // Retourne tous les grains sauf ceux qui sont FORGED ou en ERROR.
        val allGrains = pollenGrainDao.getByStatus(PollenStatus.RAW) +
                pollenGrainDao.getByStatus(PollenStatus.IDENTIFYING) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_DESCRIPTION) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_STATS) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_QUIZ) +
                pollenGrainDao.getByStatus(PollenStatus.PENDING_TRANSLATION)
        return allGrains.distinctBy { it.id }.sortedByDescending { it.timestamp }
    }

    /**
     * Récupère la KnowledgeCard associée à un PollenGrain.
     */
    suspend fun getCardForGrain(grain: PollenGrain): KnowledgeCard? {
        return grain.forgedCardId?.let { cardDao.getCardById(it) }
    }

    /**
     * Récupère tous les résultats d'analyse pour une propriété spécifique d'un grain.
     */
    suspend fun getAnalysisResults(pollenGrainId: String, propertyName: String): List<AnalysisResult> {
        return analysisResultDao.getByPollenGrainIdAndProperty(pollenGrainId, propertyName)
    }

    /**
     * BOURDON'S FIX: Nouvelle méthode pour insérer une seule tâche.
     * C'est une correction nécessaire pour la logique du ViewModel.
     */
    suspend fun insertAnalysisResult(result: AnalysisResult) {
        analysisResultDao.insert(result)
    }


    /**
     * Crée et insère dans la base de données les tâches d'analyse pour un "tournoi".
     * @return La liste des tâches créées.
     */
    suspend fun createAnalysisTasksForProperty(pollenGrainId: String, propertyName: String, models: List<String>, accelerator: String): List<AnalysisResult> {
        val tasks = mutableListOf<AnalysisResult>()
        // BOURDON'S FIX: Le décret de 2 configurations par Reine est appliqué ici.
        val configs = listOf(
            Pair(0.2f, 40), // Factuel
            Pair(0.9f, 80)  // Créatif
        )

        models.forEach { modelName ->
            configs.forEach { (temp, topK) ->
                val modelConfig = ModelConfiguration(modelName, accelerator, temp, topK)
                val task = AnalysisResult(
                    pollenGrainId = pollenGrainId,
                    propertyName = propertyName,
                    modelConfigJson = gson.toJson(modelConfig),
                    status = AnalysisStatus.PENDING
                )
                analysisResultDao.insert(task)
                tasks.add(task)
            }
        }
        return tasks
    }

    /**
     * BOURDON'S FIX: Nouvelle méthode pour purger les résultats d'une compétition avant de la relancer.
     */
    suspend fun clearAnalysisResultsForProperty(pollenGrainId: String, propertyName: String) {
        analysisResultDao.deleteByPollenGrainIdAndProperty(pollenGrainId, propertyName)
    }

    /**
     * Met à jour une tâche d'analyse (typiquement après son exécution).
     */
    suspend fun updateAnalysisResult(result: AnalysisResult) {
        analysisResultDao.update(result)
    }

    /**
     * Met à jour le statut d'un grain de pollen.
     */
    suspend fun updatePollenStatus(pollenGrainId: String, newStatus: PollenStatus) {
        pollenGrainDao.updateStatus(pollenGrainId, newStatus)
    }

    /**
     * Met à jour une propriété spécifique de la carte de connaissance.
     * Cette fonction est complète et gère les différents types de propriétés.
     */
    suspend fun updateCardProperty(cardId: Long, propertyName: String, value: String) {
        val card = cardDao.getCardById(cardId) ?: return

        val updatedCard = when {
            propertyName == "description" -> card.copy(description = value)
            propertyName == "biological.scientificName" -> card.copy(scientificName = value)
            propertyName == "biological.vernacularName" -> card.copy(vernacularName = value)
            propertyName == "ingredients" -> card.copy(ingredients = gson.fromJson(value, stringListType))
            propertyName == "allergens" -> card.copy(allergens = gson.fromJson(value, stringListType))
            propertyName.startsWith("stats.") -> {
                val statKey = propertyName.substringAfter("stats.")
                val newStatsItems = card.stats?.items?.toMutableMap() ?: mutableMapOf()
                newStatsItems[statKey] = value
                card.copy(stats = CardStats(title = "Statistics", items = newStatsItems))
            }
            else -> {
                Log.w("ForgeRepository", "Tentative de mise à jour d'une propriété inconnue: '$propertyName'")
                card // Ne rien faire si la propriété est inconnue
            }
        }

        if (updatedCard != card) {
            cardDao.update(updatedCard)
        }
    }

    /**
     * BOURDON'S FIX: Nouvelle fonction pour orchestrer une suppression complète.
     * Supprime le grain, sa carte associée, ses fichiers images et ses résultats d'analyse (via cascade).
     */
    suspend fun deletePollenGrainAndAssociatedData(grain: PollenGrain) {
        // 1. Supprimer la carte associée, si elle existe.
        grain.forgedCardId?.let { cardId ->
            cardDao.getCardById(cardId)?.let { card ->
                cardDao.delete(card)
                Log.d("ForgeRepository", "Carte associée (ID: $cardId) supprimée.")
            }
        }

        // 2. Supprimer les fichiers image physiques.
        grain.pollenImagePaths.forEach { path ->
            try {
                val file = File(path)
                if (file.exists()) {
                    if (file.delete()) {
                        Log.d("ForgeRepository", "Fichier image supprimé : $path")
                    } else {
                        Log.w("ForgeRepository", "Échec de la suppression du fichier image : $path")
                    }
                }
            } catch (e: Exception) {
                Log.e("ForgeRepository", "Erreur lors de la suppression du fichier image : $path", e)
            }
        }

        // 3. Supprimer le grain de pollen.
        // La suppression en cascade dans la DB s'occupera des AnalysisResults.
        pollenGrainDao.delete(grain)
        Log.d("ForgeRepository", "Grain de pollen (ID: ${grain.id}) et ses données associées supprimés.")
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeRepository.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---

package be.heyman.android.ai.kikko.forge

import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.content.ContextCompat
import androidx.core.view.isVisible
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.PollenStatus
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.card.MaterialCardView
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import kotlinx.coroutines.launch
import java.io.File

class ForgeWorkshopActivity : AppCompatActivity() {

    private val viewModel: ForgeWorkshopViewModel by viewModels {
        ViewModelProvider.AndroidViewModelFactory.getInstance(application)
    }

    private val TAG = "ForgeWorkshopActivity"

    // Vues statiques
    private lateinit var statusMessage: TextView
    private lateinit var progressBar: ProgressBar
    private lateinit var pollenGrainsRecyclerView: RecyclerView
    private lateinit var workshopContent: View
    private lateinit var grainIdLabel: TextView
    private lateinit var workshopSelectedImage: ImageView
    private lateinit var workshopSelectedName: TextView
    private lateinit var workshopSelectedDeck: TextView
    private lateinit var propertiesContainer: LinearLayout
    private lateinit var workshopDeleteGrainButton: Button
    private lateinit var filterRawButton: LinearLayout
    private lateinit var filterFoodButton: LinearLayout
    private lateinit var filterPlantButton: LinearLayout
    private lateinit var filterInsectButton: LinearLayout
    private lateinit var filterBirdButton: LinearLayout
    private lateinit var filterButtons: Map<String, View>

    // Adaptateurs et état de l'UI
    private lateinit var grainAdapter: PollenGrainAdapter
    private val propertyAdapters = mutableMapOf<String, AnalysisResultAdapter>()
    private val expandedPropertySections = mutableSetOf<String>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_forge_workshop)
        Log.d(TAG, "[CYCLE DE VIE] onCreate: Initialisation de l'Atelier.")

        bindViews()
        setupStaticAdapters()
        setupStaticListeners()
        observeUiState()
    }

    private fun bindViews() {
        Log.d(TAG, "Liaison des vues de l'Atelier...")
        statusMessage = findViewById(R.id.workshop_status_message)
        progressBar = findViewById(R.id.workshop_progress_bar)
        pollenGrainsRecyclerView = findViewById(R.id.workshop_grains_recyclerview)
        workshopContent = findViewById(R.id.workshop_detail_container)
        grainIdLabel = findViewById(R.id.grain_id_label)
        workshopSelectedImage = findViewById(R.id.workshop_selected_image)
        workshopSelectedName = findViewById(R.id.workshop_selected_name)
        workshopSelectedDeck = findViewById(R.id.workshop_selected_deck)
        propertiesContainer = findViewById(R.id.workshop_properties_container)
        workshopDeleteGrainButton = findViewById(R.id.workshop_delete_grain_button)
        filterRawButton = findViewById(R.id.filter_button_raw)
        filterFoodButton = findViewById(R.id.filter_button_food)
        filterPlantButton = findViewById(R.id.filter_button_plant)
        filterInsectButton = findViewById(R.id.filter_button_insect)
        filterBirdButton = findViewById(R.id.filter_button_bird)
        filterButtons = mapOf(
            ForgeWorkshopViewModel.FILTER_RAW to filterRawButton,
            GameConstants.MASTER_DECK_LIST[0] to filterFoodButton,
            GameConstants.MASTER_DECK_LIST[1] to filterPlantButton,
            GameConstants.MASTER_DECK_LIST[2] to filterInsectButton,
            GameConstants.MASTER_DECK_LIST[3] to filterBirdButton
        )
        Log.d(TAG, "Toutes les vues ont été liées avec succès.")
    }

    private fun setupStaticAdapters() {
        grainAdapter = PollenGrainAdapter(emptyList(), null) { grain ->
            viewModel.selectGrain(grain)
        }
        pollenGrainsRecyclerView.layoutManager =
            LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)
        pollenGrainsRecyclerView.adapter = grainAdapter
    }

    private fun setupStaticListeners() {
        Log.d(TAG, "Configuration des listeners statiques.")
        workshopDeleteGrainButton.setOnClickListener {
            Log.d(TAG, "Bouton de suppression du grain cliqué.")
            MaterialAlertDialogBuilder(this)
                .setTitle(R.string.workshop_delete_grain_dialog_title)
                .setMessage(R.string.workshop_delete_grain_dialog_message)
                .setNegativeButton(R.string.dialog_cancel, null)
                .setPositiveButton(R.string.workshop_button_delete) { _, _ ->
                    Log.i(TAG, "Confirmation de la suppression. Appel au ViewModel.")
                    viewModel.deleteSelectedGrain()
                }
                .show()
        }
        filterButtons.forEach { (filterType, button) ->
            button.setOnClickListener {
                Log.d(TAG, "Bouton de filtre '$filterType' cliqué.")
                viewModel.setFilter(filterType)
            }
        }
    }

    private fun observeUiState() {
        lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                Log.v(TAG, "[UI UPDATE] Nouvel état UI. Filtre: ${state.activeFilter}, Jugement: ${state.judgmentState::class.simpleName}")
                progressBar.isVisible = state.isLoading
                statusMessage.text = state.statusMessage

                grainAdapter.updateGrainsAndSelection(state.workshopGrains, state.selectedGrain?.id)

                if (state.selectedGrain != null) {
                    workshopContent.isVisible = true
                    grainIdLabel.text = getString(R.string.workshop_grain_id_format, state.selectedGrain.id.substring(0, 8))

                    if (state.selectedCard != null) {
                        workshopSelectedName.text = state.selectedCard.specificName
                        workshopSelectedDeck.text = getString(R.string.workshop_deck_format, state.selectedCard.deckName)
                        state.selectedCard.imagePath?.let { path ->
                            File(path).takeIf { it.exists() }?.let { workshopSelectedImage.setImageBitmap(BitmapFactory.decodeFile(it.absolutePath)) }
                                ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                        } ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                    } else {
                        workshopSelectedName.text = getString(R.string.workshop_raw_pollen_title)
                        workshopSelectedDeck.text = getString(R.string.workshop_deck_unknown)
                        state.selectedGrain.pollenImagePaths.firstOrNull()?.let { path ->
                            File(path).takeIf { it.exists() }?.let { workshopSelectedImage.setImageBitmap(BitmapFactory.decodeFile(it.absolutePath)) }
                                ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                        } ?: workshopSelectedImage.setImageResource(R.drawable.ic_placeholder_card)
                    }

                    populatePropertiesContainer(state)

                } else {
                    workshopContent.isVisible = false
                }

                state.analysisResults.forEach { (propertyName, results) ->
                    propertyAdapters[propertyName]?.submitList(results)
                }

                updateFilterButtonsVisualState(state.activeFilter)
                handleJudgmentState(state.judgmentState)
            }
        }
    }

    private fun handleJudgmentState(judgmentState: JudgmentState) {
        val existingDialog = supportFragmentManager.findFragmentByTag(JudgmentDialogFragment.TAG) as? JudgmentDialogFragment
        if (judgmentState is JudgmentState.None) {
            existingDialog?.dismiss()
            return
        }
        if (existingDialog == null) {
            JudgmentDialogFragment.newInstance().show(supportFragmentManager, JudgmentDialogFragment.TAG)
        }
    }

    private fun updateFilterButtonsVisualState(activeFilter: String) {
        val activeColor = ContextCompat.getColor(this, R.color.kikko_gold_light)
        val inactiveColor = ContextCompat.getColor(this, android.R.color.transparent)
        filterButtons.forEach { (filterType, buttonView) ->
            if (filterType == activeFilter) {
                buttonView.setBackgroundColor(activeColor)
                buttonView.alpha = 1.0f
            } else {
                buttonView.setBackgroundColor(inactiveColor)
                buttonView.alpha = 0.7f
            }
        }
    }

    private fun populatePropertiesContainer(state: ForgeWorkshopUiState) {
        propertiesContainer.removeAllViews()
        propertyAdapters.clear()
        val grain = state.selectedGrain ?: return
        val card = state.selectedCard
        val isAwaitingValidation = grain.status == PollenStatus.AWAITING_VALIDATION || grain.status == PollenStatus.IDENTIFYING || grain.status == PollenStatus.RAW

        addPropertySection("identification", state, isAwaitingValidation)

        if(card != null && card.deckName != "Unknown") {
            val properties = viewModel.getPropertiesForDeck(card.deckName)
            properties.forEach { propertyName ->
                addPropertySection(propertyName, state, isAwaitingValidation)
            }
        }
    }

    private fun addPropertySection(propertyName: String, state: ForgeWorkshopUiState, isAwaitingValidation: Boolean) {
        val view = LayoutInflater.from(this).inflate(R.layout.item_property_refinement, propertiesContainer, false)

        val headerView = view.findViewById<ConstraintLayout>(R.id.property_refinement_header)
        val titleView = view.findViewById<TextView>(R.id.property_refinement_title)
        val resultCountView = view.findViewById<TextView>(R.id.property_refinement_result_count)
        val expandIcon = view.findViewById<ImageView>(R.id.property_refinement_expand_icon)
        val contentContainer = view.findViewById<LinearLayout>(R.id.property_refinement_content)
        val launchButton = view.findViewById<Button>(R.id.property_refinement_launch_button)
        val judgmentButton = view.findViewById<Button>(R.id.property_refinement_launch_judgment_button)
        val recyclerView = view.findViewById<RecyclerView>(R.id.property_refinement_results_recyclerview)
        val summaryCard = view.findViewById<MaterialCardView>(R.id.property_refinement_summary_card)
        val summaryContainer = view.findViewById<LinearLayout>(R.id.property_refinement_summary_container)

        titleView.text = getTitleForProperty(propertyName)
        val isExpanded = expandedPropertySections.contains(propertyName)
        contentContainer.isVisible = isExpanded
        expandIcon.rotation = if (isExpanded) 180f else 0f
        val allResults = state.analysisResults[propertyName] ?: emptyList()
        val completedResultsCount = allResults.count { it.status == AnalysisStatus.COMPLETED }
        resultCountView.text = if (completedResultsCount > 0) getString(R.string.workshop_results_count, completedResultsCount) else ""
        resultCountView.isVisible = completedResultsCount > 0

        headerView.setOnClickListener {
            if (expandedPropertySections.contains(propertyName)) {
                expandedPropertySections.remove(propertyName)
                contentContainer.isVisible = false
                expandIcon.animate().rotation(0f).start()
            } else {
                expandedPropertySections.add(propertyName)
                contentContainer.isVisible = true
                expandIcon.animate().rotation(180f).start()
            }
        }

        // --- BOURDON'S REFACTORED INTELLIGENT BUTTON LOGIC (v2) ---
        var isLaunchButtonEnabled = true
        var disabledReasonResId: Int? = null
        if (isAwaitingValidation && propertyName != "identification") {
            isLaunchButtonEnabled = false; disabledReasonResId = R.string.workshop_validate_identification_first
        } else if (propertyName == "allergens" && state.selectedCard?.ingredients == null) {
            isLaunchButtonEnabled = false; disabledReasonResId = R.string.workshop_forge_ingredients_first
        }

        val isCompetitionRunning = allResults.any { it.status == AnalysisStatus.PENDING || it.status == AnalysisStatus.RUNNING }
        val hasCompletedResults = allResults.any { it.status == AnalysisStatus.COMPLETED }

        if (isCompetitionRunning) {
            launchButton.setText(R.string.workshop_competition_in_progress)
            isLaunchButtonEnabled = false
        } else if (allResults.isEmpty()) {
            launchButton.setText(R.string.workshop_launch_competition)
            launchButton.setOnClickListener { viewModel.createAnalysisTournament(propertyName) }
        } else {
            launchButton.setText(R.string.workshop_relaunch_competition)
            launchButton.setOnClickListener {
                MaterialAlertDialogBuilder(this)
                    .setTitle(R.string.dialog_relaunch_title).setMessage(R.string.dialog_relaunch_message)
                    .setNegativeButton(R.string.dialog_cancel, null)
                    .setPositiveButton(R.string.dialog_relaunch_confirm) { _, _ -> viewModel.relaunchAnalysisTournament(propertyName) }
                    .show()
            }
        }

        if (disabledReasonResId != null) launchButton.text = getString(disabledReasonResId)
        launchButton.isEnabled = isLaunchButtonEnabled

        // BOURDON'S CRITICAL FIX: Le bouton de jugement apparaît dès qu'il y a au moins un résultat.
        judgmentButton.isVisible = hasCompletedResults && isLaunchButtonEnabled
        judgmentButton.setOnClickListener {
            viewModel.launchFinalJudgment(propertyName)
        }
        // --- END OF REFACTORED LOGIC ---

        val summary = state.competitionSummaries[propertyName]
        if (summary != null && summary.items.isNotEmpty()) {
            summaryCard.isVisible = true
            summaryContainer.removeAllViews()
            summary.items.forEach { summaryItem ->
                val summaryItemView = LayoutInflater.from(this).inflate(R.layout.item_competition_summary, summaryContainer, false)
                val summaryTextView = summaryItemView.findViewById<TextView>(R.id.summary_response_text)
                val summaryValidateButton = summaryItemView.findViewById<Button>(R.id.summary_validate_button)
                summaryTextView.text = getString(R.string.workshop_summary_proposal_format, summaryItem.voteCount, summaryItem.response)
                summaryValidateButton.setOnClickListener { viewModel.validateFromSummary(summaryItem) }
                summaryContainer.addView(summaryItemView)
            }
        } else {
            summaryCard.isVisible = false
        }

        val adapter = AnalysisResultAdapter(
            onRun = { viewModel.runAnalysisTask(it) },
            onCancel = { viewModel.cancelAnalysisTask(it) },
            onRetry = { viewModel.retryAnalysisTask(it) },
            onViewError = { task -> showErrorDialog(task.errorMessage ?: getString(R.string.error_unknown)) },
            onValidate = { task ->
                if (task.propertyName == "identification") viewModel.validateAndCreateCardFromIdentification(task)
                else viewModel.validateProperty(task)
            }
        )
        recyclerView.layoutManager = LinearLayoutManager(this)
        recyclerView.adapter = adapter
        propertyAdapters[propertyName] = adapter
        propertiesContainer.addView(view)
    }

    private fun getTitleForProperty(propertyName: String): String {
        val propertyTitleResId = when (propertyName) {
            "identification" -> R.string.property_title_identification
            "description" -> R.string.property_title_description
            "ingredients" -> R.string.property_title_ingredients
            "allergens" -> R.string.property_title_allergens
            "stats.energy" -> R.string.property_title_energy
            "biological.scientificName" -> R.string.property_title_scientific_name
            "biological.vernacularName" -> R.string.property_title_vernacular_name
            "stats.floweringPeriod" -> R.string.property_title_flowering
            "stats.diet" -> R.string.property_title_diet
            "stats.wingspan" -> R.string.property_title_wingspan
            else -> 0
        }
        return if (propertyTitleResId != 0) {
            getString(R.string.workshop_refinement_title_format, getString(propertyTitleResId))
        } else {
            getString(R.string.workshop_refinement_title_format, propertyName.replaceFirstChar { it.titlecase() })
        }
    }

    private fun showErrorDialog(message: String) {
        MaterialAlertDialogBuilder(this)
            .setTitle(R.string.dialog_error_details_title)
            .setMessage(message)
            .setPositiveButton(R.string.dialog_ok, null)
            .show()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---
package be.heyman.android.ai.kikko.forge

import android.app.Application
import android.content.Context
import android.graphics.BitmapFactory
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.concurrent.CancellationException
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

// BOURDON'S ADDITION: Data classes pour le résumé de la compétition
data class CompetitionSummaryItem(
    val response: String,
    val voteCount: Int,
    val firstValidTask: AnalysisResult // On garde une tâche source pour la validation
)

data class CompetitionSummary(
    val propertyName: String,
    val items: List<CompetitionSummaryItem>
)

// BOURDON'S ADDITION: Machine d'états pour le processus de Jugement Final.
sealed class JudgmentState {
    data object None : JudgmentState()
    data class InProgress(val propertyName: String, val prompt: String, val streamingResponse: String = "") : JudgmentState()
    data class Complete(val propertyName: String, val arbiterReasoning: String, val winningProposal: AnalysisResult) : JudgmentState()
    data class Failed(val propertyName: String, val error: String) : JudgmentState()
}

data class ForgeWorkshopUiState(
    val isLoading: Boolean = true,
    val workshopGrains: List<PollenGrain> = emptyList(),
    val selectedGrain: PollenGrain? = null,
    val selectedCard: KnowledgeCard? = null,
    val analysisResults: Map<String, List<AnalysisResult>> = emptyMap(),
    val competitionSummaries: Map<String, CompetitionSummary> = emptyMap(),
    val judgmentState: JudgmentState = JudgmentState.None, // BOURDON'S ADDITION: Le nouvel état de jugement.
    val statusMessage: String? = null,
    val activeFilter: String = ForgeWorkshopViewModel.FILTER_RAW
)

class ForgeWorkshopViewModel(application: Application) : AndroidViewModel(application) {

    private val forgeRepository: ForgeRepository = (application as KikkoApplication).forgeRepository
    private val llmHelper: ForgeLlmHelper = (application as KikkoApplication).forgeLlmHelper
    private val pollenGrainDao: PollenGrainDao = (application as KikkoApplication).pollenGrainDao

    private val TAG = "KikkoForgeTrace"
    private val _uiState = MutableStateFlow(ForgeWorkshopUiState())
    val uiState = _uiState.asStateFlow()
    private val gson = Gson()

    private var competitionJob: Job? = null
    private var judgmentJob: Job? = null

    private var allWorkshopItems = listOf<Pair<PollenGrain, KnowledgeCard?>>()

    private val deckProperties = mapOf(
        "Food" to listOf("description", "ingredients", "allergens", "stats.energy"),
        "Plant" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.floweringPeriod"),
        "Insect" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.diet"),
        "Bird" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.wingspan")
    )

    private data class IdentificationResultData(
        val reasoning: Reasoning,
        val deckName: String,
        val specificName: String,
        val confidence: Float
    )

    companion object {
        const val FILTER_ALL = "ALL"
        const val FILTER_RAW = "RAW"
    }

    init {
        Log.d(TAG, "ViewModel initialisé. Lancement du chargement initial des grains de pollen.")
        viewModelScope.launch {
            _uiState.update { it.copy(statusMessage = getString(R.string.workshop_loading_grains)) }
            loadWorkshopGrains()
        }
    }

    fun getPropertiesForDeck(deckName: String?): List<String> {
        val normalizedDeckName = deckName
            ?.trim()
            ?.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
            ?.removeSuffix("s")
        val properties = deckProperties[normalizedDeckName] ?: emptyList()
        return properties
    }


    fun selectGrain(grain: PollenGrain) {
        viewModelScope.launch {
            competitionJob?.cancel()
            judgmentJob?.cancel()
            Log.i(TAG, "[SELECT] Sélection du grain ID: ${grain.id} | Statut: ${grain.status} | CardID lié: ${grain.forgedCardId}")

            val card = allWorkshopItems.find { it.first.id == grain.id }?.second

            val newStatusMessage = if (grain.status == PollenStatus.AWAITING_VALIDATION || grain.status == PollenStatus.IDENTIFYING) {
                getString(R.string.workshop_awaiting_validation)
            } else {
                getString(R.string.workshop_ready_to_refine)
            }

            _uiState.update { it.copy(
                selectedGrain = grain,
                selectedCard = card,
                analysisResults = emptyMap(),
                competitionSummaries = emptyMap(),
                judgmentState = JudgmentState.None,
                statusMessage = newStatusMessage
            ) }

            if (card != null) {
                Log.d(TAG, "[SELECT] Carte chargée depuis la cache - ID: ${card.id}, Nom: '${card.specificName}', Deck: '${card.deckName}'")
            } else {
                Log.w(TAG, "[SELECT] Aucune carte n'a pu être chargée pour ce grain.")
            }

            refreshAnalysisResults(grain.id, "identification")
            if (card?.deckName != "Unknown") {
                val properties = getPropertiesForDeck(card?.deckName)
                properties.forEach { propertyName ->
                    refreshAnalysisResults(grain.id, propertyName)
                }
            }
        }
    }

    fun setFilter(filterType: String) {
        viewModelScope.launch {
            if (_uiState.value.activeFilter == filterType) return@launch
            _uiState.update { it.copy(activeFilter = filterType) }
            updateFilteredGrains()
        }
    }

    private fun updateFilteredGrains() {
        val currentFilter = _uiState.value.activeFilter
        Log.d(TAG, "[FILTER] Application du filtre: $currentFilter")

        val filteredItems = when (currentFilter) {
            FILTER_RAW -> allWorkshopItems.filter { (grain, _) ->
                grain.status == PollenStatus.RAW ||
                        grain.status == PollenStatus.IDENTIFYING ||
                        grain.status == PollenStatus.AWAITING_VALIDATION ||
                        grain.status == PollenStatus.ERROR
            }
            else -> allWorkshopItems.filter { (_, card) -> card?.deckName == currentFilter }
        }

        val filteredGrains = filteredItems.map { it.first }
        _uiState.update { it.copy(workshopGrains = filteredGrains) }

        val selectedGrainStillVisible = filteredGrains.any { it.id == _uiState.value.selectedGrain?.id }
        if (!selectedGrainStillVisible) {
            val newGrainToSelect = filteredGrains.firstOrNull()
            if (newGrainToSelect != null) {
                selectGrain(newGrainToSelect)
            } else {
                _uiState.update { it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_in_deck)) }
            }
        }
    }


    fun createAnalysisTournament(propertyName: String) {
        val grain = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_preparing_competition, propertyName)) }

            val modelsToCompete = withContext(Dispatchers.IO) {
                val modelsDir = File(getApplication<Application>().filesDir, "imported_models")
                if (modelsDir.exists() && modelsDir.isDirectory) {
                    modelsDir.listFiles { _, name -> name.endsWith(".task") }?.map { it.name } ?: emptyList()
                } else {
                    emptyList()
                }
            }

            if (modelsToCompete.isEmpty()) {
                _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_no_queens_installed)) }
                return@launch
            }
            Log.i(TAG, "[COMPETITION] Reines en compétition: ${modelsToCompete.joinToString()}")

            val accelerator = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                .getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU") ?: "GPU"

            val tasks = forgeRepository.createAnalysisTasksForProperty(grain.id, propertyName, modelsToCompete, accelerator)
            Log.i(TAG, "[COMPETITION] Création de ${tasks.size} tâches pour la propriété '$propertyName'.")

            refreshAnalysisResults(grain.id, propertyName)
            val message = getApplication<Application>().resources.getQuantityString(R.plurals.workshop_tasks_ready, tasks.size, tasks.size)
            _uiState.update { it.copy(isLoading = false, statusMessage = message) }

            launchCompetitionExecution(propertyName)
        }
    }

    fun relaunchAnalysisTournament(propertyName: String) {
        val grain = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, statusMessage = "Clearing old results for '$propertyName'...") }
            forgeRepository.clearAnalysisResultsForProperty(grain.id, propertyName)
            refreshAnalysisResults(grain.id, propertyName)
            createAnalysisTournament(propertyName)
        }
    }


    fun validateFromSummary(summaryItem: CompetitionSummaryItem) {
        Log.i(TAG, "[VALIDATE-SUMMARY] Validation demandée pour la réponse '${summaryItem.response}' avec ${summaryItem.voteCount} votes.")
        validateProperty(summaryItem.firstValidTask)
    }

    fun validateAndCreateCardFromIdentification(task: AnalysisResult) {
        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch

            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_identification)) }
            }

            try {
                var resultData = parseIntelligentJson<IdentificationResultData>(rawResponse)

                if (resultData == null) {
                    val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
                    val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value

                    if (name != null && deck != null) {
                        resultData = IdentificationResultData(
                            specificName = name, deckName = deck,
                            reasoning = Reasoning(getString(R.string.fallback_reasoning_visual), getString(R.string.fallback_reasoning_correlation)),
                            confidence = 0.5f
                        )
                    } else {
                        throw IOException(getString(R.string.error_validation_parsing_failed))
                    }
                }

                var cardId = grain.forgedCardId
                if (cardId == null) {
                    val newCard = KnowledgeCard(
                        specificName = resultData.specificName, deckName = resultData.deckName,
                        imagePath = grain.pollenImagePaths.firstOrNull(), confidence = resultData.confidence,
                        reasoning = resultData.reasoning, description = null, stats = null, quiz = null, translations = null,
                        scientificName = null, vernacularName = null, allergens = null, ingredients = null
                    )
                    cardId = (getApplication<Application>().applicationContext as KikkoApplication).cardDao.insert(newCard)
                    pollenGrainDao.updateForgingResult(grain.id, grain.status, cardId)
                } else {
                    (getApplication<Application>().applicationContext as KikkoApplication).cardDao.updateIdentification(
                        cardId = cardId, specificName = resultData.specificName, deckName = resultData.deckName,
                        reasoning = resultData.reasoning, confidence = resultData.confidence
                    )
                }

                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_DESCRIPTION)

                withContext(Dispatchers.Main) {
                    loadWorkshopGrains()
                }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-ID] Échec critique du processus de validation.", e)
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message ?: getString(R.string.error_unknown))) }
                }
            }
        }
    }

    fun validateProperty(task: AnalysisResult) {
        if (task.propertyName == "identification") {
            validateAndCreateCardFromIdentification(task)
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val cardId = grain.forgedCardId ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch
            Log.i(TAG, "[VALIDATE-PROP] Validation de la propriété '${task.propertyName}' avec la réponse de la tâche ${task.id}.")


            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_property, task.propertyName)) }
            }

            try {
                val propertyJson = parseIntelligentJson<JsonObject>(rawResponse)
                    ?: throw IOException(getString(R.string.error_json_malformed))

                val valueElement = propertyJson.get(task.propertyName)
                    ?: throw IOException(getString(R.string.error_json_key_missing, task.propertyName))

                val valueAsString = if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)

                forgeRepository.updateCardProperty(cardId, task.propertyName, valueAsString)

                val nextStatus = getNextStatus(grain.status)
                pollenGrainDao.updateStatus(grain.id, nextStatus)

                withContext(Dispatchers.Main) {
                    loadWorkshopGrains()
                }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-PROP] Échec de la validation pour la propriété '${task.propertyName}'.", e)
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message ?: getString(R.string.error_unknown))) }
                }
            }
        }
    }

    private fun getNextStatus(currentStatus: PollenStatus): PollenStatus {
        return when (currentStatus) {
            PollenStatus.PENDING_DESCRIPTION -> PollenStatus.PENDING_STATS
            PollenStatus.PENDING_STATS -> PollenStatus.PENDING_QUIZ
            PollenStatus.PENDING_QUIZ -> PollenStatus.PENDING_TRANSLATION
            PollenStatus.PENDING_TRANSLATION -> PollenStatus.FORGED
            else -> currentStatus
        }
    }

    // BOURDON'S REFORGE V2: L'Orchestrateur Royal.
    private fun launchCompetitionExecution(propertyName: String, singleTaskToRun: AnalysisResult? = null) {
        competitionJob?.cancel()
        competitionJob = viewModelScope.launch(Dispatchers.IO) {
            val tasksToRun = singleTaskToRun?.let { listOf(it) }
                ?: _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.PENDING }
                ?: emptyList()

            if (tasksToRun.isEmpty()) {
                Log.w(TAG, "[ORCHESTRATOR] Lancement demandé pour '$propertyName', mais aucune tâche en attente trouvée.")
                return@launch
            }

            // Regrouper les tâches par Reine (nom du modèle).
            val tasksByQueen = tasksToRun.groupBy {
                gson.fromJson(it.modelConfigJson, ModelConfiguration::class.java).modelName
            }
            Log.i(TAG, "[ORCHESTRATOR] Lancement pour ${tasksToRun.size} tâches, réparties sur ${tasksByQueen.size} Reine(s).")

            for ((modelName, tasksForQueen) in tasksByQueen) {
                Log.i(TAG, "[ORCHESTRATOR] Convocation de la Reine '$modelName' pour ${tasksForQueen.size} tâche(s).")
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) {
                    Log.e(TAG, "[ORCHESTRATOR] Échec : Fichier de la Reine IA '$modelName' introuvable.")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Model file not found") }
                    continue // Passe à la Reine suivante
                }

                val isMultimodal = tasksForQueen.any { it.propertyName == "identification" || it.propertyName == "description" }
                val queenModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = modelName.contains("gemma-3n", ignoreCase = true))
                val accelerator = gson.fromJson(tasksForQueen.first().modelConfigJson, ModelConfiguration::class.java).accelerator

                val initError = llmHelper.initialize(queenModel, accelerator, isMultimodal)
                if (initError != null) {
                    Log.e(TAG, "[ORCHESTRATOR] Échec de l'initialisation de la Reine '$modelName': $initError")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Initialization failed: $initError") }
                    continue
                }

                try {
                    for (task in tasksForQueen) {
                        val success = runSingleTask(task)
                        if (!success) {
                            Log.w(TAG, "[ORCHESTRATOR] La tâche ${task.id.substring(0,4)} a échoué. La Reine '$modelName' continue avec la tâche suivante.")
                        }
                    }
                } finally {
                    Log.i(TAG, "[ORCHESTRATOR] La Reine '$modelName' a terminé son service. Nettoyage des ressources.")
                    llmHelper.cleanUp()
                }
            }
            Log.i(TAG, "[ORCHESTRATOR] Toutes les Reines ont terminé leur service pour la propriété '$propertyName'.")
        }
    }

    private suspend fun runSingleTask(task: AnalysisResult): Boolean {
        return try {
            withContext(Dispatchers.Main) { updateTaskStatusInUi(task.id, task.propertyName) { it.copy(status = AnalysisStatus.RUNNING, streamingResponse = "") } }

            val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
            val isMultimodalTask = task.propertyName == "identification" || task.propertyName == "description"
            val parentGrain = _uiState.value.selectedGrain ?: throw IllegalStateException("Parent pollen grain not found")
            val swarmReportJson = parentGrain.swarmAnalysisReportJson ?: throw IOException("Swarm report missing")
            val images = if (isMultimodalTask) parentGrain.pollenImagePaths.mapNotNull { BitmapFactory.decodeFile(it) } else emptyList()

            val prompt = when(task.propertyName) {
                "identification" -> ForgePromptGenerator.generateIdentificationTournamentPrompt(swarmReportJson)
                else -> {
                    val card = cardDao.getCardById(parentGrain.forgedCardId ?: -1) ?: throw IllegalStateException("Card not found for refinement")
                    // Note: La logique de dépendance (ex: allergènes) est simplifiée ici pour la clarté.
                    // Une implémentation complète la gérerait ici.
                    ForgePromptGenerator.generatePropertyForgePrompt(
                        propertyName = task.propertyName, deckName = card.deckName, specificName = card.specificName,
                        swarmReportJson = swarmReportJson, existingDescription = card.description, dependencyDataJson = null
                    )
                }
            }

            llmHelper.resetSession(Model(name=config.modelName, url="", downloadFileName="", sizeInBytes=0), isMultimodalTask, config.temperature, config.topK)

            val fullResponse = suspendCoroutine<String> { continuation ->
                val responseBuilder = StringBuilder()
                llmHelper.runInference(prompt, images) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    viewModelScope.launch(Dispatchers.Main) { updateTaskStatusInUi(task.id, task.propertyName) { it.copy(streamingResponse = responseBuilder.toString()) } }
                    if (done && continuation.isActive) continuation.resume(responseBuilder.toString())
                }
            }

            val updatedTask = task.copy(status = AnalysisStatus.COMPLETED, rawResponse = fullResponse, streamingResponse = null)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) { refreshAnalysisResults(task.pollenGrainId, task.propertyName) }
            true
        } catch (e: Exception) {
            if (e is CancellationException) {
                Log.i(TAG, "[TASK-CANCEL] Tâche ${task.id.substring(0,4)} annulée.")
                updateTaskStatusInDb(task.id, task.pollenGrainId, task.propertyName, AnalysisStatus.CANCELLED)
            } else {
                Log.e(TAG, "[TASK-FAIL] Échec Tâche ${task.id.substring(0,4)}", e)
                updateTaskStatusInDb(task.id, task.pollenGrainId, task.propertyName, AnalysisStatus.FAILED, e.message)
            }
            false
        }
    }

    fun launchFinalJudgment(propertyName: String) {
        judgmentJob?.cancel()
        val proposals = _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.COMPLETED }
        if (proposals.isNullOrEmpty()) {
            viewModelScope.launch { _uiState.update { it.copy(statusMessage = "Aucune proposition valide à juger.") } }
            return
        }

        judgmentJob = viewModelScope.launch(Dispatchers.IO) {
            val prompt = ForgePromptGenerator.generateJudgmentPrompt(propertyName, proposals)
            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(judgmentState = JudgmentState.InProgress(propertyName, prompt)) }
            }

            try {
                val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                val modelName = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null) ?: throw IOException("Aucune Reine sélectionnée pour être l'Arbitre.")
                val accelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) throw IOException("Fichier de la Reine Arbitre introuvable.")
                val arbiterModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0)
                val config = ModelConfiguration(modelName, accelerator, 0.1f, 1)

                val initError = llmHelper.initialize(arbiterModel, accelerator, false)
                if(initError != null) throw RuntimeException("Échec de l'initialisation de l'Arbitre: $initError")

                val responseBuilder = StringBuilder()
                llmHelper.runInferenceWithConfig(prompt, emptyList(), config) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    viewModelScope.launch(Dispatchers.Main) {
                        _uiState.update {
                            val currentState = it.judgmentState
                            if(currentState is JudgmentState.InProgress) {
                                it.copy(judgmentState = currentState.copy(streamingResponse = responseBuilder.toString()))
                            } else it
                        }
                    }

                    if (done) {
                        val arbiterResponse = parseArbiterResponse(responseBuilder.toString(), proposals)
                        viewModelScope.launch(Dispatchers.Main) {
                            if (arbiterResponse != null) {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Complete(propertyName, arbiterResponse.first, arbiterResponse.second)) }
                            } else {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, "Impossible de parser le verdict de l'Arbitre.")) }
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, e.message ?: "Erreur inconnue de l'Arbitre."))}
                }
            }
        }
    }

    private data class ArbiterVerdict(val arbiterReasoning: String, val bestProposal: JsonObject)

    private fun parseArbiterResponse(rawResponse: String, originalProposals: List<AnalysisResult>): Pair<String, AnalysisResult>? {
        Log.d(TAG, "[ARBITER-PARSE] Tentative de parsing du verdict de l'Arbitre.")
        val verdict = parseIntelligentJson<ArbiterVerdict>(rawResponse)
        if (verdict == null) {
            Log.e(TAG, "[ARBITER-PARSE] ÉCHEC. Le verdict de l'Arbitre est malformé ou vide.")
            return null
        }

        Log.d(TAG, "[ARBITER-PARSE] Verdict parsé avec succès. Recherche de la proposition gagnante...")
        val winningProposal = originalProposals.find {
            it.rawResponse?.let { originalRaw ->
                try {
                    val originalJsonObj = parseIntelligentJson<JsonObject>(originalRaw)
                    originalJsonObj != null && originalJsonObj == verdict.bestProposal
                } catch (e: Exception) {
                    false
                }
            } ?: false
        }

        return if (winningProposal != null) {
            Log.i(TAG, "[ARBITER-PARSE] SUCCÈS. Proposition gagnante trouvée (Tâche ID: ${winningProposal.id.substring(0,4)}).")
            Pair(verdict.arbiterReasoning, winningProposal)
        } else {
            Log.e(TAG, "[ARBITER-PARSE] ÉCHEC. Aucune proposition originale ne correspond au verdict de l'Arbitre.")
            null
        }
    }

    fun confirmJudgment() {
        val currentState = _uiState.value.judgmentState
        if (currentState is JudgmentState.Complete) {
            validateProperty(currentState.winningProposal)
            dismissJudgment()
        }
    }

    fun dismissJudgment() {
        _uiState.update { it.copy(judgmentState = JudgmentState.None) }
    }

    fun cancelCompetition(propertyName: String) {
        competitionJob?.cancel()
        Log.i(TAG, "[AUTO-FORGE] Compétition pour '$propertyName' annulée par l'utilisateur.")
    }

    fun retryAnalysisTask(task: AnalysisResult) {
        launchCompetitionExecution(task.propertyName, singleTaskToRun = task)
    }

    fun deleteSelectedGrain() {
        val grainToDelete = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                forgeRepository.deletePollenGrainAndAssociatedData(grainToDelete)
            }
            loadWorkshopGrains()
        }
    }

    private suspend fun updateTaskStatusInDb(taskId: String, grainId: String, propertyName: String, newStatus: AnalysisStatus, errorMessage: String? = null) {
        val currentTask = forgeRepository.getAnalysisResults(grainId, propertyName).find { it.id == taskId }
        if (currentTask != null) {
            val updatedTask = currentTask.copy(status = newStatus, errorMessage = errorMessage)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) {
                refreshAnalysisResults(grainId, propertyName)
            }
        }
    }

    private fun updateTaskStatusInUi(taskId: String, propertyName: String, updateAction: (AnalysisResult) -> AnalysisResult) {
        _uiState.update { currentState ->
            val newMap = currentState.analysisResults.toMutableMap()
            val propertyTasks = newMap[propertyName]?.toMutableList()
            val taskIndex = propertyTasks?.indexOfFirst { it.id == taskId }

            if (propertyTasks != null && taskIndex != null && taskIndex != -1) {
                propertyTasks[taskIndex] = updateAction(propertyTasks[taskIndex])
                newMap[propertyName] = propertyTasks
                currentState.copy(analysisResults = newMap)
            } else {
                currentState
            }
        }
    }

    private suspend fun loadWorkshopGrains() {
        _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_loading_grains)) }

        val grains = forgeRepository.getGrainsForWorkshop() + pollenGrainDao.getByStatus(PollenStatus.AWAITING_VALIDATION) + pollenGrainDao.getByStatus(PollenStatus.ERROR)
        val items = grains.distinctBy { it.id }.sortedByDescending { it.timestamp }.map { grain ->
            val card = forgeRepository.getCardForGrain(grain)
            Pair(grain, card)
        }
        allWorkshopItems = items

        _uiState.update { it.copy(isLoading = false) }
        updateFilteredGrains()

        val grainToSelect = _uiState.value.workshopGrains.firstOrNull()
        if (grainToSelect != null) {
            selectGrain(grainToSelect)
        } else {
            _uiState.update { it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_to_forge)) }
        }
    }

    private suspend fun refreshAnalysisResults(pollenGrainId: String, propertyName: String) {
        val results = forgeRepository.getAnalysisResults(pollenGrainId, propertyName)

        _uiState.update { currentState ->
            val newAnalysisMap = currentState.analysisResults.toMutableMap().apply { this[propertyName] = results }
            val newSummariesMap = currentState.competitionSummaries.toMutableMap()

            val hasCompletedTasks = results.any { it.status == AnalysisStatus.COMPLETED }
            if (hasCompletedTasks) {
                Log.d(TAG, "[SUMMARY] Au moins une tâche pour '$propertyName' est terminée. Calcul du résumé.")
                val summary = createCompetitionSummary(propertyName, results)
                if (summary.items.isNotEmpty()) {
                    newSummariesMap[propertyName] = summary
                } else {
                    newSummariesMap.remove(propertyName)
                }
            } else {
                newSummariesMap.remove(propertyName)
            }
            currentState.copy(analysisResults = newAnalysisMap, competitionSummaries = newSummariesMap)
        }
    }

    private fun createCompetitionSummary(propertyName: String, results: List<AnalysisResult>): CompetitionSummary {
        val completedTasks = results.filter { it.status == AnalysisStatus.COMPLETED && !it.rawResponse.isNullOrBlank() }
        if (completedTasks.isEmpty()) return CompetitionSummary(propertyName, emptyList())

        val responseGroups = completedTasks.groupBy { task ->
            extractValueFromResponse(task.rawResponse!!, propertyName)
        }.filterKeys { it.isNotBlank() }

        val summaryItems = responseGroups.map { (response, tasks) ->
            CompetitionSummaryItem(response = response, voteCount = tasks.size, firstValidTask = tasks.first())
        }.sortedByDescending { it.voteCount }
        Log.d(TAG, "[SUMMARY] Création du résumé pour '$propertyName': ${summaryItems.size} proposition(s) unique(s) trouvée(s).")
        return CompetitionSummary(propertyName, summaryItems)
    }

    private fun extractValueFromResponse(rawResponse: String, propertyName: String): String {
        try {
            val propertyJson = parseIntelligentJson<JsonObject>(rawResponse)
            if (propertyJson != null) {
                return when (propertyName) {
                    "identification" -> {
                        val name = propertyJson.get("specificName")?.asString ?: ""
                        val deck = propertyJson.get("deckName")?.asString ?: ""
                        if (name.isNotBlank() && deck.isNotBlank()) "$deck: $name" else ""
                    }
                    else -> {
                        val valueElement = propertyJson.get(propertyName)
                        if (valueElement != null) {
                            if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)
                        } else ""
                    }
                }
            }
        } catch (e: Exception) {
            Log.w(TAG, "[PARSER] Le parsing JSON a échoué pour '$propertyName', tentative de fallback. Erreur: ${e.message}")
        }

        if (propertyName == "identification") {
            val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
            val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
            if (name != null && deck != null) {
                Log.i(TAG, "[EXTRACT-REGEX] Fallback réussi pour identification: '$deck: $name'")
                return "$deck: $name"
            }
        }
        return ""
    }


    private inline fun <reified T> parseIntelligentJson(rawString: String): T? {
        val firstBrace = rawString.indexOf('{')
        if (firstBrace == -1) return null

        var braceCount = 0
        var lastBrace = -1
        for (i in firstBrace until rawString.length) {
            when (rawString[i]) {
                '{' -> braceCount++
                '}' -> braceCount--
            }
            if (braceCount == 0) {
                lastBrace = i
                break
            }
        }

        if (lastBrace == -1) return null
        val jsonSubstring = rawString.substring(firstBrace, lastBrace + 1)
        Log.d(TAG, "[PARSER] JSON isolé pour l'analyse: $jsonSubstring")

        return try {
            val type = object : TypeToken<T>() {}.type
            gson.fromJson(jsonSubstring, type)
        } catch (e: JsonSyntaxException) {
            Log.e(TAG, "[PARSER] Erreur de syntaxe Gson pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        } catch (e: Exception) {
            Log.e(TAG, "[PARSER] Erreur inattendue lors du parsing pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        }
    }

    private fun getString(resId: Int, vararg formatArgs: Any): String {
        return getApplication<Application>().getString(resId, *formatArgs)
    }

    override fun onCleared() {
        super.onCleared()
        competitionJob?.cancel()
        judgmentJob?.cancel()
        llmHelper.cleanUp()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/JudgmentDialogFragment.kt ---

package be.heyman.android.ai.kikko.forge

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.core.view.isVisible
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.AnalysisStatus
import com.google.android.material.card.MaterialCardView
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

class JudgmentDialogFragment : DialogFragment() {

    private val viewModel: ForgeWorkshopViewModel by activityViewModels()

    private lateinit var streamingResponseTextView: TextView
    private lateinit var promptContentTextView: TextView
    private lateinit var evidenceContentTextView: TextView
    private lateinit var confirmButton: Button
    private lateinit var overrideButton: Button
    // BOURDON'S ADDITION: Vues pour l'avertissement de sagesse.
    private lateinit var judgmentWarningCard: MaterialCardView
    private lateinit var judgmentWarningText: TextView


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NORMAL, R.style.Theme_Kikko_FullScreenDialog)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.dialog_judgment, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle(R.string.judgment_dialog_title)

        bindViews(view)
        setupListeners()
        observeViewModel()
    }

    private fun bindViews(view: View) {
        streamingResponseTextView = view.findViewById(R.id.judgment_streaming_response)
        promptContentTextView = view.findViewById(R.id.judgment_prompt_content)
        evidenceContentTextView = view.findViewById(R.id.judgment_evidence_content)
        confirmButton = view.findViewById(R.id.judgment_button_confirm)
        overrideButton = view.findViewById(R.id.judgment_button_override)
        // BOURDON'S ADDITION: Liaison des nouvelles vues.
        judgmentWarningCard = view.findViewById(R.id.judgment_warning_card)
        judgmentWarningText = view.findViewById(R.id.judgment_warning_text)
    }

    private fun setupListeners() {
        confirmButton.setOnClickListener {
            viewModel.confirmJudgment()
        }
        overrideButton.setOnClickListener {
            viewModel.dismissJudgment()
        }
    }

    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collectLatest { state ->
                when (val judgment = state.judgmentState) {
                    is JudgmentState.InProgress -> {
                        promptContentTextView.text = judgment.prompt
                        streamingResponseTextView.text = judgment.streamingResponse
                        evidenceContentTextView.text = "L'Arbitre délibère..."
                        confirmButton.isEnabled = false
                        overrideButton.text = getString(R.string.dialog_cancel)
                        checkCompetitionStatus(state, judgment.propertyName)
                    }
                    is JudgmentState.Complete -> {
                        val winningProposalText = "Proposition Gagnante (par ${judgment.winningProposal.modelConfigJson}):\n${judgment.winningProposal.rawResponse}"
                        streamingResponseTextView.text = "${judgment.arbiterReasoning}\n\n$winningProposalText"
                        confirmButton.isEnabled = true
                        overrideButton.text = getString(R.string.judgment_button_override)
                        checkCompetitionStatus(state, judgment.propertyName)
                    }
                    is JudgmentState.Failed -> {
                        streamingResponseTextView.text = "Erreur du Jugement : ${judgment.error}"
                        confirmButton.isEnabled = false
                        overrideButton.text = getString(R.string.dialog_cancel)
                        judgmentWarningCard.isVisible = false
                    }
                    JudgmentState.None -> {
                        // L'activité gère la fermeture.
                    }
                }
            }
        }
    }

    // BOURDON'S ADDITION: Nouvelle fonction pour afficher l'avertissement.
    private fun checkCompetitionStatus(state: ForgeWorkshopUiState, propertyName: String) {
        val allTasks = state.analysisResults[propertyName] ?: emptyList()
        if (allTasks.isEmpty()) {
            judgmentWarningCard.isVisible = false
            return
        }

        val totalTasks = allTasks.size
        val finishedTasks = allTasks.count { it.status in listOf(AnalysisStatus.COMPLETED, AnalysisStatus.FAILED, AnalysisStatus.CANCELLED) }

        if (finishedTasks < totalTasks) {
            judgmentWarningText.text = getString(R.string.judgment_warning_in_progress, finishedTasks, totalTasks)
            judgmentWarningCard.isVisible = true
        } else {
            judgmentWarningCard.isVisible = false
        }
    }

    companion object {
        const val TAG = "JudgmentDialogFragment"
        fun newInstance(): JudgmentDialogFragment {
            return JudgmentDialogFragment()
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/JudgmentDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenGrainAdapter.kt ---

package be.heyman.android.ai.kikko.forge

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.PollenGrain
import com.google.android.material.chip.Chip
import java.io.File

/**
 * Adaptateur pour afficher la liste horizontale des PollenGrains dans l'Atelier de la Forge.
 * Gère l'affichage de l'aperçu et l'état de sélection.
 */
class PollenGrainAdapter(
    private var grains: List<PollenGrain>,
    private var selectedCardId: String?,
    private val onClick: (PollenGrain) -> Unit
) : RecyclerView.Adapter<PollenGrainAdapter.ViewHolder>() {

    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.pollen_preview_image)
        val statusChip: Chip = view.findViewById(R.id.pollen_preview_status_chip)
        val nameTextView: TextView = view.findViewById(R.id.pollen_preview_name)
        val selectionBorder: View = view.findViewById(R.id.pollen_preview_selection_border)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_pollen_grain_preview, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val grain = grains[position]

        // Affiche le nom s'il existe, sinon l'ID court.
        holder.nameTextView.text = grain.forgedCardId?.toString() ?: "Pollen #${grain.id.substring(0, 4)}"
        holder.statusChip.text = grain.status.name

        // Affiche la première image du grain.
        grain.pollenImagePaths.firstOrNull()?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                holder.imageView.setImageBitmap(BitmapFactory.decodeFile(imgFile.absolutePath))
            } else {
                holder.imageView.setImageResource(R.drawable.ic_placeholder_card)
            }
        } ?: holder.imageView.setImageResource(R.drawable.ic_placeholder_card)

        // Gère la visibilité de la bordure de sélection.
        holder.selectionBorder.visibility = if (grain.id == selectedCardId) View.VISIBLE else View.GONE

        holder.itemView.setOnClickListener { onClick(grain) }
    }

    override fun getItemCount() = grains.size

    /**
     * Met à jour la liste des grains et l'ID de la sélection, puis rafraîchit l'affichage.
     */
    fun updateGrainsAndSelection(newGrains: List<PollenGrain>, newSelectedCardId: String?) {
        this.grains = newGrains
        this.selectedCardId = newSelectedCardId
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenGrainAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenPreviewAdapter.kt ---

package be.heyman.android.ai.kikko.forge

import android.graphics.Bitmap
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.ImageView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R

/**
 * Un adaptateur pour le RecyclerView qui affiche une prévisualisation horizontale
 * des images (pollen) sélectionnées par l'utilisateur.
 *
 * @param pollenImages La liste mutable des bitmaps à afficher.
 * @param onRemoveClick Une fonction lambda appelée lorsqu'un utilisateur clique sur le bouton de suppression
 * d'une image, passant l'index de l'image à supprimer.
 */
class PollenPreviewAdapter(
    private val pollenImages: MutableList<Bitmap>,
    private val onRemoveClick: (Int) -> Unit
) : RecyclerView.Adapter<PollenPreviewAdapter.PollenViewHolder>() {

    /**
     * ViewHolder qui contient les vues pour un seul item de prévisualisation de pollen.
     */
    inner class PollenViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.pollen_preview_imageview)
       /* val removeButton//: ImageButton = view.findViewById(R.id.pollen_remove_button)

        init {
            removeButton.setOnClickListener {
                // S'assure que la position est valide avant de déclencher le callback
                val position = adapterPosition
                if (position != RecyclerView.NO_POSITION) {
                    onRemoveClick(position)
                }
            }
        }

        */
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PollenViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_pollen_preview, parent, false)
        return PollenViewHolder(view)
    }

    override fun onBindViewHolder(holder: PollenViewHolder, position: Int) {
        val bitmap = pollenImages[position]
        holder.imageView.setImageBitmap(bitmap)
    }

    override fun getItemCount(): Int = pollenImages.size

    /**
     * Met à jour la liste des images affichées par l'adaptateur.
     * @param newImages La nouvelle liste de bitmaps.
     */
    fun updateImages(newImages: List<Bitmap>) {
        pollenImages.clear()
        pollenImages.addAll(newImages)
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PollenPreviewAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PromptGenerator.kt ---

package be.heyman.android.ai.kikko.forge

import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.QuizQuestion
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.model.TranslatedContent
import be.heyman.android.ai.kikko.prompt.PromptManager
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.IOException
import java.util.Locale

/**
 * BOURDON'S REFORGE (v4.0): Ce générateur est maintenant un HÉRAUT.
 * Il ne crée plus de prompts lui-même, mais récupère les décrets officiels du
 * PromptManager et les formate avec les données spécifiques à la mission.
 * L'ancien code de génération de prompt a été supprimé et remplacé par des
 * appels à String.format.
 */
object PromptGenerator {

    // --- LOGIQUE SPÉCIFIQUE À LA FORGE (NE SONT PAS DES PROMPTS) ---

    // Stats attendues par deck pour le prompt de génération de stats.
    private val deckStats = mapOf(
        "Bird" to listOf("Wingspan (cm)", "Average Weight (g)", "Lifespan (years)", "Clutch Size (eggs)"),
        "Insect" to listOf("Average Length (mm)", "Lifespan (days)", "Number of Legs", "Flying Speed (km/h)"),
        "Plant" to listOf("Maximum Height (m)", "Flowering Period (months)", "Lifespan (years)", "Minimum Temperature (°C)"),
        "Food" to listOf("Energy (kcal per 100g)", "Protein (g per 100g)")
    )

    // Liste des allergènes majeurs pour le prompt de génération de stats.
    private val majorAllergensList = listOf(
        "Cereals containing gluten", "Crustaceans", "Eggs", "Fish", "Peanuts",
        "Soybeans", "Milk", "Nuts", "Celery", "Mustard", "Sesame seeds",
        "Sulphur dioxide and sulphites", "Lupin", "Molluscs"
    )
    // --- FIN DE LA LOGIQUE SPÉCIFIQUE ---


    fun generateIdentificationPrompt(swarmReportJson: String): String {
        val rawPrompt = PromptManager.getPrompt("forge_identification")
        return String.format(rawPrompt, swarmReportJson)
    }

    fun generateNarrationDescriptionPrompt(subject: String, deckName: String, locale: Locale): String {
        val rawPrompt = PromptManager.getPrompt("forge_description")
        val languageName = when (locale.language) {
            "fr" -> "French"
            "ja" -> "Japanese"
            else -> "English"
        }
        val lowerSubject = subject.lowercase(locale)
        return String.format(rawPrompt, deckName, lowerSubject, languageName)
    }

    fun generateStatsExtractionPrompt(specificName: String, deckName: String, ocrText: String, description: String): String {
        val statsToFind = deckStats[deckName]
        if (statsToFind == null && deckName != "Food") return "" // Pas de stats pour les decks non-Food/non-biologiques définis
        val statsString = statsToFind?.joinToString(", ") ?: ""
        val lowerSpecificName = specificName.lowercase(Locale.getDefault())

        val allergenContext = if (deckName == "Food") {
            """
            Additionally, you MUST identify all allergens from the `[ALLERGEN_LIST]`.
            [ALLERGEN_LIST]: [${majorAllergensList.joinToString(", ")}]
            Finally, you MUST extract the list of ingredients.
            """
        } else ""

        val exampleOutput = when (deckName) {
            "Food" -> """{"stats": {"Energy (kcal per 100g)": "520", "Protein (g per 100g)": "5.8"}, "allergens": ["Milk", "Soybeans"], "ingredients": ["Wheat flour", "Sugar"]}"""
            "Bird" -> """{"stats": {"Wingspan (cm)": "22.0", "Lifespan (years)": "2.0"}, "scientificName": "...", "vernacularName": "..."}"""
            "Insect" -> """{"stats": {"Average Length (mm)": "15.0", "Lifespan (days)": "30.0"}, "scientificName": "...", "vernacularName": "..."}"""
            "Plant" -> """{"stats": {"Maximum Height (m)": "0.6", "Flowering Period (months)": "3.0"}, "scientificName": "...", "vernacularName": "..."}"""
            else -> "{}"
        }

        val rawPrompt = PromptManager.getPrompt("forge_stats")
        return String.format(rawPrompt, lowerSpecificName, statsString, allergenContext, exampleOutput, ocrText, description)
    }

    fun generateQuizPrompt(subject: String, description: String, stats: CardStats?, locale: Locale): String {
        val rawPrompt = PromptManager.getPrompt("forge_quiz")
        val statsJson = if (stats != null) Gson().toJson(stats.items) else "{}"
        val languageName = when (locale.language) {
            "fr" -> "French"
            "ja" -> "Japanese"
            else -> "English"
        }
        return String.format(rawPrompt, languageName, description, statsJson)
    }

    fun generateFullCardTranslationPrompt(originalContentJson: String, targetLanguageName: String): String {
        val rawPrompt = PromptManager.getPrompt("forge_translation")
        return String.format(rawPrompt, targetLanguageName, originalContentJson)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/PromptGenerator.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/StreamingJsonParser.kt ---

package be.heyman.android.ai.kikko.forge

import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import be.heyman.android.ai.kikko.model.IdentificationResult

/**
 * Un analyseur JSON intelligent et tolérant aux pannes, conçu pour interpréter
 * la sortie parfois imparfaite des LLMs en streaming.
 */
class StreamingJsonParser {

    private var buffer = ""
    private val gson = Gson()

    /**
     * Contient le résultat partiel ou complet d'une analyse JSON en streaming.
     */
    data class ParsedResult(
        val specificName: String = "",
        val deckName: String = "",
        val reasoning: Map<String, String> = emptyMap(),
        val confidence: Float = 0.0f,
        val isComplete: Boolean = false
    )

    fun process(chunk: String): ParsedResult {
        buffer += chunk

        // Tentative 1: Essayer de parser le JSON le plus complet possible.
        val firstBrace = buffer.indexOf('{')
        val lastBrace = buffer.lastIndexOf('}')

        if (firstBrace != -1 && lastBrace > firstBrace) {
            val potentialJson = buffer.substring(firstBrace, lastBrace + 1)
            try {
                // Essai avec Gson, le plus strict
                val result: IdentificationResult = gson.fromJson(potentialJson, IdentificationResult::class.java)
                if (result.specificName.isNotBlank() && result.deckName.isNotBlank()) {
                    return ParsedResult(
                        specificName = result.specificName,
                        deckName = result.deckName,
                        reasoning = mapOf(
                            "visualAnalysis" to result.reasoning.visualAnalysis,
                            "evidenceCorrelation" to result.reasoning.evidenceCorrelation
                        ),
                        confidence = result.confidence,
                        isComplete = true
                    )
                }
            } catch (e: JsonSyntaxException) {
                // Le JSON est malformé. On passe à la tentative 2.
            }
        }

        // Tentative 2: Extraction manuelle des champs clés, tolérante aux erreurs.
        val specificName = extractStringValue("specificName")
        val deckName = extractStringValue("deckName")

        val isPotentiallyComplete = specificName.isNotBlank() && deckName.isNotBlank() && buffer.contains("confidence")

        return ParsedResult(
            specificName = specificName,
            deckName = deckName,
            isComplete = isPotentiallyComplete
        )
    }

    private fun extractStringValue(key: String): String {
        val keyPattern = "\"$key\"\\s*:\\s*\"(.*?)\""
        val regex = keyPattern.toRegex()
        val match = regex.find(buffer)
        return match?.groups?.get(1)?.value ?: ""
    }

    fun reset() {
        buffer = ""
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/StreamingJsonParser.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/SwarmAnalysisData.kt ---

package be.heyman.android.ai.kikko.forge

/**
 * Contient le résultat complet d'une analyse d'essaim sur plusieurs images.
 * @param reports La liste des rapports d'analyse pour chaque image.
 */
data class SwarmAnalysisResult(
    val reports: List<ImageAnalysisReport>
)

/**
 * Contient le rapport d'analyse d'une seule image par les Abeilles Spécialistes.
 * @param detectedObjects La liste des objets détectés.
 * @param globalClassifierResults Une map des résultats des classifieurs, où la clé est le nom du classifieur.
 * @param ocrText Le texte brut reconnu par l'OCR.
 */
data class ImageAnalysisReport(
    val detectedObjects: List<SimpleDetectedObject>,
    val globalClassifierResults: Map<String, List<SimpleImageLabel>>,
    val ocrText: String
)

/**
 * Une représentation simplifiée d'un objet détecté par ML Kit.
 * @param labels La liste des labels associés à cet objet.
 */
data class SimpleDetectedObject(
    val labels: List<SimpleImageLabel>
)

/**
 * Une représentation simplifiée d'un label d'image (pour les objets ou les classifieurs).
 * @param text Le nom du label (ex: "Cat", "Eiffel Tower").
 * @param confidence Le score de confiance de la détection (entre 0.0 et 1.0).
 */
data class SimpleImageLabel(
    val text: String,
    val confidence: Float
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/SwarmAnalysisData.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/AnalysisResult.kt ---

package be.heyman.android.ai.kikko.model

import android.os.Parcelable
import kotlinx.parcelize.Parcelize
import java.util.UUID

/**
 * Définit les états possibles pour une seule tâche d'analyse
 * lancée depuis l'Atelier de la Forge.
 * BOURDON'S REFORGE: Ajout des états pour un contrôle granulaire des tâches.
 */
enum class AnalysisStatus {
    PENDING,   // La tâche est en file d'attente, prête à être lancée.
    RUNNING,   // La tâche est en cours d'exécution.
    PAUSED,    // La tâche a été mise en pause par l'utilisateur.
    CANCELLED, // La tâche a été annulée par l'utilisateur.
    COMPLETED, // La tâche s'est terminée avec succès.
    FAILED     // La tâche a échoué.
}

/**
 * Encapsule la configuration exacte d'un modèle IA pour une tâche d'analyse.
 * Permet de différencier les résultats d'un tournoi.
 */
@Parcelize
data class ModelConfiguration(
    val modelName: String,
    val accelerator: String,
    val temperature: Float,
    val topK: Int
) : Parcelable

/**
 * Représente une seule tâche d'analyse (et son résultat) lancée sur une propriété
 * d'un PollenGrain. Cet objet sera stocké dans une nouvelle table de la base de données.
 *
 * @param id Identifiant unique de la tâche d'analyse.
 * @param pollenGrainId L'ID du PollenGrain parent auquel cette tâche est associée.
 * @param propertyName Le nom de la propriété analysée (ex: "description", "stats.lifespan").
 * @param modelConfigJson La configuration du modèle IA utilisée, sérialisée en JSON.
 * @param rawResponse La réponse brute complète retournée par le modèle IA une fois la tâche terminée.
 * @param streamingResponse Le contenu partiel reçu en temps réel (non persisté).
 * @param status L'état actuel de cette tâche d'analyse.
 * @param timestamp L'horodatage de la création de cette tâche.
 * @param errorMessage Un message d'erreur si la tâche a échoué.
 */
@Parcelize
data class AnalysisResult(
    val id: String = UUID.randomUUID().toString(),
    val pollenGrainId: String,
    val propertyName: String,
    val modelConfigJson: String,
    var rawResponse: String? = null,
    // BOURDON'S ADDITION: Champ pour le texte en streaming.
    // Il est transient car il ne vit que dans l'UI et n'est pas sauvegardé en base de données.
    @Transient var streamingResponse: String? = null,
    var status: AnalysisStatus = AnalysisStatus.PENDING,
    val timestamp: Long = System.currentTimeMillis(),
    var errorMessage: String? = null
) : Parcelable

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/AnalysisResult.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/IdentificationResult.kt ---

package be.heyman.android.ai.kikko.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
// BOURDON'S FIX: Import explicite de la classe Reasoning de haut niveau
import be.heyman.android.ai.kikko.model.Reasoning

/**
 * Représente le résultat structuré du premier prompt de la chaîne multimodale.
 * Contient l'identification de base et le raisonnement de l'IA.
 */
@Serializable
data class IdentificationResult(
    // BOURDON'S FIX: On s'assure que ce champ utilise la classe de haut niveau
    // be.heyman.android.ai.kikko.model.Reasoning, et non une classe imbriquée.
    @SerialName("reasoning")
    val reasoning: Reasoning,

    @SerialName("deckName")
    val deckName: String,

    @SerialName("specificName")
    val specificName: String,

    @SerialName("confidence")
    val confidence: Float
)
// L'ancienne classe imbriquée "Reasoning" a été supprimée d'ici.

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/IdentificationResult.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/KnowledgeCard.kt ---

package be.heyman.android.ai.kikko.model

import android.os.Parcelable
import com.google.gson.annotations.SerializedName
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.Serializable

/**
 * Contient tous les champs traduisibles pour une langue spécifique.
 */
@Serializable
@Parcelize
data class TranslatedContent(
    val description: String?,
    val reasoning: Reasoning?,
    val quiz: List<QuizQuestion>?
) : Parcelable


/**
 * Représente une seule pièce de connaissance.
 * BOURDON'S REFORGE (v3.0): Le modèle est simplifié pour le concours,
 * avec des champs spécifiques aux decks biologiques et des stats flexibles.
 */
@Serializable
@Parcelize
data class KnowledgeCard(
    val id: Long = 0,
    val specificName: String,
    val deckName: String,
    val imagePath: String?,
    val confidence: Float,
    // Contenu original (généré par l'IA)
    val reasoning: Reasoning,
    val description: String?,
    val stats: CardStats?,
    val quiz: List<QuizQuestion>?,
    // Nouveaux champs pour les decks biologiques - BOURDON'S FIX
    val scientificName: String? = null,
    val vernacularName: String? = null,
    // Nouveaux champs pour le deck Food - BOURDON'S FIX
    val allergens: List<String>? = null,
    val ingredients: List<String>? = null,
    // Contenu traduit
    val translations: Map<String, TranslatedContent>? = null
) : Parcelable

@Serializable
@Parcelize
data class Reasoning(
    val visualAnalysis: String,
    val evidenceCorrelation: String
) : Parcelable

@Serializable
@Parcelize
data class CardStats(
    val title: String,
    // La map `items` est flexible pour contenir différentes stats selon le deck
    // Ex: {"Energy": "520 kcal", "Allergens": "Peanuts, Gluten"} pour Food
    // Ex: {"Wingspan": "110 cm", "Diet": "Carnivore"} pour Bird
    val items: Map<String, String>
) : Parcelable

@Serializable
@Parcelize
data class QuizQuestion(
    @SerializedName("q")
    val question: String,
    @SerializedName("o")
    val options: List<String>,
    @SerializedName("c")
    val correctAnswerIndex: Int,
    val explanation: String?
) : Parcelable

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/KnowledgeCard.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenGrain.kt ---

package be.heyman.android.ai.kikko.model

import android.os.Parcelable
import kotlinx.parcelize.Parcelize
import java.util.UUID

/**
 * Représente une session de récolte de "pollen" complète.
 * C'est un POKO (Plain Old Kotlin Object) utilisé comme modèle de données
 * pour la persistance en SQL pur.
 *
 * @property id Identifiant unique de la session de récolte (UUID).
 * @property timestamp Horodatage de la fin de la capture.
 * @property status L'état actuel du grain dans le cycle de vie de la Forge.
 * @property userIntent L'intention vocale ou textuelle de l'utilisateur lors de la capture.
 * @property pollenImagePaths Les chemins d'accès vers les fichiers images sources de la capture. Sérialisé en JSON.
 * @property swarmAnalysisReportJson Le rapport JSON brut complet de l'analyse par les Abeilles Spécialistes.
 * @property forgedCardId L'ID de la KnowledgeCard résultante une fois la Forge terminée.
 */
@Parcelize
data class PollenGrain(
    val id: String = UUID.randomUUID().toString(),
    val timestamp: Long = System.currentTimeMillis(),
    var status: PollenStatus = PollenStatus.RAW, // 'var' pour pouvoir le mettre à jour
    val userIntent: String?,
    val pollenImagePaths: List<String>,
    val swarmAnalysisReportJson: String?,
    var forgedCardId: Long? = null // 'var' pour pouvoir le mettre à jour
) : Parcelable

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenGrain.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenStatus.kt ---

package be.heyman.android.ai.kikko.model

/**
 * Définit les différents états possibles pour un PollenGrain dans son cycle de vie,
 * de sa capture brute à sa transformation finale en Miel (KnowledgeCard).
 * Chaque état représente une étape dans la chaîne de production de notre WorkManager.
 *
 * BOURDON'S REFORGE V6.0: Introduction d'un nouvel état pour la validation manuelle.
 */
enum class PollenStatus {
    /**
     * Le grain de pollen vient d'être capturé et est prêt pour la Forge.
     */
    RAW,

    /**
     * Étape 1 : Le grain est en cours de pré-identification par la Reine IA en arrière-plan.
     */
    IDENTIFYING,

    /**
     * NOUVEL ÉTAT: Le grain a une identification préliminaire et attend la validation
     * du Maître Forgeron dans l'Atelier. C'est le point d'entrée pour le raffinage manuel.
     */
    AWAITING_VALIDATION,

    /**
     * En attente de l'Étape 2 : La génération de la description narrative.
     */
    PENDING_DESCRIPTION,

    /**
     * En attente de l'Étape 3 : L'extraction des statistiques.
     */
    PENDING_STATS,

    /**
     * En attente de l'Étape 4 : La création du quiz.
     */
    PENDING_QUIZ,

    /**
     * En attente de l'Étape 5 : La traduction du contenu.
     */
    PENDING_TRANSLATION,

    /**
     * Le processus de Forge est terminé avec succès. La KnowledgeCard est complète.
     */
    FORGED,

    /**
     * Une erreur est survenue à l'une des étapes de la Forge.
     */
    ERROR
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/PollenStatus.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/SwarmAnalysisData.kt ---

package be.heyman.android.ai.kikko.model

import com.google.gson.annotations.SerializedName

/**
 * Contient le résultat complet d'une analyse d'essaim sur plusieurs images.
 */
data class SwarmAnalysisResult(
    val reports: List<ImageAnalysisReport>?
)

/**
 * BOURDON'S ROBUSTNESS FIX V3:
 * - Structure de données alignée sur le JSON réel de PollenForge.
 * - Toutes les collections et propriétés potentiellement manquantes sont nullables.
 */
data class ImageAnalysisReport(
    @SerializedName("object_detection_results")
    val detectedObjects: List<SimpleDetectedObject>?,

    @SerializedName("global_classification_results")
    val globalClassifierResults: Map<String, List<SimpleImageLabel>?>?,

    @SerializedName("ocr_results")
    val ocrResults: OcrResult?
) {
    val ocrText: String
        get() = ocrResults?.fullText ?: ""
}

data class OcrResult(
    @SerializedName("full_text")
    val fullText: String?
)

data class SimpleDetectedObject(
    val labels: List<SimpleImageLabel>
)

data class SimpleImageLabel(
    // BOURDON'S FIX: Rendu nullable pour empêcher les crashs de Gson/Kotlin.
    val text: String?,
    val confidence: Float
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/model/SwarmAnalysisData.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/AnalysisResultDao.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.util.Log
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * DAO (Data Access Object) pour l'entité AnalysisResult.
 * Gère toutes les interactions avec la table "analysis_results".
 */
class AnalysisResultDao(context: Context) {

    private val dbHelper = DatabaseHelper.getInstance(context) // BOURDON'S FIX: Assure l'initialisation correcte du singleton
    private val gson = Gson()

    /**
     * Insère un nouveau résultat d'analyse (ou une tâche) dans la base de données.
     * @param result L'objet AnalysisResult à insérer.
     */
    suspend fun insert(result: AnalysisResult) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_AR_ID, result.id) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_POLLEN_ID, result.pollenGrainId) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_PROPERTY_NAME, result.propertyName) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_MODEL_CONFIG_JSON, result.modelConfigJson) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_RAW_RESPONSE, result.rawResponse) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_STATUS, result.status.name) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_TIMESTAMP, result.timestamp) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_ERROR_MESSAGE, result.errorMessage) // BOURDON'S FIX: Références qualifiées
        }
        db.insert(DatabaseHelper.TABLE_ANALYSIS_RESULTS, null, values) // BOURDON'S FIX: Références qualifiées
    }

    /**
     * Met à jour un résultat d'analyse existant.
     * @param result L'objet AnalysisResult avec les nouvelles données.
     */
    suspend fun update(result: AnalysisResult) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_AR_RAW_RESPONSE, result.rawResponse) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_STATUS, result.status.name) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_AR_ERROR_MESSAGE, result.errorMessage) // BOURDON'S FIX: Références qualifiées
        }
        db.update(
            DatabaseHelper.TABLE_ANALYSIS_RESULTS, // BOURDON'S FIX: Références qualifiées
            values,
            "${DatabaseHelper.COLUMN_AR_ID} = ?", // BOURDON'S FIX: Références qualifiées
            arrayOf(result.id)
        )
    }

    /**
     * Récupère tous les résultats d'analyse pour un PollenGrain et une propriété spécifiques.
     * @param pollenGrainId L'ID du PollenGrain parent.
     * @param propertyName Le nom de la propriété (ex: "description").
     * @return Une liste d'AnalysisResults.
     */
    suspend fun getByPollenGrainIdAndProperty(pollenGrainId: String, propertyName: String): List<AnalysisResult> = withContext(Dispatchers.IO) {
        val results = mutableListOf<AnalysisResult>()
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_ANALYSIS_RESULTS, // BOURDON'S FIX: Références qualifiées
            null, // Toutes les colonnes
            "${DatabaseHelper.COLUMN_AR_POLLEN_ID} = ? AND ${DatabaseHelper.COLUMN_AR_PROPERTY_NAME} = ?", // BOURDON'S FIX: Références qualifiées
            arrayOf(pollenGrainId, propertyName),
            null, null, "${DatabaseHelper.COLUMN_AR_TIMESTAMP} ASC" // BOURDON'S FIX: Références qualifiées
        )
        cursor.use {
            while (it.moveToNext()) {
                results.add(cursorToAnalysisResult(it))
            }
        }
        return@withContext results
    }

    /**
     * BOURDON'S FIX: Supprime tous les résultats d'analyse pour une propriété spécifique d'un grain.
     * C'est la méthode nécessaire pour la fonctionnalité de "relance".
     */
    suspend fun deleteByPollenGrainIdAndProperty(pollenGrainId: String, propertyName: String) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val deletedRows = db.delete(
            DatabaseHelper.TABLE_ANALYSIS_RESULTS,
            "${DatabaseHelper.COLUMN_AR_POLLEN_ID} = ? AND ${DatabaseHelper.COLUMN_AR_PROPERTY_NAME} = ?",
            arrayOf(pollenGrainId, propertyName)
        )
        Log.i("AnalysisResultDao", "$deletedRows résultats d'analyse supprimés pour le grain $pollenGrainId et la propriété $propertyName.")
    }


    /**
     * Supprime TOUTES les entrées de la table analysis_results. Action irréversible.
     */
    suspend fun nuke() = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(DatabaseHelper.TABLE_ANALYSIS_RESULTS, null, null) // BOURDON'S FIX: Références qualifiées
        Log.w("AnalysisResultDao", "NUKE: La table analysis_results a été entièrement vidée.")
    }

    /**
     * Helper pour convertir une ligne de curseur en un objet AnalysisResult.
     */
    private fun cursorToAnalysisResult(cursor: Cursor): AnalysisResult {
        fun getStringOrNull(columnName: String): String? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getString(colIndex) else null
        }

        return AnalysisResult(
            id = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_ID)), // BOURDON'S FIX: Références qualifiées
            pollenGrainId = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_POLLEN_ID)), // BOURDON'S FIX: Références qualifiées
            propertyName = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_PROPERTY_NAME)), // BOURDON'S FIX: Références qualifiées
            modelConfigJson = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_MODEL_CONFIG_JSON)), // BOURDON'S FIX: Références qualifiées
            rawResponse = getStringOrNull(DatabaseHelper.COLUMN_AR_RAW_RESPONSE), // BOURDON'S FIX: Références qualifiées
            status = AnalysisStatus.valueOf(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_STATUS))), // BOURDON'S FIX: Références qualifiées
            timestamp = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_AR_TIMESTAMP)), // BOURDON'S FIX: Références qualifiées
            errorMessage = getStringOrNull(DatabaseHelper.COLUMN_AR_ERROR_MESSAGE) // BOURDON'S FIX: Références qualifiées
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/AnalysisResultDao.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/CardDao.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.util.Log
import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.QuizQuestion
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.model.TranslatedContent
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/**
 * DAO (Data Access Object) for the KnowledgeCard entity.
 * BOURDON'S REFORGE (v6.0): Added a surgical update method for validation.
 */
class CardDao(context: Context) {
    private val dbHelper = DatabaseHelper.getInstance(context)
    private val gson = Gson()
    private val TAG = "KikkoForgeTrace" // BOURDON'S LOGGING: TAG unifié

    private val quizListType = object : TypeToken<List<QuizQuestion>>() {}.type
    private val statsType = object : TypeToken<CardStats>() {}.type
    private val reasoningType = object : TypeToken<Reasoning>() {}.type
    private val translationsType = object : TypeToken<Map<String, TranslatedContent>>() {}.type
    private val stringListType = object : TypeToken<List<String>>() {}.type

    suspend fun insert(card: KnowledgeCard): Long = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME, card.specificName)
            put(DatabaseHelper.COLUMN_CARD_DECK_NAME, card.deckName)
            put(DatabaseHelper.COLUMN_CARD_IMAGE_PATH, card.imagePath)
            put(DatabaseHelper.COLUMN_CARD_CONFIDENCE, card.confidence)
            put(DatabaseHelper.COLUMN_CARD_DESCRIPTION, card.description)
            put(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME, card.scientificName)
            put(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME, card.vernacularName)
            put(DatabaseHelper.COLUMN_CARD_REASONING_JSON, gson.toJson(card.reasoning))
            put(DatabaseHelper.COLUMN_CARD_STATS_JSON, gson.toJson(card.stats))
            put(DatabaseHelper.COLUMN_CARD_QUIZ_JSON, gson.toJson(card.quiz))
            put(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON, gson.toJson(card.translations))
            put(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON, gson.toJson(card.allergens, stringListType))
            put(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON, gson.toJson(card.ingredients, stringListType))
        }
        val id = db.insert(DatabaseHelper.TABLE_CARDS, null, values)
        Log.i(TAG, "[DAO-INSERT] Carte insérée avec ID: $id. Nom: '${card.specificName}', Deck: '${card.deckName}'")
        return@withContext id
    }

    suspend fun getAll(): List<KnowledgeCard> = withContext(Dispatchers.IO) {
        val cards = mutableListOf<KnowledgeCard>()
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_CARDS, null, null, null, null, null,
            "${DatabaseHelper.COLUMN_CARD_ID} DESC"
        )
        cursor.use {
            while (it.moveToNext()) {
                cards.add(cursorToKnowledgeCard(it))
            }
        }
        return@withContext cards
    }

    suspend fun getCardById(id: Long): KnowledgeCard? = withContext(Dispatchers.IO) {
        var card: KnowledgeCard? = null
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_CARDS, null, "${DatabaseHelper.COLUMN_CARD_ID} = ?",
            arrayOf(id.toString()), null, null, null
        )
        cursor.use {
            if (it.moveToFirst()) {
                card = cursorToKnowledgeCard(it)
            }
        }
        return@withContext card
    }

    suspend fun update(card: KnowledgeCard) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME, card.specificName)
            put(DatabaseHelper.COLUMN_CARD_DECK_NAME, card.deckName)
            put(DatabaseHelper.COLUMN_CARD_IMAGE_PATH, card.imagePath)
            put(DatabaseHelper.COLUMN_CARD_CONFIDENCE, card.confidence)
            put(DatabaseHelper.COLUMN_CARD_DESCRIPTION, card.description)
            put(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME, card.scientificName)
            put(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME, card.vernacularName)
            put(DatabaseHelper.COLUMN_CARD_REASONING_JSON, gson.toJson(card.reasoning))
            put(DatabaseHelper.COLUMN_CARD_STATS_JSON, gson.toJson(card.stats))
            put(DatabaseHelper.COLUMN_CARD_QUIZ_JSON, gson.toJson(card.quiz))
            put(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON, gson.toJson(card.translations))
            put(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON, gson.toJson(card.allergens, stringListType))
            put(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON, gson.toJson(card.ingredients, stringListType))
        }
        val rows = db.update(
            DatabaseHelper.TABLE_CARDS, values,
            "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(card.id.toString())
        )
        Log.i(TAG, "[DAO-UPDATE] ${rows} ligne(s) mise(s) à jour pour la carte ID ${card.id}.")
    }

    suspend fun updateIdentification(cardId: Long, specificName: String?, deckName: String?, reasoning: Reasoning, confidence: Float) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        Log.d(TAG, "[DAO-UPDATE-ID] Ordre reçu pour Carte ID $cardId: Nom='$specificName', Deck='$deckName'")
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME, specificName)
            put(DatabaseHelper.COLUMN_CARD_DECK_NAME, deckName)
            put(DatabaseHelper.COLUMN_CARD_REASONING_JSON, gson.toJson(reasoning, reasoningType))
            put(DatabaseHelper.COLUMN_CARD_CONFIDENCE, confidence)
        }
        val rows = db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
        Log.i(TAG, "[DAO-UPDATE-ID] ${rows} ligne(s) mise(s) à jour pour la carte ID $cardId. L'opération a-t-elle réussi ? (rows > 0)")
    }

    suspend fun updateDescription(cardId: Long, description: String?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_DESCRIPTION, description)
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateStats(cardId: Long, stats: CardStats?, allergens: List<String>?, ingredients: List<String>?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_STATS_JSON, gson.toJson(stats))
            put(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON, gson.toJson(allergens, stringListType))
            put(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON, gson.toJson(ingredients, stringListType))
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateScientificAndVernacularNames(cardId: Long, scientificName: String?, vernacularName: String?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME, scientificName)
            put(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME, vernacularName)
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateQuiz(cardId: Long, quiz: List<QuizQuestion>?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_QUIZ_JSON, gson.toJson(quiz))
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun updateTranslations(cardId: Long, translations: Map<String, TranslatedContent>?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON, gson.toJson(translations))
        }
        db.update(DatabaseHelper.TABLE_CARDS, values, "${DatabaseHelper.COLUMN_CARD_ID} = ?", arrayOf(cardId.toString()))
    }

    suspend fun delete(card: KnowledgeCard) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(
            DatabaseHelper.TABLE_CARDS,
            "${DatabaseHelper.COLUMN_CARD_ID} = ?",
            arrayOf(card.id.toString())
        )
    }

    suspend fun nuke() = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(DatabaseHelper.TABLE_CARDS, null, null)
        Log.w("CardDao", "NUKE: La table knowledge_cards a été entièrement vidée.")
    }

    private fun cursorToKnowledgeCard(cursor: Cursor): KnowledgeCard {
        fun getStringOrNull(columnName: String): String? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getString(colIndex) else null
        }
        fun getLongOrNull(columnName: String): Long? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getLong(colIndex) else null
        }

        val specificNameRaw = getStringOrNull(DatabaseHelper.COLUMN_CARD_SPECIFIC_NAME)
        val deckNameRaw = getStringOrNull(DatabaseHelper.COLUMN_CARD_DECK_NAME)
        val cardId = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_CARD_ID))
        Log.d(TAG, "[DAO-READ] Lecture Carte ID $cardId: Nom='${specificNameRaw}', Deck='${deckNameRaw}'")

        val specificName = specificNameRaw ?: "Erreur de Nom"
        val deckName = deckNameRaw ?: "Erreur de Deck"

        return KnowledgeCard(
            id = cardId,
            specificName = specificName,
            deckName = deckName,
            imagePath = getStringOrNull(DatabaseHelper.COLUMN_CARD_IMAGE_PATH),
            confidence = cursor.getFloat(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_CARD_CONFIDENCE)),
            description = getStringOrNull(DatabaseHelper.COLUMN_CARD_DESCRIPTION),
            scientificName = getStringOrNull(DatabaseHelper.COLUMN_CARD_SCIENTIFIC_NAME),
            vernacularName = getStringOrNull(DatabaseHelper.COLUMN_CARD_VERNACULAR_NAME),
            reasoning = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_REASONING_JSON), reasoningType) ?: Reasoning("N/A","N/A"),
            stats = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_STATS_JSON), statsType),
            quiz = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_QUIZ_JSON), quizListType),
            translations = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_TRANSLATIONS_JSON), translationsType),
            allergens = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_ALLERGENS_JSON), stringListType),
            ingredients = gson.fromJson(getStringOrNull(DatabaseHelper.COLUMN_CARD_INGREDIENTS_JSON), stringListType)
        )
    }
    fun getAllCardsFlow(): Flow<List<KnowledgeCard>> {
        return flow {
            emit(getAll())
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/CardDao.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/DatabaseHelper.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.util.Log

class DatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {

    companion object {
        private const val DATABASE_NAME = "kikko.db"
        // BOURDON'S REFORGE: Version incrémentée à 7 pour refléter le nouveau schéma de carte.
        private const val DATABASE_VERSION = 7 // BOURDON'S FIX: Incrémentation de la version

        // --- Table "knowledge_cards" Definition ---
        const val TABLE_CARDS = "knowledge_cards"
        const val COLUMN_CARD_ID = "id"
        const val COLUMN_CARD_SPECIFIC_NAME = "specificName"
        const val COLUMN_CARD_DECK_NAME = "deckName"
        const val COLUMN_CARD_IMAGE_PATH = "imagePath"
        const val COLUMN_CARD_CONFIDENCE = "confidence"
        const val COLUMN_CARD_DESCRIPTION = "description"
        const val COLUMN_CARD_REASONING_JSON = "reasoning"
        const val COLUMN_CARD_STATS_JSON = "stats"
        const val COLUMN_CARD_QUIZ_JSON = "quiz"
        const val COLUMN_CARD_TRANSLATIONS_JSON = "translations"
        // BOURDON'S REFORGE: Ajout des nouveaux champs pour les decks biologiques.
        const val COLUMN_CARD_SCIENTIFIC_NAME = "scientificName"
        const val COLUMN_CARD_VERNACULAR_NAME = "vernacularName"
        // BOURDON'S FIX: NOUVEAUX CHAMPS ALLERGENS ET INGREDIENTS
        const val COLUMN_CARD_ALLERGENS_JSON = "allergens"
        const val COLUMN_CARD_INGREDIENTS_JSON = "ingredients"


        private const val TABLE_CARDS_CREATE =
            "CREATE TABLE $TABLE_CARDS (" +
                    "$COLUMN_CARD_ID INTEGER PRIMARY KEY AUTOINCREMENT, " +
                    "$COLUMN_CARD_SPECIFIC_NAME TEXT, " +
                    "$COLUMN_CARD_DECK_NAME TEXT, " +
                    "$COLUMN_CARD_IMAGE_PATH TEXT, " +
                    "$COLUMN_CARD_CONFIDENCE REAL, " +
                    "$COLUMN_CARD_DESCRIPTION TEXT, " +
                    // BOURDON'S REFORGE: Ajout des nouvelles colonnes au schéma.
                    "$COLUMN_CARD_SCIENTIFIC_NAME TEXT, " +
                    "$COLUMN_CARD_VERNACULAR_NAME TEXT, " +
                    "$COLUMN_CARD_REASONING_JSON TEXT, " +
                    "$COLUMN_CARD_STATS_JSON TEXT, " +
                    "$COLUMN_CARD_QUIZ_JSON TEXT, " +
                    "$COLUMN_CARD_TRANSLATIONS_JSON TEXT, " +
                    // BOURDON'S FIX: Ajout des nouvelles colonnes à la clause CREATE TABLE.
                    "$COLUMN_CARD_ALLERGENS_JSON TEXT, " +
                    "$COLUMN_CARD_INGREDIENTS_JSON TEXT);"

        // --- Table "pollen_grains" Definition (inchangée) ---
        const val TABLE_POLLEN_GRAINS = "pollen_grains"
        const val COLUMN_POLLEN_ID = "id"
        const val COLUMN_POLLEN_TIMESTAMP = "timestamp"
        const val COLUMN_POLLEN_STATUS = "status"
        const val COLUMN_POLLEN_USER_INTENT = "user_intent"
        const val COLUMN_POLLEN_IMAGE_PATHS_JSON = "image_paths_json"
        const val COLUMN_POLLEN_SWARM_REPORT_JSON = "swarm_report_json"
        const val COLUMN_POLLEN_FORGED_CARD_ID = "forged_card_id"

        private const val TABLE_POLLEN_CREATE =
            "CREATE TABLE $TABLE_POLLEN_GRAINS (" +
                    "$COLUMN_POLLEN_ID TEXT PRIMARY KEY NOT NULL, " +
                    "$COLUMN_POLLEN_TIMESTAMP INTEGER NOT NULL, " +
                    "$COLUMN_POLLEN_STATUS TEXT NOT NULL, " +
                    "$COLUMN_POLLEN_USER_INTENT TEXT, " +
                    "$COLUMN_POLLEN_IMAGE_PATHS_JSON TEXT NOT NULL, " +
                    "$COLUMN_POLLEN_SWARM_REPORT_JSON TEXT, " +
                    "$COLUMN_POLLEN_FORGED_CARD_ID INTEGER, " +
                    "FOREIGN KEY($COLUMN_POLLEN_FORGED_CARD_ID) REFERENCES $TABLE_CARDS($COLUMN_CARD_ID));"

        // --- Table "analysis_results" Definition (inchangée) ---
        const val TABLE_ANALYSIS_RESULTS = "analysis_results"
        const val COLUMN_AR_ID = "id"
        const val COLUMN_AR_POLLEN_ID = "pollen_grain_id"
        const val COLUMN_AR_PROPERTY_NAME = "property_name"
        const val COLUMN_AR_MODEL_CONFIG_JSON = "model_config_json"
        const val COLUMN_AR_RAW_RESPONSE = "raw_response"
        const val COLUMN_AR_STATUS = "status"
        const val COLUMN_AR_TIMESTAMP = "timestamp"
        const val COLUMN_AR_ERROR_MESSAGE = "error_message"

        private const val TABLE_ANALYSIS_RESULTS_CREATE =
            "CREATE TABLE $TABLE_ANALYSIS_RESULTS (" +
                    "$COLUMN_AR_ID TEXT PRIMARY KEY NOT NULL, " +
                    "$COLUMN_AR_POLLEN_ID TEXT NOT NULL, " +
                    "$COLUMN_AR_PROPERTY_NAME TEXT NOT NULL, " +
                    "$COLUMN_AR_MODEL_CONFIG_JSON TEXT NOT NULL, " +
                    "$COLUMN_AR_RAW_RESPONSE TEXT, " +
                    "$COLUMN_AR_STATUS TEXT NOT NULL, " +
                    "$COLUMN_AR_TIMESTAMP INTEGER NOT NULL, " +
                    "$COLUMN_AR_ERROR_MESSAGE TEXT, " +
                    "FOREIGN KEY($COLUMN_AR_POLLEN_ID) REFERENCES $TABLE_POLLEN_GRAINS($COLUMN_POLLEN_ID) ON DELETE CASCADE);"


        @Volatile
        private var INSTANCE: DatabaseHelper? = null

        fun getInstance(context: Context): DatabaseHelper {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: DatabaseHelper(context.applicationContext).also { INSTANCE = it }
            }
        }
    }

    override fun onCreate(db: SQLiteDatabase?) {
        Log.i("DatabaseHelper", "Création des tables de la base de données (v$DATABASE_VERSION)...")
        db?.execSQL(TABLE_CARDS_CREATE)
        db?.execSQL(TABLE_POLLEN_CREATE)
        db?.execSQL(TABLE_ANALYSIS_RESULTS_CREATE)
    }

    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
        Log.w("DatabaseHelper", "Mise à jour de la base de données de la version $oldVersion à $newVersion, les anciennes données seront détruites.")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_ANALYSIS_RESULTS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_POLLEN_GRAINS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_CARDS")
        onCreate(db)
    }

    override fun onDowngrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
        Log.w("DatabaseHelper", "Retour en arrière de la BDD de v$oldVersion à v$newVersion. Purge complète des données...")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_ANALYSIS_RESULTS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_POLLEN_GRAINS")
        db?.execSQL("DROP TABLE IF EXISTS $TABLE_CARDS")
        onCreate(db)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/DatabaseHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/PollenGrainDao.kt ---

package be.heyman.android.ai.kikko.persistence

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.util.Log
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * DAO (Data Access Object) pour l'entité PollenGrain.
 * Gère toutes les interactions avec la table "pollen_grains" en utilisant des requêtes SQL pures.
 */
class PollenGrainDao(context: Context) {

    private val dbHelper = DatabaseHelper.getInstance(context) // BOURDON'S FIX: Assure l'initialisation correcte du singleton
    private val gson = Gson()
    private val stringListType = object : TypeToken<List<String>>() {}.type

    /**
     * Insère un nouveau PollenGrain dans la base de données.
     * @param pollenGrain L'objet à insérer.
     */
    suspend fun insert(pollenGrain: PollenGrain) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_POLLEN_ID, pollenGrain.id) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_TIMESTAMP, pollenGrain.timestamp) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_STATUS, pollenGrain.status.name) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_USER_INTENT, pollenGrain.userIntent) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_IMAGE_PATHS_JSON, gson.toJson(pollenGrain.pollenImagePaths, stringListType)) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_SWARM_REPORT_JSON, pollenGrain.swarmAnalysisReportJson) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID, pollenGrain.forgedCardId) // BOURDON'S FIX: Références qualifiées
        }
        db.insert(DatabaseHelper.TABLE_POLLEN_GRAINS, null, values) // BOURDON'S FIX: Références qualifiées
    }

    /**
     * Met à jour le statut et l'ID de la carte forgée d'un PollenGrain.
     * Utilisé à la fin d'une étape de forge réussie.
     * @param pollenId L'ID du grain à mettre à jour.
     * @param newStatus Le nouveau statut du grain.
     * @param forgedCardId L'ID de la KnowledgeCard nouvellement créée.
     */
    suspend fun updateForgingResult(pollenId: String, newStatus: PollenStatus, forgedCardId: Long?) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_POLLEN_STATUS, newStatus.name) // BOURDON'S FIX: Références qualifiées
            put(DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID, forgedCardId) // BOURDON'S FIX: Références qualifiées
        }
        db.update(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: Références qualifiées
            values,
            "${DatabaseHelper.COLUMN_POLLEN_ID} = ?", // BOURDON'S FIX: Références qualifiées
            arrayOf(pollenId)
        )
    }

    /**
     * Met à jour uniquement le statut d'un PollenGrain.
     * C'est une méthode optimisée pour les workers.
     * @param pollenId L'ID du grain à mettre à jour.
     * @param newStatus Le nouveau statut à appliquer.
     */
    suspend fun updateStatus(pollenId: String, newStatus: PollenStatus) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        val values = ContentValues().apply {
            put(DatabaseHelper.COLUMN_POLLEN_STATUS, newStatus.name) // BOURDON'S FIX: Références qualifiées
        }
        db.update(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: Références qualifiées
            values,
            "${DatabaseHelper.COLUMN_POLLEN_ID} = ?", // BOURDON'S FIX: Références qualifiées
            arrayOf(pollenId)
        )
    }

    /**
     * BOURDON'S FIX: Nouvelle méthode de suppression pour un grain spécifique.
     * @param pollenGrain Le grain à supprimer de la base de données.
     */
    suspend fun delete(pollenGrain: PollenGrain) = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(
            DatabaseHelper.TABLE_POLLEN_GRAINS,
            "${DatabaseHelper.COLUMN_POLLEN_ID} = ?",
            arrayOf(pollenGrain.id)
        )
        Log.d("PollenGrainDao", "PollenGrain (ID: ${pollenGrain.id}) supprimé de la base de données.")
    }


    /**
     * Récupère tous les PollenGrains ayant un statut spécifique.
     * @param status Le statut à rechercher.
     * @return Une liste de PollenGrains correspondants.
     */
    suspend fun getByStatus(status: PollenStatus): List<PollenGrain> = withContext(Dispatchers.IO) {
        val grains = mutableListOf<PollenGrain>()
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: Références qualifiées
            null, // Toutes les colonnes
            "${DatabaseHelper.COLUMN_POLLEN_STATUS} = ?", // BOURDON'S FIX: Références qualifiées
            arrayOf(status.name),
            null, null, "${DatabaseHelper.COLUMN_POLLEN_TIMESTAMP} ASC" // BOURDON'S FIX: Références qualifiées
        )
        cursor.use {
            while (it.moveToNext()) {
                grains.add(cursorToPollenGrain(it))
            }
        }
        return@withContext grains
    }

    /**
     * NOUVEAU: Récupère un PollenGrain par l'ID de la carte qu'il a forgée.
     * @param cardId L'ID de la KnowledgeCard.
     * @return Le PollenGrain correspondant ou null si non trouvé.
     */
    suspend fun findByForgedCardId(cardId: Long): PollenGrain? = withContext(Dispatchers.IO) {
        var grain: PollenGrain? = null
        val db = dbHelper.readableDatabase
        val cursor = db.query(
            DatabaseHelper.TABLE_POLLEN_GRAINS, // BOURDON'S FIX: Références qualifiées
            null,
            "${DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID} = ?", // BOURDON'S FIX: Références qualifiées
            arrayOf(cardId.toString()),
            null, null, null, "1"
        )
        cursor.use {
            if (it.moveToFirst()) {
                grain = cursorToPollenGrain(it)
            }
        }
        return@withContext grain
    }

    /**
     * Compte le nombre de grains pour chaque statut.
     * C'est la fonction clé pour alimenter les cocardes de l'interface.
     * @return Une map associant chaque PollenStatus à son nombre d'occurrences.
     */
    suspend fun countByStatus(): Map<PollenStatus, Int> = withContext(Dispatchers.IO) {
        val counts = PollenStatus.values().associateWith { 0 }.toMutableMap()
        val db = dbHelper.readableDatabase
        val query = "SELECT ${DatabaseHelper.COLUMN_POLLEN_STATUS}, COUNT(*) FROM ${DatabaseHelper.TABLE_POLLEN_GRAINS} GROUP BY ${DatabaseHelper.COLUMN_POLLEN_STATUS}" // BOURDON'S FIX: Références qualifiées
        val cursor = db.rawQuery(query, null)
        cursor.use {
            while (it.moveToNext()) {
                try {
                    val status = PollenStatus.valueOf(it.getString(it.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_STATUS))) // BOURDON'S FIX: getColumnIndexOrThrow
                    val count = it.getInt(it.getColumnIndexOrThrow("COUNT(*)")) // BOURDON'S FIX: getColumnIndexOrThrow
                    counts[status] = count
                } catch (e: IllegalArgumentException) {
                    // Ignore les statuts inconnus dans la base de données
                }
            }
        }
        return@withContext counts
    }

    suspend fun getDebugSummary(): String = withContext(Dispatchers.IO) {
        val db = dbHelper.readableDatabase
        val cursor = db.query(DatabaseHelper.TABLE_POLLEN_GRAINS, null, null, null, null, null, "${DatabaseHelper.COLUMN_POLLEN_TIMESTAMP} DESC") // BOURDON'S FIX: Références qualifiées
        val summary = StringBuilder()
        summary.append("--- Début du Rapport de la Réserve de Pollen ---\n")
        summary.append("Total de Grains: ${cursor.count}\n")
        cursor.use {
            while (it.moveToNext()) {
                val grain = cursorToPollenGrain(it)
                summary.append("  - ID: ${grain.id.substring(0, 8)}... | Status: ${grain.status} | CardID: ${grain.forgedCardId ?: "N/A"}\n")
            }
        }
        summary.append("--- Fin du Rapport ---")
        return@withContext summary.toString()
    }

    /**
     * Supprime TOUTES les entrées de la table pollen_grains. Action irréversible.
     */
    suspend fun nuke() = withContext(Dispatchers.IO) {
        val db = dbHelper.writableDatabase
        db.delete(DatabaseHelper.TABLE_POLLEN_GRAINS, null, null) // BOURDON'S FIX: Références qualifiées
        Log.w("PollenGrainDao", "NUKE: La table pollen_grains a été entièrement vidée.")
    }

    /**
     * Helper pour convertir une ligne de curseur en un objet PollenGrain.
     */
    private fun cursorToPollenGrain(cursor: Cursor): PollenGrain {
        fun getStringOrNull(columnName: String): String? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getString(colIndex) else null
        }
        fun getLongOrNull(columnName: String): Long? {
            val colIndex = cursor.getColumnIndex(columnName)
            return if (colIndex != -1 && !cursor.isNull(colIndex)) cursor.getLong(colIndex) else null
        }


        return PollenGrain(
            id = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_ID)), // BOURDON'S FIX: getColumnIndexOrThrow
            timestamp = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_TIMESTAMP)), // BOURDON'S FIX: getColumnIndexOrThrow
            status = PollenStatus.valueOf(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_STATUS))), // BOURDON'S FIX: getColumnIndexOrThrow
            userIntent = getStringOrNull(DatabaseHelper.COLUMN_POLLEN_USER_INTENT), // BOURDON'S FIX: getColumnIndexOrThrow
            pollenImagePaths = gson.fromJson(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.COLUMN_POLLEN_IMAGE_PATHS_JSON)), stringListType), // BOURDON'S FIX: getColumnIndexOrThrow
            swarmAnalysisReportJson = getStringOrNull(DatabaseHelper.COLUMN_POLLEN_SWARM_REPORT_JSON), // BOURDON'S FIX: getColumnIndexOrThrow
            forgedCardId = getLongOrNull(DatabaseHelper.COLUMN_POLLEN_FORGED_CARD_ID) // BOURDON'S FIX: getColumnIndexOrThrow
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/persistence/PollenGrainDao.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---

package be.heyman.android.ai.kikko.pollen

import android.Manifest
import android.annotation.SuppressLint
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageFormat
import android.graphics.Matrix
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.CompoundButton
import android.widget.TextView
import android.widget.Toast
import android.widget.ToggleButton
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.ImageProxy
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.TtsService
import kotlinx.coroutines.launch
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

@SuppressLint("ClickableViewAccessibility")
class ForgeLiveActivity : AppCompatActivity(), CompoundButton.OnCheckedChangeListener {

    private val viewModel: ForgeLiveViewModel by lazy {
        ViewModelProvider(this, ViewModelProvider.AndroidViewModelFactory(application)).get(ForgeLiveViewModel::class.java)
    }

    // BOURDON'S LOGGING: TAG pour cette activité.
    private val TAG = "ForgeLiveActivity"

    // Vues
    private lateinit var previewView: PreviewView
    private lateinit var facingSwitch: ToggleButton
    // Vues de dialogue
    private lateinit var bourdonDialogueContainer: View
    private lateinit var bourdonMessageTextView: TextView
    // BOURDON'S REFACTOR: Suppression des vues liées à l'intention.
    // private lateinit var pollenStartCaptureButton: Button
    // private lateinit var intentChoiceContainer: View
    // private lateinit var recordVoiceButton: ImageButton
    // private lateinit var pollenSkipIntentButton: Button
    // Vues de capture
    private lateinit var pollenRecyclerView: RecyclerView
    private lateinit var pollenAdapter: PollenPreviewAdapter
    private lateinit var captureButtonContainer: View
    private lateinit var captureButton: Button
    private lateinit var finishHarvestButton: Button
    // Vues de choix final
    private lateinit var finalChoiceContainer: View
    private lateinit var restartHarvestButton: Button
    private lateinit var sendToHiveButton: Button

    // Utilitaires
    private lateinit var cameraExecutor: ExecutorService
    private var cameraProvider: ProcessCameraProvider? = null
    private var imageCapture: ImageCapture? = null
    private var lensFacing = CameraSelector.LENS_FACING_BACK
    private lateinit var yuvToRgbConverter: YuvToRgbConverter
    private lateinit var pollenForge: PollenForge

    // BOURDON'S REFACTOR: Le launcher de permission micro est maintenant obsolète.
    private val requestCameraPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
        if (isGranted) {
            Log.i(TAG, "Permission caméra accordée. Initialisation.")
            setupCamera()
        } else {
            Toast.makeText(this, "Permission caméra refusée. Impossible de continuer.", Toast.LENGTH_LONG).show()
            finish()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_forge_live)
        Log.d(TAG, "[CYCLE DE VIE] onCreate")

        yuvToRgbConverter = YuvToRgbConverter(this)
        cameraExecutor = Executors.newSingleThreadExecutor()
        pollenForge = PollenForge(this)

        TtsService.initialize(this)

        bindViews()
        setupRecyclerView()
        setupListeners()
        checkCameraPermissionAndSetup()
        observeViewModel()
    }

    private fun bindViews() {
        Log.d(TAG, "Liaison des vues...")
        previewView = findViewById(R.id.live_preview_view)
        facingSwitch = findViewById(R.id.facing_switch)
        bourdonDialogueContainer = findViewById(R.id.bourdon_dialogue_container)
        bourdonMessageTextView = findViewById(R.id.bourdon_message_textview)
        // BOURDON'S REFACTOR: Les vues pour l'intention ne sont plus liées.
        pollenRecyclerView = findViewById(R.id.captured_pollen_recyclerview)
        captureButtonContainer = findViewById(R.id.capture_button_container)
        captureButton = findViewById(R.id.capture_and_forge_button)
        finishHarvestButton = findViewById(R.id.finish_harvest_button)
        finalChoiceContainer = findViewById(R.id.final_choice_container)
        restartHarvestButton = findViewById(R.id.restart_harvest_button)
        sendToHiveButton = findViewById(R.id.send_to_hive_button)
        Log.d(TAG, "Vues liées avec succès.")
    }

    private fun setupRecyclerView() {
        // BOURDON'S REFACTOR: La logique de l'adapter reste la même, mais son nom a été corrigé dans d'autres fichiers.
        pollenAdapter = PollenPreviewAdapter(emptyList()) { pollenCapture ->
            val report = pollenCapture.report
            val jsonReport = pollenCapture.jsonReport
            if (pollenCapture.status == PollenAnalysisStatus.DONE && report != null && jsonReport != null) {
                val textReport = generateTextReport(report)
                SpecialistReportDialogFragment.newInstance(getString(R.string.specialist_report_dialog_title), textReport, jsonReport)
                    .show(supportFragmentManager, "SpecialistReportDialog")
            }
        }
        pollenRecyclerView.apply {
            layoutManager = LinearLayoutManager(this@ForgeLiveActivity, LinearLayoutManager.HORIZONTAL, false)
            adapter = pollenAdapter
        }
    }

    private fun setupListeners() {
        Log.d(TAG, "Configuration des listeners...")
        facingSwitch.setOnCheckedChangeListener(this)

        // BOURDON'S REFACTOR: Suppression des listeners pour les boutons d'intention.
        // pollenStartCaptureButton.setOnClickListener { viewModel.onStartCaptureRequested() }
        captureButton.setOnClickListener { takePhoto() }
        finishHarvestButton.setOnClickListener { viewModel.onStopHarvesting() }
        restartHarvestButton.setOnClickListener { viewModel.onRestartHarvest() }
        sendToHiveButton.setOnClickListener { viewModel.onSendToHive() }
        Log.d(TAG, "Listeners configurés.")
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    viewModel.uiState.collect { state ->
                        Log.d(TAG, "[UI UPDATE] Nouvel état reçu: ${state.currentStep}")
                        updateUiForState(state)
                    }
                }
                launch {
                    viewModel.navigationEvent.collect {
                        Log.i(TAG, "[NAVIGATION] Événement de navigation reçu. Fermeture de l'activité.")
                        Toast.makeText(this@ForgeLiveActivity, R.string.pollen_save_toast, Toast.LENGTH_SHORT).show()
                        finish()
                    }
                }
            }
        }
    }

    private fun updateUiForState(state: ForgeLiveUiState) {
        if (state.bourdonMessage != null) {
            bourdonDialogueContainer.visibility = View.VISIBLE
            bourdonMessageTextView.text = state.bourdonMessage
            // BOURDON'S REFACTOR: TTS utilise la locale du système.
            TtsService.speak(state.bourdonMessage, Locale.getDefault()) {
                runOnUiThread { viewModel.onBourdonFinishedSpeaking() }
            }
        } else {
            bourdonDialogueContainer.visibility = View.GONE
        }

        // BOURDON'S REFACTOR: Visibilité simplifiée.
        captureButtonContainer.visibility = if (state.currentStep == HarvestStep.USER_CAPTURING_POLLEN) View.VISIBLE else View.GONE
        finalChoiceContainer.visibility = if (state.currentStep == HarvestStep.AWAITING_FINAL_CHOICE || state.currentStep == HarvestStep.SAVING || state.currentStep == HarvestStep.SAVED) View.VISIBLE else View.GONE

        if (state.currentStep == HarvestStep.USER_CAPTURING_POLLEN) {
            finishHarvestButton.visibility = if (state.canFinishHarvest) View.VISIBLE else View.GONE
            captureButton.isEnabled = state.capturedPollen.size < 4
            captureButton.text = if (state.capturedPollen.size >= 4) {
                getString(R.string.pollen_capture_button_full)
            } else {
                getString(R.string.pollen_capture_button_format, state.capturedPollen.size)
            }
        }

        if (state.currentStep == HarvestStep.AWAITING_FINAL_CHOICE || state.currentStep == HarvestStep.SAVING || state.currentStep == HarvestStep.SAVED) {
            val isSaving = state.currentStep == HarvestStep.SAVING
            restartHarvestButton.isEnabled = !isSaving
            sendToHiveButton.isEnabled = !isSaving
        }

        pollenAdapter.updatePollen(state.capturedPollen)
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "[CYCLE DE VIE] onResume")
        bindCameraUseCases()
        viewModel.startInteraction()
    }

    private fun takePhoto() {
        val imageCapture = this.imageCapture ?: return
        if (viewModel.uiState.value.capturedPollen.size >= 4) return
        captureButton.isEnabled = false
        Log.i(TAG, "Déclenchement de la capture photo.")

        imageCapture.takePicture(
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageCapturedCallback() {
                @SuppressLint("UnsafeOptInUsageError")
                override fun onCaptureSuccess(image: ImageProxy) {
                    Log.d(TAG, "Capture réussie. Rotation: ${image.imageInfo.rotationDegrees} degrés.")
                    val rotationDegrees = image.imageInfo.rotationDegrees
                    val bitmap = imageProxyToBitmap(image)
                    image.close()

                    if (bitmap != null) {
                        val rotatedBitmap = rotateBitmap(bitmap, rotationDegrees.toFloat())
                        viewModel.startPollenAnalysis(rotatedBitmap, pollenForge)
                    } else {
                        Log.e(TAG, "Échec de la conversion de ImageProxy en Bitmap.")
                        Toast.makeText(this@ForgeLiveActivity, R.string.pollen_capture_error_toast, Toast.LENGTH_SHORT).show()
                        captureButton.isEnabled = true
                    }
                }
                override fun onError(exception: ImageCaptureException) {
                    Log.e(TAG, "Échec de la capture d'image : ", exception)
                    Toast.makeText(this@ForgeLiveActivity, R.string.pollen_capture_failed_toast, Toast.LENGTH_SHORT).show()
                    captureButton.isEnabled = true
                }
            }
        )
    }

    private fun checkCameraPermissionAndSetup() {
        when {
            ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED -> {
                Log.d(TAG, "Permission caméra déjà accordée.")
                setupCamera()
            }
            else -> {
                Log.d(TAG, "Demande de la permission caméra.")
                requestCameraPermissionLauncher.launch(Manifest.permission.CAMERA)
            }
        }
    }

    private fun setupCamera() {
        Log.d(TAG, "Configuration de la caméra...")
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            cameraProvider = cameraProviderFuture.get()
            bindCameraUseCases()
        }, ContextCompat.getMainExecutor(this))
    }

    @SuppressLint("UnsafeOptInUsageError")
    private fun bindCameraUseCases() {
        val cameraProvider = cameraProvider ?: return
        Log.d(TAG, "Liaison des cas d'usage de la caméra.")
        cameraProvider.unbindAll()
        val cameraSelector = CameraSelector.Builder().requireLensFacing(lensFacing).build()
        val preview = Preview.Builder().build().also { it.setSurfaceProvider(previewView.surfaceProvider) }
        imageCapture = ImageCapture.Builder().setTargetResolution(android.util.Size(1920, 1080)).build()
        try {
            cameraProvider.bindToLifecycle(this, cameraSelector, preview, imageCapture)
            Log.d(TAG, "Cas d'usage liés avec succès.")
        } catch (e: Exception) {
            Log.e(TAG, "La liaison des cas d'usage a échoué", e)
        }
    }

    private fun rotateBitmap(source: Bitmap, angle: Float): Bitmap {
        if (angle == 0f) return source
        val matrix = Matrix()
        matrix.postRotate(angle)
        return Bitmap.createBitmap(source, 0, 0, source.width, source.height, matrix, true)
    }

    @SuppressLint("UnsafeOptInUsageError")
    private fun imageProxyToBitmap(image: ImageProxy): Bitmap? {
        return when (image.format) {
            ImageFormat.YUV_420_888 -> {
                val bitmap = Bitmap.createBitmap(image.width, image.height, Bitmap.Config.ARGB_8888)
                yuvToRgbConverter.yuvToRgb(image.image!!, bitmap)
                bitmap
            }
            ImageFormat.JPEG -> {
                val buffer = image.planes[0].buffer
                val bytes = ByteArray(buffer.remaining())
                buffer.get(bytes)
                BitmapFactory.decodeByteArray(bytes, 0, bytes.size)
            }
            else -> null
        }
    }

    override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {
        lensFacing = if (isChecked) CameraSelector.LENS_FACING_FRONT else CameraSelector.LENS_FACING_BACK
        Log.d(TAG, "Changement de caméra vers: ${if (isChecked) "AVANT" else "ARRIÈRE"}")
        bindCameraUseCases()
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "[CYCLE DE VIE] onPause")
        cameraProvider?.unbindAll()
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "[CYCLE DE VIE] onDestroy")
        cameraExecutor.shutdown()
        TtsService.shutdown()
    }

    private fun generateTextReport(report: PollenAnalysis): String {
        val sb = StringBuilder()
        sb.append(getString(R.string.specialist_report_global_title)).append("\n")
        if (report.globalAnalysis.isEmpty()) {
            sb.append(getString(R.string.specialist_report_no_global)).append("\n")
        } else {
            report.globalAnalysis.forEach { specialistReport ->
                sb.append(getString(R.string.specialist_report_specialist_opinion, specialistReport.specialistName)).append("\n")
                specialistReport.results.take(3).forEach { result ->
                    sb.append(getString(R.string.specialist_report_item, result.label, result.confidence * 100)).append("\n")
                }
            }
        }
        sb.append("\n").append(getString(R.string.specialist_report_objects_title, report.analyzedObjects.size)).append("\n")
        if (report.analyzedObjects.isEmpty()) {
            sb.append(getString(R.string.specialist_report_no_objects)).append("\n")
        } else {
            report.analyzedObjects.forEachIndexed { index, analyzedObject ->
                val mainLabel = analyzedObject.detectedObject.labels.firstOrNull()
                sb.append(getString(R.string.specialist_report_object_item, index + 1, mainLabel?.text ?: getString(R.string.specialist_report_unknown_object), (mainLabel?.confidence ?: 0f) * 100)).append("\n")
                analyzedObject.specialistReports.forEach { specialistReport ->
                    sb.append(getString(R.string.specialist_report_object_specialist_item, specialistReport.specialistName, specialistReport.results.firstOrNull()?.label ?: "N/A")).append("\n")
                }
            }
        }
        return sb.toString()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---

package be.heyman.android.ai.kikko.pollen

import android.app.Application
import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.Constraints
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.model.PollenGrain as DbPollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
// BOURDON'S FIX: La référence à l'ancien IdentificationWorker est supprimée.
// import be.heyman.android.ai.kikko.worker.IdentificationWorker
// BOURDON'S FIX: La nouvelle référence pointe vers le worker unifié.
import be.heyman.android.ai.kikko.worker.ForgeWorker
import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.UUID

enum class HarvestStep {
    IDLE,
    BOURDON_INTRO,
    USER_CAPTURING_POLLEN,
    AWAITING_FINAL_CHOICE,
    SAVING,
    SAVED
}

data class ForgeLiveUiState(
    val currentStep: HarvestStep = HarvestStep.IDLE,
    val userIntent: String = "",
    val capturedPollen: List<PollenCapture> = emptyList(),
    val bourdonMessage: String? = null,
    val canFinishHarvest: Boolean = false
)

class ForgeLiveViewModel(application: Application) : AndroidViewModel(application) {

    private val TAG = "ForgeLiveViewModel"

    private val _uiState = MutableStateFlow(ForgeLiveUiState())
    val uiState = _uiState.asStateFlow()

    private val _navigationEvent = MutableSharedFlow<Unit>()
    val navigationEvent = _navigationEvent.asSharedFlow()

    private val pollenGrainDao = PollenGrainDao(application)
    private val gson = Gson()
    private val workManager = WorkManager.getInstance(application)


    fun startInteraction() {
        if (_uiState.value.currentStep != HarvestStep.IDLE) return
        Log.d(TAG, "[FLUX] Démarrage de l'interaction. Passage à BOURDON_INTRO.")
        _uiState.update {
            it.copy(
                currentStep = HarvestStep.BOURDON_INTRO,
                bourdonMessage = getApplication<Application>().getString(R.string.bourdon_welcome_capture)
            )
        }
    }

    fun onBourdonFinishedSpeaking() {
        _uiState.update {
            val nextStep = when (it.currentStep) {
                HarvestStep.BOURDON_INTRO -> HarvestStep.USER_CAPTURING_POLLEN
                else -> it.currentStep
            }
            Log.d(TAG, "[FLUX] Le Bourdon a fini de parler. Passage à l'état: $nextStep")
            it.copy(currentStep = nextStep, bourdonMessage = null)
        }
    }

    fun startPollenAnalysis(bitmap: Bitmap, pollenForge: PollenForge) {
        if (_uiState.value.capturedPollen.size >= 4) {
            Log.w(TAG, "[ANALYSE] Tentative de capture alors que le maximum (4) est atteint. Ignoré.")
            return
        }

        val newCapture = PollenCapture(bitmap = bitmap)
        _uiState.update { it.copy(capturedPollen = it.capturedPollen + newCapture) }
        Log.i(TAG, "[ANALYSE] Nouvelle capture ajoutée (ID: ${newCapture.id}). Lancement de l'analyse par la PollenForge.")

        viewModelScope.launch {
            val (report, jsonReport) = pollenForge.processImage(bitmap)
            Log.i(TAG, "[ANALYSE] Analyse terminée pour la capture ID: ${newCapture.id}.")

            _uiState.update { currentState ->
                val updatedList = currentState.capturedPollen.map { capture ->
                    if (capture.id == newCapture.id) {
                        capture.copy(status = PollenAnalysisStatus.DONE, report = report, jsonReport = jsonReport)
                    } else {
                        capture
                    }
                }

                val canFinish = updatedList.isNotEmpty()
                val shouldStopCapture = updatedList.size >= 4 && currentState.currentStep == HarvestStep.USER_CAPTURING_POLLEN

                if (shouldStopCapture) {
                    Log.d(TAG, "[FLUX] Maximum de captures atteint. Passage à AWAITING_FINAL_CHOICE.")
                    currentState.copy(
                        capturedPollen = updatedList,
                        currentStep = HarvestStep.AWAITING_FINAL_CHOICE,
                        bourdonMessage = getApplication<Application>().getString(R.string.bourdon_harvest_complete),
                        canFinishHarvest = canFinish
                    )
                } else {
                    currentState.copy(
                        capturedPollen = updatedList,
                        canFinishHarvest = canFinish
                    )
                }
            }
        }
    }

    fun onStopHarvesting() {
        Log.d(TAG, "[FLUX] L'utilisateur a terminé la récolte manuellement. Passage à AWAITING_FINAL_CHOICE.")
        _uiState.update {
            it.copy(
                currentStep = HarvestStep.AWAITING_FINAL_CHOICE,
                bourdonMessage = getApplication<Application>().getString(R.string.bourdon_harvest_complete_alt)
            )
        }
    }

    fun onRestartHarvest() {
        Log.i(TAG, "[FLUX] Réinitialisation de la session de récolte.")
        _uiState.value = ForgeLiveUiState()
        startInteraction()
    }

    fun onSendToHive() {
        val currentState = _uiState.value
        if (currentState.capturedPollen.isEmpty() || currentState.currentStep == HarvestStep.SAVING) return

        viewModelScope.launch {
            Log.d(TAG, "[FLUX] Envoi du pollen à la Ruche. Passage à SAVING.")
            _uiState.update { it.copy(currentStep = HarvestStep.SAVING, bourdonMessage = getApplication<Application>().getString(R.string.bourdon_save_pollen)) }

            val savedImagePaths = savePollenImages(currentState.capturedPollen)

            if (savedImagePaths.isEmpty()) {
                Log.e(TAG, "[FLUX] Erreur critique lors de la sauvegarde des images. Le processus est interrompu.")
                _uiState.update { it.copy(currentStep = HarvestStep.AWAITING_FINAL_CHOICE, bourdonMessage = getApplication<Application>().getString(R.string.bourdon_save_error)) }
                return@launch
            }

            val aggregatedReport = aggregateJsonReports(currentState.capturedPollen)

            val pollenToSave = DbPollenGrain(
                userIntent = null,
                pollenImagePaths = savedImagePaths,
                swarmAnalysisReportJson = aggregatedReport,
                status = PollenStatus.RAW
            )

            Log.i(TAG, "CONTENU DU RAPPORT JSON SAUVEGARDÉ :\n$aggregatedReport")

            pollenGrainDao.insert(pollenToSave)
            Log.i(TAG, "Nouveau PollenGrain (ID: ${pollenToSave.id}) inséré dans la base de données.")

            // BOURDON'S FIX: Appel à la nouvelle fonction qui utilise le bon worker.
            launchForgeWorker()

            _uiState.update { it.copy(currentStep = HarvestStep.SAVED, bourdonMessage = getApplication<Application>().getString(R.string.bourdon_save_success)) }

            kotlinx.coroutines.delay(2000)
            _navigationEvent.emit(Unit)
        }
    }

    // BOURDON'S FIX: La fonction est renommée et corrigée pour utiliser ForgeWorker.
    private fun launchForgeWorker() {
        Log.d(TAG, "Lancement du ForgeWorker.")

        val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
        val requiresCharging = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_CHARGING, false)
        val requiresIdle = prefs.getBoolean(ToolsDialogFragment.KEY_REQUIRE_IDLE, false)

        val constraints = Constraints.Builder()
            .setRequiresCharging(requiresCharging)
            .setRequiresDeviceIdle(requiresIdle)
            .build()

        val forgeRequest = OneTimeWorkRequestBuilder<ForgeWorker>()
            .setConstraints(constraints)
            .build()

        workManager.beginUniqueWork(
            "PollenForgeChain",
            ExistingWorkPolicy.APPEND_OR_REPLACE,
            forgeRequest
        ).enqueue()

        Log.i(TAG, "ForgeWorker mis en file d'attente avec succès.")
    }

    private suspend fun savePollenImages(captures: List<PollenCapture>): List<String> = withContext(Dispatchers.IO) {
        val imagePaths = mutableListOf<String>()
        val pollenDir = File(getApplication<Application>().filesDir, "pollen_captures")
        if (!pollenDir.exists()) pollenDir.mkdirs()
        Log.d(TAG, "Sauvegarde de ${captures.size} images dans le répertoire: ${pollenDir.absolutePath}")

        captures.forEach { capture ->
            val fileName = "pollen_${UUID.randomUUID()}.png"
            val file = File(pollenDir, fileName)
            try {
                FileOutputStream(file).use { out ->
                    capture.bitmap.compress(Bitmap.CompressFormat.PNG, 90, out)
                    imagePaths.add(file.absolutePath)
                }
            } catch (e: IOException) {
                Log.e("ForgeLiveViewModel", "Erreur lors de la sauvegarde de l'image du pollen: ${file.absolutePath}", e)
                return@withContext emptyList<String>()
            }
        }
        Log.i(TAG, "${imagePaths.size} images sauvegardées avec succès.")
        return@withContext imagePaths
    }

    private fun aggregateJsonReports(captures: List<PollenCapture>): String {
        val allReports = captures.mapNotNull { capture ->
            capture.jsonReport?.let { gson.fromJson(it, Map::class.java) }
        }
        return gson.toJson(mapOf("reports" to allReports))
    }

    fun reset() {
        Log.i(TAG, "ViewModel réinitialisé à son état initial.")
        _uiState.value = ForgeLiveUiState()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/ForgeLiveViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/LivePollenHarvester.kt ---

package be.heyman.android.ai.kikko.pollen

import android.annotation.SuppressLint
import androidx.camera.core.ImageProxy
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import java.util.concurrent.atomic.AtomicInteger

/**
 * Chef d'orchestre qui gère la synchronisation de plusieurs processeurs.
 */
class LivePollenHarvester {

    private val scoutBees = mutableListOf<VisionProcessorBase<*>>()
    private var isShutdown = false

    var isTextRecognitionEnabled = false
    var isBarcodeScanningEnabled = false
    var isObjectDetectionEnabled = false

    @Synchronized
    fun addScoutBee(bee: VisionProcessorBase<*>) {
        scoutBees.add(bee)
    }

    @SuppressLint("UnsafeOptInUsageError")
    @Synchronized
    fun processImageProxy(
        imageProxy: ImageProxy,
        graphicOverlay: GraphicOverlay,
        onAllWorkDone: () -> Unit
    ) {
        if (isShutdown) {
            imageProxy.close()
            return
        }

        val activeProcessors = mutableListOf<VisionProcessorBase<*>>()
        if (isTextRecognitionEnabled) {
            scoutBees.filterIsInstance<PollenTextRecognitionProcessor>().firstOrNull()?.let { activeProcessors.add(it) }
        }
        if (isBarcodeScanningEnabled) {
            scoutBees.filterIsInstance<PollenBarcodeScannerProcessor>().firstOrNull()?.let { activeProcessors.add(it) }
        }
        if (isObjectDetectionEnabled) {
            scoutBees.filterIsInstance<PollenObjectDetectorProcessor>().firstOrNull()?.let { activeProcessors.add(it) }
        }

        if (activeProcessors.isEmpty()) {
            imageProxy.close()
            onAllWorkDone()
            return
        }

        val remainingTasks = AtomicInteger(activeProcessors.size)
        val onFinished = {
            if (remainingTasks.decrementAndGet() == 0) {
                imageProxy.close()
                onAllWorkDone()
            }
        }

        graphicOverlay.clear()

        activeProcessors.forEach { processor ->
            processor.processImageProxy(imageProxy, graphicOverlay, onFinished)
        }
    }

    @Synchronized
    fun stop() {
        isShutdown = true
        scoutBees.forEach { it.stop() }
        scoutBees.clear()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/LivePollenHarvester.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenAnalysisStatus.kt ---

package be.heyman.android.ai.kikko.pollen

/**
 * Définit les différents états possibles pour l'analyse d'un grain de pollen
 * pendant la phase de capture en direct.
 */
enum class PollenAnalysisStatus {
    /**
     * L'analyse par les Abeilles Spécialistes est en cours.
     */
    PROCESSING,

    /**
     * L'analyse est terminée avec succès et un rapport est disponible.
     */
    DONE,

    /**
     * Une erreur est survenue durant l'analyse.
     */
    ERROR
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenAnalysisStatus.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.barcode.common.Barcode

class PollenBarcodeGraphic(
    overlay: GraphicOverlay,
    private val barcode: Barcode?
) : GraphicOverlay.Graphic(overlay) {

    private var rectPaint: Paint = Paint().apply {
        color = BOX_COLOR
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
    }

    private var barcodePaint: Paint = Paint().apply {
        color = TEXT_COLOR
        textSize = TEXT_SIZE
    }

    override fun draw(canvas: Canvas) {
        if (barcode == null || barcode.boundingBox == null) return

        val rect = RectF(barcode.boundingBox)

        // BOURDON'S FIX: Utilisation de overlay.translateX et overlay.translateY
        val mappedRect = RectF(
            overlay.translateX(rect.left),
            overlay.translateY(rect.top),
            overlay.translateX(rect.right),
            overlay.translateY(rect.bottom)
        )
        canvas.drawRect(mappedRect, rectPaint)

        barcode.rawValue?.let {
            canvas.drawText(it, mappedRect.left, mappedRect.bottom + TEXT_SIZE, barcodePaint)
        }
    }

    companion object {
        private const val BOX_COLOR = Color.CYAN
        private const val TEXT_COLOR = Color.CYAN
        private const val STROKE_WIDTH = 5.0f
        private const val TEXT_SIZE = 40.0f
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeScannerProcessor.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import com.google.android.gms.tasks.Task
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage

/**
 * Processeur spécialisé dans la détection de codes-barres.
 */
class PollenBarcodeScannerProcessor(context: Context) : VisionProcessorBase<List<Barcode>>(context) {

    private val barcodeScanner: BarcodeScanner

    init {
        val options = BarcodeScannerOptions.Builder()
            .setBarcodeFormats(
                Barcode.FORMAT_QR_CODE,
                Barcode.FORMAT_AZTEC,
                Barcode.FORMAT_EAN_13,
                Barcode.FORMAT_UPC_A
            )
            .build()
        barcodeScanner = BarcodeScanning.getClient(options)
    }

    override fun stop() {
        super.stop()
        barcodeScanner.close()
    }

    override fun detectInImage(image: InputImage): Task<List<Barcode>> {
        return barcodeScanner.process(image)
    }

    override fun onSuccess(results: List<Barcode>, graphicOverlay: GraphicOverlay) {
        if (results.isEmpty()) {
            return
        }
        for (barcode in results) {
            graphicOverlay.add(PollenBarcodeGraphic(graphicOverlay, barcode))
        }
    }

    override fun onFailure(e: Exception) {
        Log.e(TAG, "La détection de code-barres a échoué.", e)
    }

    companion object {
        private const val TAG = "BarcodeScannerProc"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenBarcodeScannerProcessor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenCapture.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Bitmap
import java.util.UUID

/**
 * Représente un grain de pollen individuel pendant la phase de capture en direct.
 * C'est un objet de l'interface utilisateur (UI model) qui contient le bitmap pour
 * l'affichage et les résultats d'analyse en temps réel.
 *
 * Cet objet est éphémère et sera transformé en un 'PollenGrain' persistant
 * (du package model) au moment de la sauvegarde.
 *
 * @param id Un identifiant unique pour suivre le grain dans l'UI.
 * @param bitmap L'image capturée, utilisée pour l'affichage et l'analyse.
 * @param status L'état actuel de l'analyse pour ce grain.
 * @param report Le rapport d'analyse structuré une fois l'analyse terminée.
 * @param jsonReport Le rapport d'analyse complet en format JSON.
 */
data class PollenCapture(
    val id: String = UUID.randomUUID().toString(),
    val bitmap: Bitmap,
    var status: PollenAnalysisStatus = PollenAnalysisStatus.PROCESSING,
    var report: PollenAnalysis? = null,
    var jsonReport: String? = null
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenCapture.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenForge.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import com.google.gson.GsonBuilder
import com.google.mlkit.common.model.LocalModel
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.label.ImageLabel
import com.google.mlkit.vision.label.ImageLabeler
import com.google.mlkit.vision.label.ImageLabeling
import com.google.mlkit.vision.label.custom.CustomImageLabelerOptions
import com.google.mlkit.vision.label.defaults.ImageLabelerOptions
import com.google.mlkit.vision.objects.DetectedObject
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.tasks.await
import java.io.Closeable

/**
 * Orchestre une analyse multi-niveaux avec une escouade complète de classifieurs spécialisés,
 * un OCR et un scanner de codes-barres.
 * BOURDON'S REFACTOR: Cette version est maintenant robuste et charge les modèles séquentiellement.
 */
class PollenForge(private val context: Context) {

    private val TAG = "PollenForge"

    private val specialistModelPaths = mapOf(
        "Défaut ML Kit" to "DEFAULT", // Cas spécial pour le modèle par défaut
        "Labeler Objet" to "object_labeler.tflite",
        "Plantes" to "aiy-tflite-vision-classifier-plants-v1-v3.tflite",
        "Insectes" to "aiy-tflite-vision-classifier-insects-v1-v3.tflite",
        "Oiseaux" to "aiy-tflite-vision-classifier-birds-v1-v3.tflite",
        "Nourriture" to "aiy-tflite-vision-classifier-food-v1-v1.tflite",
        "EfficientNet-L0" to "efficientnet_lite0.tflite",
        "EfficientNet-L1" to "efficientnet_lite1_int8_2.tflite",
        "EfficientNet-L2" to "efficientnet_lite2_int8_2.tflite",
        "MobileNetV1" to "mobilenet_v1_1.0_224_quantized_1_metadata_1.tflite"
    )

    private fun createImageLabeler(modelPath: String): ImageLabeler {
        return if (modelPath == "DEFAULT") {
            ImageLabeling.getClient(ImageLabelerOptions.DEFAULT_OPTIONS)
        } else {
            val localModel = LocalModel.Builder().setAssetFilePath(modelPath).build()
            val options = CustomImageLabelerOptions.Builder(localModel)
                .setConfidenceThreshold(0.1f)
                .setMaxResultCount(4)
                .build()
            ImageLabeling.getClient(options)
        }
    }

    suspend fun processImage(bitmap: Bitmap): Pair<PollenAnalysis, String> = coroutineScope {
        val highResImage = InputImage.fromBitmap(bitmap, 0)
        var objectDetector: com.google.mlkit.vision.objects.ObjectDetector? = null
        var textRecognizer: com.google.mlkit.vision.text.TextRecognizer? = null
        var barcodeScanner: BarcodeScanner? = null
        val closableClients = mutableListOf<Closeable>()

        try {
            // --- Étape 1: Détection d'objets ---
            val objectDetectorOptions = ObjectDetectorOptions.Builder()
                .setDetectorMode(ObjectDetectorOptions.SINGLE_IMAGE_MODE)
                .enableMultipleObjects().enableClassification().build()
            objectDetector = ObjectDetection.getClient(objectDetectorOptions)
            closableClients.add(objectDetector)
            val detectedObjects = objectDetector.process(highResImage).await()
            Log.d(TAG, "Phase 1: ${detectedObjects.size} objets détectés.")

            // --- Étape 2: Analyse Globale (Spécialistes Séquentiels + OCR + Barcode) ---
            val globalSpecialistResults = mutableListOf<Pair<String, List<ImageLabel>>>()
            for ((name, path) in specialistModelPaths) {
                Log.d(TAG, "Analyse globale avec le spécialiste: $name")
                val labeler = createImageLabeler(path)
                try {
                    val labels = labeler.process(highResImage).await()
                    globalSpecialistResults.add(Pair(name, labels))
                } finally {
                    labeler.close() // Libère les ressources immédiatement
                }
            }

            textRecognizer = TextRecognition.getClient(JapaneseTextRecognizerOptions.Builder().build())
            closableClients.add(textRecognizer)
            barcodeScanner = BarcodeScanning.getClient()
            closableClients.add(barcodeScanner)

            val globalOcrResult = textRecognizer.process(highResImage).await()
            val barcodeResults = barcodeScanner.process(highResImage).await()
            Log.d(TAG, "Phase 2: Analyse globale terminée.")

            // --- Étape 3: Analyse par Objet (reportée pour la stabilité) ---
            // Pour l'instant, on se concentre sur la stabilisation de l'analyse globale.
            Log.d(TAG, "Phase 3: Analyse par objet désactivée pour cette version.")
            val analyzedObjectsResults = emptyList<AnalyzedObject>()

            // --- Étape 4: Construction des rapports ---
            val pollenAnalysisReport = PollenAnalysis(
                imageWidth = bitmap.width,
                imageHeight = bitmap.height,
                globalAnalysis = globalSpecialistResults.map { SpecialistReport(it.first, it.second.toClassifierResults()) }.filter { it.results.isNotEmpty() },
                analyzedObjects = analyzedObjectsResults,
                structuredOcrResult = globalOcrResult.toStructuredResult(),
                barcodeResults = barcodeResults.map { BarcodeResult(it.displayValue, it.format.toString()) }
            )

            val jsonReport = generateJsonReport(bitmap, barcodeResults, globalOcrResult, detectedObjects, globalSpecialistResults)

            return@coroutineScope Pair(pollenAnalysisReport, jsonReport)

        } finally {
            // Assure que tous les clients principaux sont fermés
            closableClients.forEach {
                try { it.close() } catch (e: Exception) { Log.e(TAG, "Erreur lors de la fermeture d'un client ML Kit.", e) }
            }
        }
    }

    private fun List<ImageLabel>.toClassifierResults(): List<ClassifierResult> {
        return this.map { ClassifierResult(it.text, it.confidence) }
    }

    private fun Text.toStructuredResult(): List<OcrBlock> {
        return this.textBlocks.map { block ->
            OcrBlock(
                text = block.text,
                boundingBox = block.boundingBox,
                lines = block.lines.map { line ->
                    OcrLine(
                        text = line.text,
                        boundingBox = line.boundingBox,
                        elements = line.elements.map { element ->
                            OcrElement(
                                text = element.text,
                                boundingBox = element.boundingBox
                            )
                        }
                    )
                }
            )
        }
    }

    private fun generateJsonReport(
        bitmap: Bitmap,
        barcodes: List<Barcode>,
        ocrResult: Text,
        detectedObjects: List<DetectedObject>,
        specialistResults: List<Pair<String, List<ImageLabel>>>
    ): String {
        val gson = GsonBuilder().setPrettyPrinting().create()
        val reportMap = mutableMapOf<String, Any>()

        reportMap["image_dimensions"] = mapOf("width" to bitmap.width, "height" to bitmap.height)
        reportMap["barcode_scanner_results"] = barcodes.map { mapOf("format" to it.format, "raw_value" to it.rawValue) }
        reportMap["ocr_results"] = mapOf("full_text" to ocrResult.text)
        reportMap["object_detection_results"] = detectedObjects.map { obj ->
            mapOf(
                "labels" to obj.labels.map { label -> mapOf("text" to label.text, "confidence" to label.confidence) }
            )
        }
        reportMap["global_classification_results"] = specialistResults.associate { (name, labels) ->
            name to labels.map { mapOf("label" to it.text, "confidence" to it.confidence) }
        }

        return gson.toJson(reportMap)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenForge.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenGrain.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Bitmap
import java.util.UUID

/**
 * Représente un grain de pollen individuel avec son image, son état et son rapport.
 * BOURDON'S REFACTOR: La classe a été enrichie pour suivre le statut de l'analyse
 * et conserver les rapports générés par la PollenForge.
 */
data class PollenGrain(
    val id: String = UUID.randomUUID().toString(),
    val bitmap: Bitmap,
    val status: PollenAnalysisStatus = PollenAnalysisStatus.PROCESSING,
    val report: PollenAnalysis? = null,
    val jsonReport: String? = null
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenGrain.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectDetectorProcessor.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import com.google.android.gms.tasks.Task
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.objects.DetectedObject
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.ObjectDetector
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions

/**
 * Un processeur qui utilise le DÉTECTEUR D'OBJETS PAR DÉFAUT de ML Kit.
 * C'est la version corrigée qui est capable de fournir des boîtes englobantes.
 */
class PollenObjectDetectorProcessor(context: Context) : VisionProcessorBase<List<DetectedObject>>(context) {

    private val objectDetector: ObjectDetector

    init {
        // Configure l'ObjectDetector pour le mode streaming (caméra en direct),
        // en activant la détection de plusieurs objets et leur classification.
        val options = ObjectDetectorOptions.Builder()
            .setDetectorMode(ObjectDetectorOptions.STREAM_MODE)
            .enableMultipleObjects()
            .enableClassification()
            .build()
        objectDetector = ObjectDetection.getClient(options)
    }

    override fun stop() {
        super.stop()
        objectDetector.close()
    }

    override fun detectInImage(image: InputImage): Task<List<DetectedObject>> {
        return objectDetector.process(image)
    }

    override fun onSuccess(results: List<DetectedObject>, graphicOverlay: GraphicOverlay) {
        for (detectedObject in results) {
            graphicOverlay.add(PollenObjectGraphic(graphicOverlay, detectedObject))
        }
    }

    override fun onFailure(e: Exception) {
        Log.e(TAG, "La détection d'objet a échoué.", e)
    }

    companion object {
        private const val TAG = "ObjectDetectorProcessor"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectDetectorProcessor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.objects.DetectedObject
import java.util.Locale
import kotlin.math.max
import kotlin.math.min

/**
 * Objet graphique pour dessiner les objets détectés et leurs étiquettes sur la GraphicOverlay.
 */
class PollenObjectGraphic(
    overlay: GraphicOverlay,
    private val detectedObject: DetectedObject
) : GraphicOverlay.Graphic(overlay) {

    private val boxPaint: Paint = Paint().apply {
        color = OBJECT_COLOR
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
    }

    private val textPaint: Paint = Paint().apply {
        color = Color.WHITE
        textSize = TEXT_SIZE
    }

    private val labelBackgroundPaint: Paint = Paint().apply {
        color = OBJECT_COLOR
        style = Paint.Style.FILL
    }

    override fun draw(canvas: Canvas) {
        // La boîte de délimitation fournie par ML Kit
        val rect = RectF(detectedObject.boundingBox)

        // Traduction des coordonnées pour l'affichage
        val mappedRect = RectF(
            overlay.translateX(rect.left),
            overlay.translateY(rect.top),
            overlay.translateX(rect.right),
            overlay.translateY(rect.bottom)
        )

        // Dessine la boîte
        canvas.drawRect(mappedRect, boxPaint)

        // Dessine la première étiquette trouvée (la plus probable) au-dessus de la boîte.
        detectedObject.labels.firstOrNull()?.let { label ->
            val text = "${label.text.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }} (${"%.0f".format(label.confidence * 100)}%)"
            val textWidth = textPaint.measureText(text)
            val textHeight = TEXT_SIZE

            // Dessine un fond pour le texte pour une meilleure lisibilité
            canvas.drawRect(
                mappedRect.left,
                mappedRect.top - textHeight - (STROKE_WIDTH * 2),
                mappedRect.left + textWidth + (STROKE_WIDTH * 2),
                mappedRect.top,
                labelBackgroundPaint
            )

            // Dessine le texte
            canvas.drawText(
                text,
                mappedRect.left + STROKE_WIDTH,
                mappedRect.top - STROKE_WIDTH,
                textPaint
            )
        }
    }

    companion object {
        private const val OBJECT_COLOR = Color.MAGENTA // Magenta pour bien se distinguer
        private const val TEXT_SIZE = 40.0f
        private const val STROKE_WIDTH = 5.0f
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenObjectGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenPreviewAdapter.kt ---

package be.heyman.android.ai.kikko.pollen

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R

/**
 * BOURDON'S REFACTOR: L'adaptateur gère maintenant l'affichage des `PollenCapture`
 * et les clics sur les items terminés.
 *
 * @param pollenCaptures La liste des pollens (modèle UI) à afficher.
 * @param onPollenClick Le callback à exécuter lorsqu'un grain de pollen analysé est cliqué.
 */
class PollenPreviewAdapter(
    private var pollenCaptures: List<PollenCapture>,
    private val onPollenClick: (PollenCapture) -> Unit
) : RecyclerView.Adapter<PollenPreviewAdapter.PollenViewHolder>() {

    class PollenViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.pollen_preview_imageview)
        val progressIndicator: View = view.findViewById(R.id.pollen_progress_indicator)
        val doneIcon: View = view.findViewById(R.id.pollen_done_icon)
        val removeButton: View = view.findViewById(R.id.pollen_remove_button)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PollenViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_pollen_preview, parent, false)
        return PollenViewHolder(view)
    }

    override fun onBindViewHolder(holder: PollenViewHolder, position: Int) {
        val capture = pollenCaptures[position]
        holder.imageView.setImageBitmap(capture.bitmap)
        // La logique du bouton de suppression est pour l'instant masquée.
        holder.removeButton.visibility = View.GONE

        when (capture.status) {
            PollenAnalysisStatus.PROCESSING -> {
                holder.progressIndicator.visibility = View.VISIBLE
                holder.doneIcon.visibility = View.GONE
                holder.itemView.isClickable = false
            }
            PollenAnalysisStatus.DONE -> {
                holder.progressIndicator.visibility = View.GONE
                holder.doneIcon.visibility = View.VISIBLE
                holder.itemView.isClickable = true
                holder.itemView.setOnClickListener { onPollenClick(capture) }
            }
            PollenAnalysisStatus.ERROR -> {
                holder.progressIndicator.visibility = View.GONE
                holder.doneIcon.visibility = View.GONE // Idéalement, afficher une icône d'erreur ici.
                holder.itemView.isClickable = false
            }
        }
    }

    override fun getItemCount() = pollenCaptures.size

    fun updatePollen(newCaptures: List<PollenCapture>) {
        this.pollenCaptures = newCaptures
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenPreviewAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenReport.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Rect
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.objects.DetectedObject

/**
 * Contient le résultat d'un classifieur : une étiquette et sa confiance.
 */
data class ClassifierResult(val label: String, val confidence: Float)

/**
 * Contient le rapport complet d'un spécialiste (ex: "Plantes", "Oiseaux").
 */
data class SpecialistReport(val specialistName: String, val results: List<ClassifierResult>)

/**
 * Représente un objet détecté qui a été analysé en profondeur.
 * Contient l'objet original et tous les rapports des spécialistes le concernant.
 */
data class AnalyzedObject(
    val detectedObject: DetectedObject,
    val specialistReports: List<SpecialistReport>
)

/**
 * Contient les informations extraites d'un code-barres.
 */
data class BarcodeResult(
    val displayValue: String?,
    val format: String
)

// BOURDON'S FIX: Ajout de structures de données pour un rapport OCR détaillé.
/**
 * Représente un mot ou un élément de texte reconnu par l'OCR.
 */
data class OcrElement(
    val text: String,
    val boundingBox: Rect?
)

/**
 * Représente une ligne de texte reconnue par l'OCR.
 */
data class OcrLine(
    val text: String,
    val boundingBox: Rect?,
    val elements: List<OcrElement>
)

/**
 * Représente un bloc de texte (paragraphe) reconnu par l'OCR.
 */
data class OcrBlock(
    val text: String,
    val boundingBox: Rect?,
    val lines: List<OcrLine>
)


/**
 * Le rapport d'analyse final et complet de la Forge.
 */
data class PollenAnalysis(
    val imageWidth: Int,
    val imageHeight: Int,
    val globalAnalysis: List<SpecialistReport>, // Analyse sur l'image entière
    val analyzedObjects: List<AnalyzedObject>, // Analyse par objet
    // BOURDON'S FIX: Remplacement de la chaîne de caractères simple par une structure hiérarchique.
    val structuredOcrResult: List<OcrBlock>,
    val barcodeResults: List<BarcodeResult>
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenReport.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.text.Text

class PollenTextGraphic(
    overlay: GraphicOverlay,
    private val text: Text
) : GraphicOverlay.Graphic(overlay) {

    private val textPaint: Paint = Paint().apply {
        color = TEXT_COLOR
        textSize = TEXT_SIZE
        textAlign = Paint.Align.LEFT
    }

    private val rectPaint: Paint = Paint().apply {
        color = BOX_COLOR
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
    }

    override fun draw(canvas: Canvas) {
        for (block in text.textBlocks) {
            for (line in block.lines) {
                if (line.boundingBox != null) {
                    val rect = RectF(line.boundingBox)
                    // BOURDON'S FIX: Utilisation de overlay.translateX et overlay.translateY
                    canvas.drawRect(
                        overlay.translateX(rect.left),
                        overlay.translateY(rect.top),
                        overlay.translateX(rect.right),
                        overlay.translateY(rect.bottom),
                        rectPaint
                    )

                    canvas.drawText(
                        line.text,
                        overlay.translateX(rect.left),
                        overlay.translateY(rect.bottom),
                        textPaint
                    )
                }
            }
        }
    }

    companion object {
        private const val TEXT_COLOR = Color.WHITE
        private const val BOX_COLOR = Color.GREEN
        private const val TEXT_SIZE = 45.0f
        private const val STROKE_WIDTH = 5.0f
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextRecognitionProcessor.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.util.Log
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import be.heyman.android.ai.kikko.pollen.vision.VisionProcessorBase
import com.google.android.gms.tasks.Task
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.TextRecognizer
// BOURDON'S FIX: Importation nécessaire pour les options japonaises.
import com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions

/**
 * Processeur spécialisé dans la reconnaissance de texte.
 * Cette version est configurée pour le japonais.
 */
class PollenTextRecognitionProcessor(
    context: Context
) : VisionProcessorBase<Text>(context) {

    // BOURDON'S FIX: On remplace les options par défaut par les options japonaises.
    private val textRecognizer: TextRecognizer =
        TextRecognition.getClient(JapaneseTextRecognizerOptions.Builder().build())

    override fun stop() {
        super.stop()
        textRecognizer.close()
    }

    override fun detectInImage(image: InputImage): Task<Text> {
        return textRecognizer.process(image)
    }

    override fun onSuccess(results: Text, graphicOverlay: GraphicOverlay) {
        graphicOverlay.add(PollenTextGraphic(graphicOverlay, results))
    }

    override fun onFailure(e: Exception) {
        Log.w(TAG, "La reconnaissance de texte a échoué.$e")
    }

    companion object {
        private const val TAG = "TextRecProcessor"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/PollenTextRecognitionProcessor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SpecialistReportDialogFragment.kt ---

package be.heyman.android.ai.kikko.pollen

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import com.google.android.material.switchmaterial.SwitchMaterial

class SpecialistReportDialogFragment : DialogFragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.dialog_specialist_report, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val titleTextView: TextView = view.findViewById(R.id.dialog_title)
        val reportTextView: TextView = view.findViewById(R.id.report_content_textview)
        val formatSwitch: SwitchMaterial = view.findViewById(R.id.format_switch)

        val specialistName = requireArguments().getString(ARG_SPECIALIST_NAME)
        val textReport = requireArguments().getString(ARG_TEXT_REPORT)
        val jsonReport = requireArguments().getString(ARG_JSON_REPORT)

        titleTextView.text = "Rapport de l'Abeille : $specialistName"

        // Initial display
        reportTextView.text = textReport
        formatSwitch.text = "Voir en JSON"

        formatSwitch.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                reportTextView.text = jsonReport
                formatSwitch.text = "Voir en Texte"
            } else {
                reportTextView.text = textReport
                formatSwitch.text = "Voir en JSON"
            }
        }
    }

    companion object {
        private const val ARG_SPECIALIST_NAME = "specialist_name"
        private const val ARG_TEXT_REPORT = "text_report"
        private const val ARG_JSON_REPORT = "json_report"

        fun newInstance(specialistName: String, textReport: String, jsonReport: String): SpecialistReportDialogFragment {
            val args = Bundle().apply {
                putString(ARG_SPECIALIST_NAME, specialistName)
                putString(ARG_TEXT_REPORT, textReport)
                putString(ARG_JSON_REPORT, jsonReport)
            }
            val fragment = SpecialistReportDialogFragment()
            fragment.arguments = args
            return fragment
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SpecialistReportDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SubtleObjectGraphic.kt ---

package be.heyman.android.ai.kikko.pollen

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.RectF
import be.heyman.android.ai.kikko.pollen.vision.GraphicOverlay
import com.google.mlkit.vision.objects.DetectedObject

class SubtleObjectGraphic(
    overlay: GraphicOverlay,
    private val detectedObject: DetectedObject
) : GraphicOverlay.Graphic(overlay) {

    private val boxPaint: Paint = Paint().apply {
        color = Color.argb(100, 0, 255, 0)
        style = Paint.Style.FILL
    }

    private val textPaint: Paint = Paint().apply {
        color = Color.WHITE
        textSize = 35.0f
        textAlign = Paint.Align.CENTER
    }

    override fun draw(canvas: Canvas) {
        val rect = RectF(detectedObject.boundingBox)

        // BOURDON'S FIX: Utilisation de overlay.translateX et overlay.translateY
        val mappedRect = RectF(
            overlay.translateX(rect.left),
            overlay.translateY(rect.top),
            overlay.translateX(rect.right),
            overlay.translateY(rect.bottom)
        )
        canvas.drawRect(mappedRect, boxPaint)

        detectedObject.labels.firstOrNull()?.let { label ->
            canvas.drawText(
                label.text,
                mappedRect.centerX(),
                mappedRect.centerY() + 15,
                textPaint
            )
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/SubtleObjectGraphic.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/YuvToRgbConverter.kt ---

package be.heyman.android.ai.kikko.pollen

import android.content.Context
import android.graphics.Bitmap
import android.graphics.ImageFormat
import android.graphics.Rect
import android.media.Image
import android.renderscript.Allocation
import android.renderscript.Element
import android.renderscript.RenderScript
import android.renderscript.ScriptIntrinsicYuvToRGB
import android.renderscript.Type
import java.nio.ByteBuffer

/**
 * Classe utilitaire pour convertir un objet Image au format YUV_420_888 en un bitmap RGB.
 *
 * NOTE : Cette implémentation est une adaptation standard pour gérer les conversions d'images
 * de la caméra et est nécessaire pour que les modèles ML puissent traiter les captures.
 */
class YuvToRgbConverter(context: Context) {
    private val rs = RenderScript.create(context)
    private val scriptYuvToRgb = ScriptIntrinsicYuvToRGB.create(rs, Element.U8_4(rs))

    // Tampon pour les données YUV, réutilisé pour éviter des allocations répétées.
    private var yuvBuffer: ByteBuffer? = null
    private var yuvBufferSize = 0

    // Allocations RenderScript pour l'entrée (YUV) et la sortie (Bitmap RGB).
    private var allocationIn: Allocation? = null
    private var allocationOut: Allocation? = null

    @Synchronized
    fun yuvToRgb(image: Image, output: Bitmap) {
        val imageWidth = image.width
        val imageHeight = image.height

        // S'assurer que le tampon YUV est assez grand.
        if (yuvBufferSize < imageWidth * imageHeight * ImageFormat.getBitsPerPixel(ImageFormat.YUV_420_888) / 8) {
            yuvBufferSize = imageWidth * imageHeight * ImageFormat.getBitsPerPixel(ImageFormat.YUV_420_888) / 8
            yuvBuffer = ByteBuffer.allocateDirect(yuvBufferSize)
        }
        yuvBuffer!!.rewind()

        // Copier les données des 3 plans (Y, U, V) de l'image dans notre tampon.
        imageToByteBuffer(image.planes, yuvBuffer!!)

        // Créer les allocations RenderScript si elles n'existent pas ou si la taille a changé.
        if (allocationIn == null) {
            val yuvType = Type.Builder(rs, Element.U8(rs)).setX(yuvBufferSize)
            allocationIn = Allocation.createTyped(rs, yuvType.create(), Allocation.USAGE_SCRIPT)
            val rgbaType = Type.Builder(rs, Element.RGBA_8888(rs)).setX(imageWidth).setY(imageHeight)
            allocationOut = Allocation.createTyped(rs, rgbaType.create(), Allocation.USAGE_SCRIPT)
        }

        // Copier les données du tampon vers l'allocation d'entrée.
        allocationIn!!.copyFrom(yuvBuffer!!.array())

        // Configurer les allocations pour le script de conversion.
        scriptYuvToRgb.setInput(allocationIn)
        scriptYuvToRgb.forEach(allocationOut)

        // Copier le résultat de la conversion dans le bitmap de sortie.
        allocationOut!!.copyTo(output)
    }

    private fun imageToByteBuffer(planes: Array<Image.Plane>, yuvBuffer: ByteBuffer) {
        val yPlane = planes[0]
        val uPlane = planes[1]
        val vPlane = planes[2]

        val yBuffer = yPlane.buffer
        val uBuffer = uPlane.buffer
        val vBuffer = vPlane.buffer
        yBuffer.rewind()
        uBuffer.rewind()
        vBuffer.rewind()

        val ySize = yBuffer.remaining()
        var position = 0

        // Copier le plan Y
        yuvBuffer.put(yBuffer)
        position += ySize

        val vRowStride = vPlane.rowStride
        val uRowStride = uPlane.rowStride
        val vPixelStride = vPlane.pixelStride
        val uPixelStride = uPlane.pixelStride

        // Copier les plans U et V. On gère les formats semi-planaires (comme NV21).
        val vuv = ByteArray(vRowStride)
        if (vPixelStride == 2 && uPixelStride == 2 && vRowStride == uRowStride) {
            vBuffer.get(vuv, 0, vBuffer.remaining())
            uBuffer.get(yuvBuffer.array(), position, uBuffer.remaining())
            for (i in 0 until vuv.size / 2) {
                yuvBuffer.array()[position + 2 * i] = vuv[2 * i]
            }
            position += yuvBuffer.remaining()
        } else {
            yuvBuffer.position(position)
            yuvBuffer.put(vBuffer)
            yuvBuffer.position(position + vBuffer.remaining())
            yuvBuffer.put(uBuffer)
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/YuvToRgbConverter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/CameraXViewModel.kt ---

package be.heyman.android.ai.kikko.pollen.vision // <-- Nouveau sous-package !

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.core.content.ContextCompat
import java.util.concurrent.ExecutionException

/**
 * Un ViewModel pour gérer l'objet ProcessCameraProvider de CameraX de manière sûre
 * par rapport au cycle de vie de l'application.
 */
class CameraXViewModel(application: Application) : AndroidViewModel(application) {

    private var cameraProviderLiveData: MutableLiveData<ProcessCameraProvider>? = null

    // Renvoie un LiveData contenant le ProcessCameraProvider.
    val processCameraProvider: LiveData<ProcessCameraProvider>
        get() {
            if (cameraProviderLiveData == null) {
                cameraProviderLiveData = MutableLiveData()
                val cameraProviderFuture = ProcessCameraProvider.getInstance(getApplication())
                cameraProviderFuture.addListener(
                    {
                        try {
                            cameraProviderLiveData!!.setValue(cameraProviderFuture.get())
                        } catch (e: ExecutionException) {
                            // Gérer l'erreur
                        } catch (e: InterruptedException) {
                            // Gérer l'erreur
                        }
                    },
                    ContextCompat.getMainExecutor(getApplication())
                )
            }
            return cameraProviderLiveData!!
        }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/CameraXViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/GraphicOverlay.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import android.content.Context
import android.graphics.Canvas
import android.util.AttributeSet
import android.view.View

/**
 * Une vue qui dessine par-dessus l'aperçu de la caméra pour afficher les résultats de la vision.
 * BOURDON'S FIX: Cette version est maintenant alignée sur la logique de la démo ML Kit
 * pour gérer correctement l'inversion (miroir) et le redimensionnement.
 */
class GraphicOverlay(context: Context, attrs: AttributeSet?) : View(context, attrs) {

    private val lock = Any()
    private val graphics: MutableList<Graphic> = ArrayList()
    private var imageWidth = 0
    private var imageHeight = 0
    private var isImageFlipped = false

    // Facteurs de transformation calculés pour passer des coordonnées de l'image à la vue.
    private var scaleFactor = 1.0f
    private var postScaleWidthOffset = 0f
    private var postScaleHeightOffset = 0f


    abstract class Graphic(protected val overlay: GraphicOverlay) {
        protected val context: Context = overlay.context
        abstract fun draw(canvas: Canvas)
    }

    fun clear() {
        synchronized(lock) {
            graphics.clear()
        }
        postInvalidate()
    }

    fun add(graphic: Graphic) {
        synchronized(lock) {
            graphics.add(graphic)
        }
    }

    /**
     * Définit les informations de la source de l'image pour calculer la transformation.
     * Cette méthode est la clé pour corriger les problèmes d'orientation et de miroir.
     */
    fun setImageSourceInfo(width: Int, height: Int, isFlipped: Boolean) {
        synchronized(lock) {
            imageWidth = width
            imageHeight = height
            isImageFlipped = isFlipped
        }
        postInvalidate()
    }

    fun translateX(x: Float): Float {
        return if (isImageFlipped) {
            width - (x * scaleFactor + postScaleWidthOffset)
        } else {
            x * scaleFactor + postScaleWidthOffset
        }
    }

    fun translateY(y: Float): Float {
        return y * scaleFactor + postScaleHeightOffset
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        synchronized(lock) {
            if (imageWidth != 0 && imageHeight != 0) {
                val viewWidth = width.toFloat()
                val viewHeight = height.toFloat()

                val scaleX = viewWidth / imageWidth
                val scaleY = viewHeight / imageHeight
                scaleFactor = scaleX.coerceAtLeast(scaleY)

                postScaleWidthOffset = (viewWidth - imageWidth * scaleFactor) / 2
                postScaleHeightOffset = (viewHeight - imageHeight * scaleFactor) / 2
            }

            for (graphic in graphics) {
                graphic.draw(canvas)
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/GraphicOverlay.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/PreferenceUtils.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import android.content.Context
import android.preference.PreferenceManager
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions // Corrigé: Import ajouté

/**
 * Fonctions utilitaires pour accéder aux préférences partagées liées à la caméra et à ML Kit.
 */
object PreferenceUtils {

    fun isClassificationEnabled(context: Context): Boolean {
        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)
        val key = "pref_key_object_detector_enable_classification"
        return sharedPreferences.getBoolean(key, true)
    }

    fun getObjectDetectorOptionsForLivePreview(context: Context): ObjectDetectorOptions {
        return ObjectDetectorOptions.Builder()
            .setDetectorMode(ObjectDetectorOptions.STREAM_MODE)
            .enableClassification()
            .build()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/PreferenceUtils.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/ScopedExecutor.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import java.util.concurrent.Executor
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Un exécuteur qui peut être fermé.
 * Lorsque l'exécuteur est fermé, les tâches en attente ne seront pas exécutées.
 */
class ScopedExecutor(private val executor: Executor) : Executor {
    private val shutdown = AtomicBoolean()

    override fun execute(command: Runnable) {
        // N'exécute la commande que si le garde du corps n'a pas signalé l'arrêt.
        if (!shutdown.get()) {
            executor.execute(command)
        }
    }

    /**
     * Signale à l'exécuteur d'arrêter d'accepter de nouvelles tâches.
     */
    fun shutdown() {
        shutdown.set(true)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/ScopedExecutor.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/VisionProcessorBase.kt ---

package be.heyman.android.ai.kikko.pollen.vision

import android.content.Context
import android.util.Log
import androidx.camera.core.ExperimentalGetImage
import androidx.camera.core.ImageProxy
import com.google.android.gms.tasks.Task
import com.google.android.gms.tasks.TaskExecutors
import com.google.mlkit.vision.common.InputImage

/**
 * Classe de base simplifiée et corrigée.
 */
abstract class VisionProcessorBase<T>(val context: Context) {

    private val executor = ScopedExecutor(TaskExecutors.MAIN_THREAD)
    private var isShutdown = false

    @ExperimentalGetImage
    fun processImageProxy(
        imageProxy: ImageProxy,
        graphicOverlay: GraphicOverlay,
        onFinished: () -> Unit // Un simple callback pour dire "j'ai fini"
    ) {
        if (isShutdown) {
            onFinished()
            return
        }

        val mediaImage = imageProxy.image
        if (mediaImage == null) {
            imageProxy.close()
            onFinished()
            return
        }

        val inputImage = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)

        detectInImage(inputImage)
            .addOnSuccessListener(executor) { results: T ->
                this.onSuccess(results, graphicOverlay)
                graphicOverlay.postInvalidate()
            }
            .addOnFailureListener(executor) { e: Exception ->
                this.onFailure(e)
            }
            .addOnCompleteListener {
                onFinished()
            }
    }

    open fun stop() {
        executor.shutdown()
        isShutdown = true
    }

    protected abstract fun detectInImage(image: InputImage): Task<T>

    protected abstract fun onSuccess(results: T, graphicOverlay: GraphicOverlay)

    protected abstract fun onFailure(e: Exception)

    companion object {
        private const val TAG = "VisionProcessorBase"
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/pollen/vision/VisionProcessorBase.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptEditorActivity.kt ---

package be.heyman.android.ai.kikko.prompt

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.EditText
import android.widget.Spinner
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import be.heyman.android.ai.kikko.R
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import kotlinx.coroutines.launch

class PromptEditorActivity : AppCompatActivity() {

    private val TAG = "PromptEditorActivity"

    private lateinit var toolbar: MaterialToolbar
    private lateinit var promptSpinner: Spinner
    private lateinit var promptEditText: EditText
    private lateinit var saveButton: Button

    // BOURDON'S REFACTOR: La map locale contient maintenant les prompts complets (simples chaînes).
    private var currentPrompts = mutableMapOf<String, String>()
    private var promptKeys = listOf<String>()
    private var lastSelectedSpinnerPosition = -1

    private val importPromptsLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        if (uri != null) {
            lifecycleScope.launch {
                val success = PromptManager.importPrompts(this@PromptEditorActivity, uri)
                if (success) {
                    Toast.makeText(this@PromptEditorActivity, R.string.toast_import_success, Toast.LENGTH_SHORT).show()
                    loadInitialPrompts()
                } else {
                    Toast.makeText(this@PromptEditorActivity, R.string.toast_import_failed, Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_prompt_editor)

        bindViews()
        setupToolbar()
        setupListeners()
        loadInitialPrompts()
    }

    private fun bindViews() {
        toolbar = findViewById(R.id.prompt_editor_toolbar)
        promptSpinner = findViewById(R.id.prompt_selector_spinner)
        promptEditText = findViewById(R.id.prompt_editor_edittext)
        saveButton = findViewById(R.id.prompt_editor_save_button)
    }

    private fun setupToolbar() {
        setSupportActionBar(toolbar)
        toolbar.setNavigationOnClickListener { finish() }
    }

    private fun setupListeners() {
        saveButton.setOnClickListener { saveChanges() }
    }

    private fun loadInitialPrompts() {
        // BOURDON'S REFACTOR: On charge la map simple de prompts.
        currentPrompts = PromptManager.getAllPrompts().toMutableMap()
        promptKeys = currentPrompts.keys.sorted()

        val adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, promptKeys)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        promptSpinner.adapter = adapter

        promptSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                // Sauvegarde les changements du prompt précédent avant de charger le nouveau.
                if (lastSelectedSpinnerPosition != -1 && lastSelectedSpinnerPosition < promptKeys.size) {
                    val previousKey = promptKeys[lastSelectedSpinnerPosition]
                    currentPrompts[previousKey] = promptEditText.text.toString()
                }

                val selectedKey = promptKeys[position]
                promptEditText.setText(currentPrompts[selectedKey])
                lastSelectedSpinnerPosition = position
            }
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }

        if (promptKeys.isNotEmpty()) {
            promptEditText.setText(currentPrompts[promptKeys.first()])
            lastSelectedSpinnerPosition = 0
        }
    }

    private fun saveChanges() {
        // Mettre à jour la valeur de l'éditeur dans la map avant de sauvegarder.
        val selectedKey = promptSpinner.selectedItem as? String
        if (selectedKey != null) {
            currentPrompts[selectedKey] = promptEditText.text.toString()
        }

        lifecycleScope.launch {
            PromptManager.savePrompts(this@PromptEditorActivity, currentPrompts)
            Toast.makeText(this@PromptEditorActivity, R.string.toast_prompts_saved, Toast.LENGTH_SHORT).show()
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_import_prompts -> {
                importPromptsLauncher.launch("application/json")
                true
            }
            R.id.action_export_prompts -> {
                exportPrompts()
                true
            }
            R.id.action_reset_prompts -> {
                showResetConfirmationDialog()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    private fun exportPrompts() {
        lifecycleScope.launch {
            val uri = PromptManager.exportPrompts(this@PromptEditorActivity)
            if (uri != null) {
                val shareIntent = Intent().apply {
                    action = Intent.ACTION_SEND
                    putExtra(Intent.EXTRA_STREAM, uri)
                    type = "application/json"
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }
                startActivity(Intent.createChooser(shareIntent, getString(R.string.share_prompts_title)))
            } else {
                Toast.makeText(this@PromptEditorActivity, R.string.toast_export_failed, Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun showResetConfirmationDialog() {
        MaterialAlertDialogBuilder(this)
            .setTitle(R.string.dialog_reset_prompts_title)
            .setMessage(R.string.dialog_reset_prompts_message)
            .setNegativeButton(R.string.dialog_cancel, null)
            .setPositiveButton(R.string.dialog_reset_confirm) { _, _ ->
                lifecycleScope.launch {
                    PromptManager.restoreDefaults(this@PromptEditorActivity)
                    loadInitialPrompts()
                    Toast.makeText(this@PromptEditorActivity, R.string.toast_prompts_restored, Toast.LENGTH_SHORT).show()
                }
            }
            .show()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptEditorActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptManager.kt ---

package be.heyman.android.ai.kikko.prompt

import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.core.content.FileProvider
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStreamReader
import java.util.MissingFormatArgumentException

object PromptManager {

    private const val TAG = "PromptManagerTrace"
    private val promptsCache = mutableMapOf<String, String>()
    private var isInitialized = false

    private fun getDefaultPrompts(): Map<String, String> {
        return mapOf(
            "forge_identification" to """
            ROLE: You are the AI Queen of the Kikko Hive, an expert in multimodal synthesis. Your reasoning must be flawless and strictly follow the evidence provided.
            CONTEXT: You are receiving a JSON **array** of intelligence reports from your Specialist Bees. Each object in the array corresponds to one visual clue (image). The `ocr_results` are the most reliable source of truth when available.
            TASK: **Synthesize ALL reports in the array** to determine a **single, unified subject identity**.
            1.  **Evidence Prioritization (CRITICAL):**
                -   **IF** the `ocr_results.full_text` from any report contains a specific product name or species: This OCR data is your **PRIMARY EVIDENCE**.
                -   **ELSE**: Use the highest-confidence labels from other classifiers across all reports as your PRIMARY EVIDENCE.
            2.  **Final Ruling:** Synthesize all information to determine one final `specificName` and one final `deckName`.
            CRITICAL RULES:
            -   You MUST IGNORE low-confidence labels that contradict the primary evidence.
            -   If the evidence is inconclusive, respond with `{"error": "Inconclusive analysis"}`.
            OUTPUT FORMAT: Your response MUST be a **single, valid JSON object**. Do NOT add any other text or markdown.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` or other characters instead.
            {
              "reasoning": {
                "visualAnalysis": "Your brief analysis synthesizing what is visible across ALL images.",
                "evidenceCorrelation": "Your analysis of the JSON reports, explaining how you combined evidence from all reports to reach a single conclusion."
              },
             "specificName": "The most specific and functional name of the subject.",
             "deckName": "based on the specificName, select the single most appropriate deck name from this short list: [`Bird`, `Insect`, `Plant`, `Food`] ",
              "confidence": 0.95
            }
            --- START OF DATA ---
            [INTELLIGENCE REPORTS]:
            %1${'$'}s
            """.trimIndent(),

            "forge_description" to """
            ROLE: You are a creative and engaging storyteller.
            TASK: Write a descriptive paragraph about "%1${'$'}s - %2${'$'}s". The text must be captivating and easy to read aloud (for Text-to-Speech).
            Crucially, you MUST include:
            1. The origins of the subject.
            2. Exactly four (4) interesting or fun facts seamlessly integrated into the text.
            The entire response must be a single paragraph of plain text, without markdown, lists, or bullet points.
            The response must be in %3${'$'}s.
            """.trimIndent(),

            "forge_stats" to """
            ROLE: You are a meticulous and resourceful Data Extraction AI. You never fail to find a value.
            CONTEXT: You are analyzing "%1${'$'}s". You have two sources of information: raw OCR data which is the primary source of truth, and a general narrative description which is secondary.
            TASK: Your mission is to find the values for the required stats: [%2${'$'}s]. %3${'$'}s
            Follow this strict priority order for your search:
            1.  **PRIORITY 1 (OCR)**: Scrutinize the `[RAW_OCR_DATA]` for precise figures.
            2.  **PRIORITY 2 (NARRATIVE)**: If a stat is not found in the OCR, search for it within the `[NARRATIVE_DESCRIPTION]`.
            3.  **PRIORITY 3 (INFERENCE)**: If a stat is **still not found**, it is **imperative** that you provide a typical **average value** for "%1${'$'}s".
            OUTPUT FORMAT: Your response MUST be a single, valid JSON object. Do not add any other text or markdown.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            Example Output: %4${'$'}s
            --- START OF DATA ---
            [RAW_OCR_DATA]: "%5${'$'}s"
            [NARRATIVE_DESCRIPTION]: "%6${'$'}s"
            """.trimIndent(),

            "forge_quiz" to """
            ROLE: You are a creative but strictly factual Quiz Master AI.
            CONTEXT: You have a `[DESCRIPTION]` and a `[STATS_DATA]` JSON object. This is your ONLY source of truth.
            TASK: Create exactly 4 multiple-choice questions with 4 possible answers each from BOTH the description and the stats data. At least one question must be about a specific numerical value.
            CRITICAL RULE: DO NOT use any external knowledge. All questions and answers must be directly verifiable from the provided context.
            OUTPUT FORMAT: Your response MUST be a single JSON array, with no other explanatory text. The content of the quiz must be in %1${'$'}s.
            Format: `[{"q": "...", "o": ["...", "...", "...", "..."], "c": correct_index, "explanation": "..."}]`
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value (like in "q" or "o"). Use single quotes `'` instead.
            --- START OF DATA ---
            [DESCRIPTION]: "%2${'$'}s"
            [STATS_DATA]: %3${'$'}s
            """.trimIndent(),

            "forge_translation" to """
            ROLE: You are an expert linguist and translator for the Kikko Hive.
            CONTEXT: You have the JSON content of a Knowledge Card.
            TASK: Translate ALL text content within the JSON to %1${'$'}s.
            - Maintain the EXACT JSON structure. Do NOT add or remove fields.
            - Only translate the string values. Do NOT translate field names.
            - Do NOT include any comments or extra text outside the JSON.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            Original JSON content to translate:
            %2${'$'}s
            """.trimIndent(),

            // BOURDON'S CRITICAL FIX: Restauration du format de sortie correct.
            "clash_verdict" to """
            ROLE: You are a versatile AI Judge for the Saga Arena.
            CONTEXT: You must judge a duel based on the `[CLASH_QUESTION]`. You have data for two contestants. Your verdict MUST be based solely on the provided data.
            TASK: You must provide two distinct outputs. Both generated text fields MUST be in the requested `[DEVICE_LANGUAGE]`.
            1.  **Reasoning Field**: Act as a meticulous, logical Judge. Provide a concise, technical justification for your verdict in 1-2 factual sentences.
            2.  **TTS Script Field**: Act as a fun, enthusiastic game show announcer (the Bourdon). Announce the winner and explain the main reason for the victory in simple, exciting terms for a child.
            OUTPUT FORMAT: Your response MUST be a single, valid JSON object and NOTHING ELSE.
            - The `reasoning` key: your concise, factual justification in the `[DEVICE_LANGUAGE]`.
            - The `tts_script` key: your short, exciting announcement in the `[DEVICE_LANGUAGE]`.
            - The `winner` key: CRITICAL. It MUST contain ONLY ONE of these exact three strings: "player1", "player2", or "tie".
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            --- START OF DUEL DATA ---
            [CLASH_QUESTION]: "%1${'$'}s"
            [DEVICE_LANGUAGE]: "%2${'$'}s"
            [CONTESTANT_1_NAME]: "%3${'$'}s"
            [CONTESTANT_1_STATS_JSON]: %4${'$'}s
            [CONTESTANT_2_NAME]: "%5${'$'}s"
            [CONTESTANT_2_STATS_JSON]: %6${'$'}s
            """.trimIndent(),

            "forge_judgment_arbiter" to """
            ROLE: You are the impartial AI Arbiter of the Forge. Your role is to synthesize and judge, not to create new information.
            CONTEXT: A competition was held among several AI Queens to determine the value for the property '%1${'$'}s'. You are provided with a JSON array of their proposals.
            TASK:
            1.  Analyze all proposals in the `[PROPOSALS_JSON]` array.
            2.  Evaluate them based on these criteria: Correct JSON formatting, completeness, and logical consistency.
            3.  Select the SINGLE BEST proposal.
            OUTPUT FORMAT: Your response MUST be a single, valid JSON object and nothing else.
            **IMPORTANT**: Never use double quotes `"` inside a JSON string value. Use single quotes `'` instead.
            {
              "arbiterReasoning": "Your brief justification for selecting the winning proposal.",
              "bestProposal": { ... The complete, unmodified JSON object from the `rawResponse` of the winning proposal ... }
            }
            --- START OF EVIDENCE ---
            [PROPOSALS_JSON]:
            %2${'$'}s
            """.trimIndent()
        )
    }

    fun initialize(context: Context) {
        if (isInitialized) return
        synchronized(this) {
            if (isInitialized) return
            promptsCache.clear()
            promptsCache.putAll(getDefaultPrompts())
            Log.i(TAG, "${promptsCache.size} prompts chargés en mémoire depuis la source en dur.")
            isInitialized = true
        }
    }

    fun getPrompt(key: String): String {
        val rawPrompt = promptsCache[key]
        if (rawPrompt == null) {
            Log.e(TAG, "!!! ÉCHEC: Clé de prompt introuvable: '$key'")
            return "ERREUR: Prompt '$key' non trouvé."
        }
        return rawPrompt
    }

    fun getAllPrompts(): Map<String, String> = promptsCache.toMap()

    suspend fun savePrompts(context: Context, updatedPrompts: Map<String, String>) {
        Log.w(TAG, "La sauvegarde des prompts est désactivée dans cette version de débogage.")
    }

    suspend fun restoreDefaults(context: Context) {
        synchronized(this) {
            promptsCache.clear()
            promptsCache.putAll(getDefaultPrompts())
        }
        Log.i(TAG, "Prompts restaurés aux valeurs par défaut en mémoire.")
    }

    suspend fun exportPrompts(context: Context): Uri? {
        Log.w(TAG, "L'export des prompts est désactivé dans cette version de débogage.")
        return null
    }

    suspend fun importPrompts(context: Context, uri: Uri): Boolean {
        Log.w(TAG, "L'import des prompts est désactivé dans cette version de débogage.")
        return false
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/prompt/PromptManager.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/quizz/QuizActivity.kt ---

package be.heyman.android.ai.kikko.quiz

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.View
import android.widget.Button
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.QuizQuestion
import com.google.android.material.appbar.MaterialToolbar
import com.google.android.material.card.MaterialCardView

class QuizActivity : AppCompatActivity() {

    private lateinit var toolbar: MaterialToolbar
    private lateinit var progressTextView: TextView
    private lateinit var questionTextView: TextView
    private lateinit var answersRadioGroup: RadioGroup
    private lateinit var answerRadioButtons: List<RadioButton>
    private lateinit var submitButton: Button
    private lateinit var nextButton: Button
    private lateinit var feedbackCard: MaterialCardView
    private lateinit var feedbackTextView: TextView

    private var quizQuestions: List<QuizQuestion> = emptyList()
    private var currentQuestionIndex = 0
    private var score = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_quiz)

        // BOURDON'S REFACTOR: Use of a dedicated 'card' variable for clarity.
        val card: KnowledgeCard? = intent.getParcelableExtra(EXTRA_CARD)
        quizQuestions = card?.quiz ?: emptyList()

        if (quizQuestions.isEmpty()) {
            Toast.makeText(this, "Erreur: Aucune question de quiz trouvée.", Toast.LENGTH_SHORT).show()
            finish()
            return
        }

        bindViews()
        setupToolbar(card?.specificName ?: "Quiz")
        setupListeners()
        displayQuestion()
    }

    private fun bindViews() {
        toolbar = findViewById(R.id.quiz_toolbar)
        progressTextView = findViewById(R.id.quiz_progress_textview)
        questionTextView = findViewById(R.id.quiz_question_textview)
        answersRadioGroup = findViewById(R.id.quiz_answers_radiogroup)
        answerRadioButtons = listOf(
            findViewById(R.id.quiz_answer_1),
            findViewById(R.id.quiz_answer_2),
            findViewById(R.id.quiz_answer_3),
            findViewById(R.id.quiz_answer_4)
        )
        submitButton = findViewById(R.id.quiz_submit_button)
        nextButton = findViewById(R.id.quiz_next_button)
        feedbackCard = findViewById(R.id.quiz_feedback_card)
        feedbackTextView = findViewById(R.id.quiz_feedback_textview)
    }

    private fun setupToolbar(cardName: String) {
        toolbar.title = "Quiz : $cardName"
        toolbar.setNavigationOnClickListener { finish() }
    }

    private fun setupListeners() {
        submitButton.setOnClickListener {
            val selectedAnswerId = answersRadioGroup.checkedRadioButtonId
            if (selectedAnswerId != -1) {
                val selectedRadioButton = findViewById<RadioButton>(selectedAnswerId)
                val selectedIndex = answerRadioButtons.indexOf(selectedRadioButton)
                checkAnswer(selectedIndex)
            } else {
                Toast.makeText(this, "Veuillez sélectionner une réponse.", Toast.LENGTH_SHORT).show()
            }
        }

        nextButton.setOnClickListener {
            currentQuestionIndex++
            if (currentQuestionIndex < quizQuestions.size) {
                displayQuestion()
            } else {
                showFinalScore()
            }
        }
    }

    private fun displayQuestion() {
        resetQuestionState()
        val question = quizQuestions[currentQuestionIndex]
        progressTextView.text = "Question ${currentQuestionIndex + 1} / ${quizQuestions.size}"
        questionTextView.text = question.question
        question.options.forEachIndexed { index, optionText ->
            if(index < answerRadioButtons.size) {
                answerRadioButtons[index].text = optionText
                answerRadioButtons[index].visibility = View.VISIBLE
            }
        }
    }

    private fun checkAnswer(selectedIndex: Int) {
        val question = quizQuestions[currentQuestionIndex]
        val isCorrect = selectedIndex == question.correctAnswerIndex

        if (isCorrect) {
            score++
            feedbackTextView.text = "Bonne réponse !"
            feedbackCard.setCardBackgroundColor(ContextCompat.getColor(this, R.color.kikko_success_green))
        } else {
            val correctAnswer = question.options[question.correctAnswerIndex]
            feedbackTextView.text = "Incorrect. La bonne réponse était : \n\"$correctAnswer\""
            feedbackCard.setCardBackgroundColor(ContextCompat.getColor(this, R.color.kikko_error_red))
        }

        feedbackTextView.setTextColor(ContextCompat.getColor(this, R.color.kikko_bark_brown))
        feedbackCard.visibility = View.VISIBLE

        toggleAnswerInteractivity(false)
        submitButton.visibility = View.GONE
        nextButton.visibility = View.VISIBLE
    }

    private fun showFinalScore() {
        val title = "Quiz Terminé !"
        val message = "Votre score : $score / ${quizQuestions.size}"
        // For simplicity, we use an AlertDialog for the final score.
        // A dedicated results screen could be created for a more polished UX.
        android.app.AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton("Terminer") { _, _ -> finish() }
            .setCancelable(false)
            .show()
    }

    private fun resetQuestionState() {
        answersRadioGroup.clearCheck()
        feedbackCard.visibility = View.GONE
        submitButton.visibility = View.VISIBLE
        nextButton.visibility = View.GONE
        toggleAnswerInteractivity(true)
    }

    private fun toggleAnswerInteractivity(isEnabled: Boolean) {
        for (radioButton in answerRadioButtons) {
            radioButton.isEnabled = isEnabled
        }
    }

    companion object {
        private const val EXTRA_CARD = "EXTRA_CARD"

        fun newIntent(context: Context, card: KnowledgeCard): Intent {
            return Intent(context, QuizActivity::class.java).apply {
                putExtra(EXTRA_CARD, card)
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/quizz/QuizActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/AudienceSettingsDialogFragment.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.content.Context
import android.os.Bundle
import android.os.Parcelable
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import be.heyman.android.ai.kikko.R
import com.google.android.material.slider.Slider
import kotlinx.parcelize.Parcelize
import java.util.Locale

@Parcelize
data class AudienceSettings(val temperature: Float, val topK: Int) : Parcelable

class AudienceSettingsDialogFragment : DialogFragment() {

    interface AudienceSettingsListener {
        fun onSettingsConfirmed(settings: AudienceSettings)
    }

    private var listener: AudienceSettingsListener? = null
    private lateinit var currentSettings: AudienceSettings

    private lateinit var temperatureLabel: TextView
    private lateinit var temperatureSlider: Slider
    private lateinit var topKLabel: TextView
    private lateinit var topKSlider: Slider
    private lateinit var confirmButton: Button

    override fun onAttach(context: Context) {
        super.onAttach(context)
        // L'activité parente doit implémenter cette interface pour recevoir les résultats.
        listener = context as? AudienceSettingsListener
            ?: throw ClassCastException("$context must implement AudienceSettingsListener")
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            @Suppress("DEPRECATION")
            currentSettings = it.getParcelable(ARG_SETTINGS) ?: AudienceSettings(0.2f, 40)
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_audience_settings, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        bindViews(view)
        setupViews()
        setupListeners()
    }

    private fun bindViews(view: View) {
        temperatureLabel = view.findViewById(R.id.audience_settings_temperature_label)
        temperatureSlider = view.findViewById(R.id.audience_settings_temperature_slider)
        topKLabel = view.findViewById(R.id.audience_settings_topk_label)
        topKSlider = view.findViewById(R.id.audience_settings_topk_slider)
        confirmButton = view.findViewById(R.id.audience_settings_confirm_button)
    }

    private fun setupViews() {
        dialog?.setTitle("Décrets de la Reine")

        temperatureSlider.value = currentSettings.temperature
        topKSlider.value = currentSettings.topK.toFloat()

        updateTemperatureLabel(currentSettings.temperature)
        updateTopKLabel(currentSettings.topK.toFloat())
    }

    private fun setupListeners() {
        temperatureSlider.addOnChangeListener { _, value, _ ->
            updateTemperatureLabel(value)
        }
        topKSlider.addOnChangeListener { _, value, _ ->
            updateTopKLabel(value)
        }
        confirmButton.setOnClickListener {
            val newSettings = AudienceSettings(
                temperature = temperatureSlider.value,
                topK = topKSlider.value.toInt()
            )
            listener?.onSettingsConfirmed(newSettings)
            dismiss()
        }
    }

    private fun updateTemperatureLabel(value: Float) {
        temperatureLabel.text = String.format(Locale.US, "Tempérament (Créativité : %.2f)", value)
    }

    private fun updateTopKLabel(value: Float) {
        topKLabel.text = "Focalisation (Top-K : ${value.toInt()})"
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        const val TAG = "AudienceSettingsDialog"
        private const val ARG_SETTINGS = "current_settings"

        fun newInstance(currentSettings: AudienceSettings): AudienceSettingsDialogFragment {
            val args = Bundle().apply {
                putParcelable(ARG_SETTINGS, currentSettings)
            }
            return AudienceSettingsDialogFragment().apply {
                arguments = args
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/AudienceSettingsDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/QueenSelectorDialogFragment.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.QueenModelAdapter
import be.heyman.android.ai.kikko.R
import java.io.File

class QueenSelectorDialogFragment : DialogFragment() {

    interface QueenSelectorListener {
        fun onQueenSelected(modelName: String)
    }

    private var listener: QueenSelectorListener? = null
    private lateinit var queenSelectorAdapter: QueenModelAdapter

    private lateinit var availableModels: List<File>
    private var selectedModelName: String? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = context as? QueenSelectorListener
            ?: throw ClassCastException("$context must implement QueenSelectorListener")
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            @Suppress("DEPRECATION")
            val modelPaths = it.getStringArrayList(ARG_MODELS) ?: emptyList<String>()
            availableModels = modelPaths.map { path -> File(path) }
            selectedModelName = it.getString(ARG_SELECTED_MODEL)
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.dialog_queen_selector, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        dialog?.setTitle("Choisir la Reine")

        val recyclerView: RecyclerView = view.findViewById(R.id.queen_selector_recyclerview)
        val emptyState: TextView = view.findViewById(R.id.queen_selector_empty_state)

        if (availableModels.isEmpty()) {
            recyclerView.visibility = View.GONE
            emptyState.visibility = View.VISIBLE
        } else {
            recyclerView.visibility = View.VISIBLE
            emptyState.visibility = View.GONE

            queenSelectorAdapter = QueenModelAdapter(
                models = availableModels,
                selectedModelName = selectedModelName
            ) { selectedFile ->
                listener?.onQueenSelected(selectedFile.name)
                dismiss()
            }
            recyclerView.layoutManager = LinearLayoutManager(context)
            recyclerView.adapter = queenSelectorAdapter
        }
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        const val TAG = "QueenSelectorDialog"
        private const val ARG_MODELS = "available_models"
        private const val ARG_SELECTED_MODEL = "selected_model"

        fun newInstance(availableModels: List<File>, selectedModelName: String?): QueenSelectorDialogFragment {
            val args = Bundle().apply {
                putStringArrayList(ARG_MODELS, ArrayList(availableModels.map { it.absolutePath }))
                putString(ARG_SELECTED_MODEL, selectedModelName)
            }
            return QueenSelectorDialogFragment().apply {
                arguments = args
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/QueenSelectorDialogFragment.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceActivity.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.core.content.ContextCompat
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePadding
import androidx.core.widget.addTextChangedListener
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.lifecycle.SavedStateViewModelFactory
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.SttVoskService
import be.heyman.android.ai.kikko.TtsService
import be.heyman.android.ai.kikko.VoskStatus
import com.bumptech.glide.Glide
import com.google.android.material.appbar.AppBarLayout
import kotlinx.coroutines.launch
import java.io.File

class RoyalAudienceActivity : AppCompatActivity(),
    AudienceSettingsDialogFragment.AudienceSettingsListener,
    QueenSelectorDialogFragment.QueenSelectorListener {

    private val viewModel: RoyalAudienceViewModel by lazy {
        Log.d(TAG, "👑 Audience Royale: J'utilise le bon Maître des Clés (SavedStateViewModelFactory) pour présenter nos respects à la Reine. Elle a besoin de son registre personnel (SavedStateHandle) !")
        ViewModelProvider(this, SavedStateViewModelFactory(application, this))
            .get(RoyalAudienceViewModel::class.java)
    }
    private lateinit var audienceAdapter: RoyalAudienceAdapter

    private lateinit var rootContainer: View
    private lateinit var recyclerView: RecyclerView
    private lateinit var inputBar: View
    private lateinit var inputEditText: EditText
    private lateinit var sendButton: ImageButton
    private lateinit var micButton: ImageButton
    private lateinit var attachButton: ImageButton
    private lateinit var settingsButton: ImageButton
    private lateinit var modelSelectorContainer: View
    private lateinit var modelNameTextView: TextView
    private lateinit var toolbar: Toolbar
    private lateinit var backButton: ImageButton

    private lateinit var imagePreviewContainer: FrameLayout
    private lateinit var previewImageView: ImageView
    private lateinit var removePreviewButton: ImageButton

    private lateinit var backgroundPlayerView: PlayerView
    private var exoPlayer: ExoPlayer? = null

    private var currentTranscription = ""
    private var selectedImageUri: Uri? = null

    private val requestPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
        if (isGranted) {
            startListening()
        } else {
            Toast.makeText(this, R.string.mic_permission_denied, Toast.LENGTH_SHORT).show()
        }
    }

    private val pickImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            selectedImageUri = it
            showImagePreview()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        WindowCompat.setDecorFitsSystemWindows(window, false)

        setContentView(R.layout.activity_royal_audience)
        Log.i(TAG, "🏛️ Entrée dans la salle d'audience de la Reine.")

        TtsService.initialize(this)

        bindViews()
        setupWindowInsets()
        setupRecyclerView()
        setupListeners()
        observeViewModel()
        observeVoskService()
        ensureVoskModelIsLoaded()

        updateSendButtonState()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
    }

    override fun onStop() {
        super.onStop()
        releasePlayer()
    }

    private fun bindViews() {
        rootContainer = findViewById(R.id.audience_root_container)
        recyclerView = findViewById(R.id.audience_recyclerview)
        backgroundPlayerView = findViewById(R.id.audience_background_video_view)

        inputBar = findViewById<View>(R.id.audience_input_bar)
        inputEditText = inputBar.findViewById(R.id.chat_input_edittext)
        sendButton = inputBar.findViewById(R.id.chat_send_button)
        micButton = inputBar.findViewById(R.id.chat_mic_button)
        attachButton = inputBar.findViewById(R.id.chat_attach_button)

        toolbar = findViewById(R.id.audience_toolbar)
        backButton = findViewById(R.id.audience_back_button)
        settingsButton = findViewById(R.id.audience_settings_button)
        modelSelectorContainer = findViewById(R.id.audience_model_selector_container)
        modelNameTextView = findViewById(R.id.audience_model_name)

        imagePreviewContainer = findViewById(R.id.audience_image_preview_container)

        Log.d(TAG, "🖼️ Vues de l'interface liées.")
    }

    private fun setupWindowInsets() {
        ViewCompat.setOnApplyWindowInsetsListener(rootContainer) { view, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            val imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())

            view.updatePadding(
                left = systemBars.left,
                top = systemBars.top,
                right = systemBars.right,
                bottom = systemBars.bottom
            )

            inputBar.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                bottomMargin = imeInsets.bottom
            }

            recyclerView.updatePadding(bottom = imeInsets.bottom + systemBars.bottom)

            insets
        }
    }

    private fun initializePlayer() {
        Log.d(TAG, "🎥 Initialisation du fond vidéo pour l'ambiance royale.")
        exoPlayer = ExoPlayer.Builder(this).build().also { player ->
            backgroundPlayerView.player = player
            val videoUri = Uri.parse("android.resource://$packageName/${R.raw.audience}")
            val mediaItem = MediaItem.fromUri(videoUri)
            player.setMediaItem(mediaItem)
            player.repeatMode = Player.REPEAT_MODE_ONE
            player.volume = 0f
            player.playWhenReady = true
            player.prepare()
        }
    }

    private fun releasePlayer() {
        Log.d(TAG, "🎬 Libération des ressources vidéo.")
        exoPlayer?.release()
        exoPlayer = null
    }

    private fun setupRecyclerView() {
        audienceAdapter = RoyalAudienceAdapter()
        recyclerView.apply {
            adapter = audienceAdapter
            layoutManager = LinearLayoutManager(this@RoyalAudienceActivity).apply {
                stackFromEnd = true
            }
        }
        Log.d(TAG, "📜 Parchemin de conversation déroulé et prêt.")
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupListeners() {
        backButton.setOnClickListener { finish() }

        sendButton.setOnClickListener {
            val userInput = inputEditText.text.toString()
            viewModel.sendMessage(userInput, selectedImageUri)
            inputEditText.text.clear()
            clearImagePreview()
        }

        inputEditText.addTextChangedListener {
            updateSendButtonState()
        }

        micButton.setOnClickListener {
            if (SttVoskService.voskResult.value?.status != VoskStatus.LISTENING) {
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {
                    startListening()
                } else {
                    requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                }
            }
        }

        attachButton.setOnClickListener {
            pickImageLauncher.launch("image/*")
        }

        settingsButton.setOnClickListener {
            val currentSettings = viewModel.uiState.value.audienceSettings
            AudienceSettingsDialogFragment.newInstance(currentSettings)
                .show(supportFragmentManager, AudienceSettingsDialogFragment.TAG)
        }
        modelSelectorContainer.setOnClickListener {
            val availableModels = viewModel.uiState.value.availableModels
            val selectedModel = viewModel.uiState.value.selectedModelName
            QueenSelectorDialogFragment.newInstance(availableModels, selectedModel)
                .show(supportFragmentManager, QueenSelectorDialogFragment.TAG)
        }
    }

    private fun startListening() {
        Log.i(TAG, "🎤 Démarrage de l'écoute. Le Butineur s'adresse à la Reine de vive voix.")
        if (!SttVoskService.isModelLoaded()) {
            Toast.makeText(this, R.string.audience_no_voice_model, Toast.LENGTH_LONG).show()
            return
        }
        currentTranscription = inputEditText.text.toString()
        if (currentTranscription.isNotBlank() && !currentTranscription.endsWith(" ")) {
            currentTranscription += " "
        }
        SttVoskService.startListening()
    }

    private fun updateMicButtonState(isListening: Boolean) {
        if (isListening) {
            micButton.setImageResource(R.drawable.ic_stop)
        } else {
            micButton.setImageResource(android.R.drawable.ic_btn_speak_now)
        }
        micButton.isEnabled = !viewModel.uiState.value.isLoading
    }

    private fun updateSendButtonState() {
        val hasText = inputEditText.text.isNotBlank()
        val hasImage = selectedImageUri != null
        val shouldShowSend = hasText || hasImage

        if (shouldShowSend) {
            if (SttVoskService.voskResult.value?.status == VoskStatus.LISTENING) {
                SttVoskService.stopListening()
            }
            sendButton.visibility = View.VISIBLE
            micButton.visibility = View.GONE
        } else {
            sendButton.visibility = View.GONE
            micButton.visibility = View.VISIBLE
        }
    }

    private fun showImagePreview() {
        if (imagePreviewContainer.childCount == 0) {
            layoutInflater.inflate(R.layout.layout_chat_image_preview, imagePreviewContainer, true)
            previewImageView = imagePreviewContainer.findViewById(R.id.preview_image_view)
            removePreviewButton = imagePreviewContainer.findViewById(R.id.remove_preview_button)
            removePreviewButton.setOnClickListener { clearImagePreview() }
        }
        imagePreviewContainer.visibility = View.VISIBLE
        Glide.with(this)
            .load(selectedImageUri)
            .into(previewImageView)
        updateSendButtonState()
    }

    private fun clearImagePreview() {
        selectedImageUri = null
        imagePreviewContainer.visibility = View.GONE
        updateSendButtonState()
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    viewModel.uiState.collect { state ->
                        audienceAdapter.submitList(state.messages)
                        modelNameTextView.text = state.selectedModelName ?: getString(R.string.audience_no_queen_available_short)

                        if (state.messages.isNotEmpty()) {
                            recyclerView.post { recyclerView.scrollToPosition(state.messages.size - 1) }
                        }

                        val isUserInputEnabled = !state.isLoading
                        inputEditText.isEnabled = isUserInputEnabled
                        attachButton.isEnabled = isUserInputEnabled
                        micButton.isEnabled = isUserInputEnabled
                    }
                }
                launch {
                    viewModel.toastEvent.collect { message ->
                        Toast.makeText(this@RoyalAudienceActivity, message, Toast.LENGTH_SHORT).show()
                    }
                }
            }
        }
        Log.d(TAG, "👀 Observation de l'état de l'audience (ViewModel) activée.")
    }

    private fun observeVoskService() {
        SttVoskService.voskResult.observe(this) { result ->
            val isCurrentlyListening = result.status == VoskStatus.LISTENING
            updateMicButtonState(isCurrentlyListening)

            if (isCurrentlyListening) {
                val fullText = currentTranscription + result.text
                inputEditText.setText(fullText)
                inputEditText.setSelection(fullText.length)
            } else {
                if(result.status == VoskStatus.FINAL_RESULT) {
                    val fullText = (currentTranscription + result.text).trim()
                    Log.i(TAG, "🎤 Transcription finale reçue : '$fullText'")
                    inputEditText.setText(fullText)
                    inputEditText.setSelection(fullText.length)
                }
            }
        }
    }

    private fun ensureVoskModelIsLoaded() {
        if (SttVoskService.isModelLoaded()) return

        val baseModelDir = File(filesDir, "vosk-models")
        if (baseModelDir.exists() && baseModelDir.isDirectory) {
            val modelDirs = baseModelDir.listFiles { file -> file.isDirectory }
            if (!modelDirs.isNullOrEmpty()) {
                val defaultModelDir = modelDirs.first()
                val dummyModel = Model(name = defaultModelDir.name, downloadFileName = "", url = "", sizeInBytes = 0)
                Log.d(TAG, "🧠 Chargement du modèle vocal par défaut : '${defaultModelDir.name}'")
                SttVoskService.loadModel(dummyModel, baseModelDir) { success ->
                    if (success) {
                        runOnUiThread {
                            Toast.makeText(this, getString(R.string.audience_default_voice_model_loaded, defaultModelDir.name), Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            } else {
                Toast.makeText(this, R.string.audience_no_voice_model, Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "⏸️ Audience mise en pause.")
        SttVoskService.stopListening()
        TtsService.stopAndClearQueue()
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "💥 L'audience est terminée. Libération des ressources.")
        SttVoskService.reset()
        TtsService.shutdown()
    }

    override fun onSettingsConfirmed(settings: AudienceSettings) {
        viewModel.updateAudienceSettings(settings)
    }

    override fun onQueenSelected(modelName: String) {
        viewModel.updateSelectedQueen(modelName)
    }

    companion object {
        private const val TAG = "RoyalAudienceActivity"
        const val CARD_ID_KEY = "cardId"
        fun newIntent(context: Context, cardId: Long = -1L): Intent {
            return Intent(context, RoyalAudienceActivity::class.java).apply {
                putExtra(CARD_ID_KEY, cardId)
            }
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceActivity.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceAdapter.kt ---

package be.heyman.android.ai.kikko.royal_audience

import android.graphics.BitmapFactory
import android.net.Uri
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import com.bumptech.glide.Glide
import java.io.File

/**
 * BOURDON'S REFORGE V2:
 * La data class est maintenant encore plus flexible pour inclure une image dans les messages.
 */
data class ChatMessage(
    val text: String? = null,
    val card: KnowledgeCard? = null,
    val imageUri: String? = null, // NOUVEAU: URI de l'image jointe par l'utilisateur
    val isFromUser: Boolean,
    var isStreaming: Boolean = false
)

class RoyalAudienceAdapter : RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    companion object {
        private const val VIEW_TYPE_USER = 1
        private const val VIEW_TYPE_QUEEN = 2
        private const val VIEW_TYPE_CARD_CONTEXT = 3
        private const val VIEW_TYPE_USER_WITH_IMAGE = 4 // NOUVEAU: Type de vue pour les messages avec image
    }

    private val messages: MutableList<ChatMessage> = mutableListOf()

    // --- ViewHolders pour chaque type de message ---

    inner class UserMessageViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val messageTextView: TextView = view.findViewById(R.id.chat_user_message_textview)
    }

    inner class QueenMessageViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val messageTextView: TextView = view.findViewById(R.id.chat_queen_message_textview)
    }

    inner class CardContextViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val cardImageView: ImageView = view.findViewById(R.id.chat_card_image)
        val cardNameTextView: TextView = view.findViewById(R.id.chat_card_name)
        val cardDescriptionTextView: TextView = view.findViewById(R.id.chat_card_description)

        fun bind(card: KnowledgeCard) {
            cardNameTextView.text = card.specificName
            cardDescriptionTextView.text = card.description ?: "Aucune description disponible."

            card.imagePath?.let { path ->
                val imgFile = File(path)
                if (imgFile.exists()) {
                    val bitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                    cardImageView.setImageBitmap(bitmap)
                }
            }
        }
    }

    // NOUVEAU: ViewHolder pour les messages utilisateur avec image
    inner class UserMessageWithImageViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        private val messageTextView: TextView = view.findViewById(R.id.chat_user_message_textview)
        private val imageView: ImageView = view.findViewById(R.id.chat_user_imageview)

        fun bind(message: ChatMessage) {
            // Le texte est optionnel si une image est présente
            if (message.text.isNullOrBlank()) {
                messageTextView.visibility = View.GONE
            } else {
                messageTextView.visibility = View.VISIBLE
                messageTextView.text = message.text
            }

            // L'image est chargée via Glide pour plus d'efficacité
            message.imageUri?.let {
                Glide.with(itemView.context)
                    .load(Uri.parse(it))
                    .into(imageView)
            }
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = messages[position]
        return when {
            message.card != null -> VIEW_TYPE_CARD_CONTEXT
            message.isFromUser && !message.imageUri.isNullOrEmpty() -> VIEW_TYPE_USER_WITH_IMAGE
            message.isFromUser -> VIEW_TYPE_USER
            else -> VIEW_TYPE_QUEEN
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            VIEW_TYPE_USER -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_user, parent, false)
                UserMessageViewHolder(view)
            }
            VIEW_TYPE_QUEEN -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_queen, parent, false)
                QueenMessageViewHolder(view)
            }
            VIEW_TYPE_CARD_CONTEXT -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_card_context, parent, false)
                CardContextViewHolder(view)
            }
            VIEW_TYPE_USER_WITH_IMAGE -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_chat_user_with_image, parent, false)
                UserMessageWithImageViewHolder(view)
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
    }

    override fun getItemCount(): Int = messages.size

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        val message = messages[position]
        when (holder.itemViewType) {
            VIEW_TYPE_USER -> (holder as UserMessageViewHolder).messageTextView.text = message.text
            VIEW_TYPE_QUEEN -> (holder as QueenMessageViewHolder).messageTextView.text = message.text
            VIEW_TYPE_CARD_CONTEXT -> message.card?.let { (holder as CardContextViewHolder).bind(it) }
            VIEW_TYPE_USER_WITH_IMAGE -> (holder as UserMessageWithImageViewHolder).bind(message)
        }
    }

    fun submitList(newMessages: List<ChatMessage>) {
        messages.clear()
        messages.addAll(newMessages)
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceViewModel.kt ---

// --- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---
package be.heyman.android.ai.kikko.forge

import android.app.Application
import android.content.Context
import android.graphics.BitmapFactory
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import be.heyman.android.ai.kikko.GameConstants
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.model.AnalysisResult
import be.heyman.android.ai.kikko.model.AnalysisStatus
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.concurrent.CancellationException
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

data class CompetitionSummaryItem(
    val response: String,
    val voteCount: Int,
    val firstValidTask: AnalysisResult
)

data class CompetitionSummary(
    val propertyName: String,
    val items: List<CompetitionSummaryItem>
)

sealed class JudgmentState {
    data object None : JudgmentState()
    data class InProgress(val propertyName: String, val prompt: String, val streamingResponse: String = "") : JudgmentState()
    data class Complete(val propertyName: String, val arbiterReasoning: String, val winningProposal: AnalysisResult) : JudgmentState()
    data class Failed(val propertyName: String, val error: String) : JudgmentState()
}

data class ForgeWorkshopUiState(
    val isLoading: Boolean = true,
    val workshopGrains: List<PollenGrain> = emptyList(),
    val selectedGrain: PollenGrain? = null,
    val selectedCard: KnowledgeCard? = null,
    val analysisResults: Map<String, List<AnalysisResult>> = emptyMap(),
    val competitionSummaries: Map<String, CompetitionSummary> = emptyMap(),
    val judgmentState: JudgmentState = JudgmentState.None,
    val statusMessage: String? = null,
    val activeFilter: String = ForgeWorkshopViewModel.FILTER_RAW
)

class ForgeWorkshopViewModel(application: Application) : AndroidViewModel(application) {

    private val forgeRepository: ForgeRepository = (application as KikkoApplication).forgeRepository
    private val llmHelper: ForgeLlmHelper = (application as KikkoApplication).forgeLlmHelper
    private val pollenGrainDao: PollenGrainDao = (application as KikkoApplication).pollenGrainDao

    private val TAG = "KikkoForgeTrace"
    private val _uiState = MutableStateFlow(ForgeWorkshopUiState())
    val uiState = _uiState.asStateFlow()
    private val gson = Gson()

    private var competitionJob: Job? = null
    private var judgmentJob: Job? = null

    private var allWorkshopItems = listOf<Pair<PollenGrain, KnowledgeCard?>>()

    private val deckProperties = mapOf(
        "Food" to listOf("description", "ingredients", "allergens", "stats.energy"),
        "Plant" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.floweringPeriod"),
        "Insect" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.diet"),
        "Bird" to listOf("description", "biological.scientificName", "biological.vernacularName", "stats.wingspan")
    )

    private data class IdentificationResultData(
        val reasoning: Reasoning,
        val deckName: String,
        val specificName: String,
        val confidence: Float
    )

    companion object {
        const val FILTER_ALL = "ALL"
        const val FILTER_RAW = "RAW"
    }

    init {
        Log.d(TAG, "ViewModel initialisé. Lancement du chargement initial des grains de pollen.")
        viewModelScope.launch {
            _uiState.update { it.copy(statusMessage = getString(R.string.workshop_loading_grains)) }
            loadWorkshopGrains()
        }
    }

    fun getPropertiesForDeck(deckName: String?): List<String> {
        val normalizedDeckName = deckName
            ?.trim()
            ?.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
            ?.removeSuffix("s")
        return deckProperties[normalizedDeckName] ?: emptyList()
    }


    fun selectGrain(grain: PollenGrain) {
        viewModelScope.launch {
            competitionJob?.cancel()
            judgmentJob?.cancel()
            Log.i(TAG, "[SELECT] Sélection du grain ID: ${grain.id} | Statut: ${grain.status} | CardID lié: ${grain.forgedCardId}")

            val card = allWorkshopItems.find { it.first.id == grain.id }?.second
            val newStatusMessage = if (grain.status == PollenStatus.AWAITING_VALIDATION || grain.status == PollenStatus.IDENTIFYING) {
                getString(R.string.workshop_awaiting_validation)
            } else {
                getString(R.string.workshop_ready_to_refine)
            }

            _uiState.update { it.copy(
                selectedGrain = grain,
                selectedCard = card,
                analysisResults = emptyMap(),
                competitionSummaries = emptyMap(),
                judgmentState = JudgmentState.None,
                statusMessage = newStatusMessage
            ) }

            if (card != null) {
                Log.d(TAG, "[SELECT] Carte chargée depuis la cache - ID: ${card.id}, Nom: '${card.specificName}', Deck: '${card.deckName}'")
            } else {
                Log.w(TAG, "[SELECT] Aucune carte n'a pu être chargée pour ce grain.")
            }

            refreshAnalysisResults(grain.id, "identification")
            card?.deckName?.takeIf { it != "Unknown" }?.let { deckName ->
                getPropertiesForDeck(deckName).forEach { propertyName ->
                    refreshAnalysisResults(grain.id, propertyName)
                }
            }
        }
    }

    fun setFilter(filterType: String) {
        viewModelScope.launch {
            if (_uiState.value.activeFilter == filterType) return@launch
            _uiState.update { it.copy(activeFilter = filterType) }
            updateFilteredGrains()
        }
    }

    private fun updateFilteredGrains() {
        val currentFilter = _uiState.value.activeFilter
        val filteredItems = when (currentFilter) {
            FILTER_RAW -> allWorkshopItems.filter { (grain, _) ->
                grain.status in listOf(PollenStatus.RAW, PollenStatus.IDENTIFYING, PollenStatus.AWAITING_VALIDATION, PollenStatus.ERROR)
            }
            else -> allWorkshopItems.filter { (_, card) -> card?.deckName == currentFilter }
        }

        val filteredGrains = filteredItems.map { it.first }
        _uiState.update { it.copy(workshopGrains = filteredGrains) }

        if (filteredGrains.none { it.id == _uiState.value.selectedGrain?.id }) {
            filteredGrains.firstOrNull()?.let { selectGrain(it) } ?: _uiState.update {
                it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_in_deck))
            }
        }
    }

    fun createAnalysisTournament(propertyName: String) {
        viewModelScope.launch {
            val grain = _uiState.value.selectedGrain ?: return@launch
            _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_preparing_competition, propertyName)) }

            val modelsToCompete = withContext(Dispatchers.IO) {
                File(getApplication<Application>().filesDir, "imported_models")
                    .listFiles { _, name -> name.endsWith(".task") }?.map { it.name } ?: emptyList()
            }

            if (modelsToCompete.isEmpty()) {
                _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_no_queens_installed)) }
                return@launch
            }
            Log.i(TAG, "[COMPETITION] Reines en compétition: ${modelsToCompete.joinToString()}")

            val accelerator = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                .getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU") ?: "GPU"

            val tasks = forgeRepository.createAnalysisTasksForProperty(grain.id, propertyName, modelsToCompete, accelerator)
            refreshAnalysisResults(grain.id, propertyName)

            val message = getApplication<Application>().resources.getQuantityString(R.plurals.workshop_tasks_ready, tasks.size, tasks.size)
            _uiState.update { it.copy(isLoading = false, statusMessage = message) }

            launchCompetitionExecution(propertyName)
        }
    }

    fun relaunchAnalysisTournament(propertyName: String) {
        viewModelScope.launch {
            val grain = _uiState.value.selectedGrain ?: return@launch
            _uiState.update { it.copy(isLoading = true, statusMessage = "Clearing old results for '$propertyName'...") }
            forgeRepository.clearAnalysisResultsForProperty(grain.id, propertyName)
            refreshAnalysisResults(grain.id, propertyName)
            createAnalysisTournament(propertyName)
        }
    }

    fun validateFromSummary(summaryItem: CompetitionSummaryItem) {
        Log.i(TAG, "[VALIDATE-SUMMARY] Validation for response '${summaryItem.response}' with ${summaryItem.voteCount} votes.")
        validateProperty(summaryItem.firstValidTask)
    }

    fun validateAndCreateCardFromIdentification(task: AnalysisResult) {
        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch

            withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_identification)) } }

            try {
                var resultData = parseIntelligentJson<IdentificationResultData>(rawResponse)
                if (resultData == null) {
                    val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
                    val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
                    if (name != null && deck != null) {
                        resultData = IdentificationResultData(name, deck, Reasoning("N/A", "Regex Fallback"), 0.5f)
                    } else {
                        throw IOException(getString(R.string.error_validation_parsing_failed))
                    }
                }

                var cardId = grain.forgedCardId
                if (cardId == null) {
                    val newCard = KnowledgeCard(specificName = resultData.specificName, deckName = resultData.deckName, imagePath = grain.pollenImagePaths.firstOrNull(), confidence = resultData.confidence, reasoning = resultData.reasoning, description = null, stats = null, quiz = null, translations = null, scientificName = null, vernacularName = null, allergens = null, ingredients = null)
                    cardId = cardDao.insert(newCard)
                    pollenGrainDao.updateForgingResult(grain.id, grain.status, cardId)
                } else {
                    cardDao.updateIdentification(cardId, resultData.specificName, resultData.deckName, resultData.reasoning, resultData.confidence)
                }
                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_DESCRIPTION)
                withContext(Dispatchers.Main) { loadWorkshopGrains() }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-ID] Critical validation failure.", e)
                withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message)) } }
            }
        }
    }

    fun validateProperty(task: AnalysisResult) {
        if (task.propertyName == "identification") {
            validateAndCreateCardFromIdentification(task)
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            val grain = _uiState.value.selectedGrain ?: return@launch
            val cardId = grain.forgedCardId ?: return@launch
            val rawResponse = task.rawResponse ?: return@launch
            Log.i(TAG, "[VALIDATE-PROP] Validating property '${task.propertyName}' with task ${task.id}.")

            withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_validating_property, task.propertyName)) } }

            try {
                val propertyJson = parseIntelligentJson<JsonObject>(rawResponse) ?: throw IOException(getString(R.string.error_json_malformed))
                val valueElement = propertyJson.get(task.propertyName) ?: throw IOException(getString(R.string.error_json_key_missing, task.propertyName))
                val valueAsString = if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)

                forgeRepository.updateCardProperty(cardId, task.propertyName, valueAsString)
                pollenGrainDao.updateStatus(grain.id, getNextStatus(grain.status))
                withContext(Dispatchers.Main) { loadWorkshopGrains() }

            } catch (e: Exception) {
                Log.e(TAG, "[VALIDATE-PROP] Failed to validate property '${task.propertyName}'.", e)
                withContext(Dispatchers.Main) { _uiState.update { it.copy(isLoading = false, statusMessage = getString(R.string.workshop_validation_error, e.message)) } }
            }
        }
    }

    private fun getNextStatus(currentStatus: PollenStatus): PollenStatus = when (currentStatus) {
        PollenStatus.PENDING_DESCRIPTION -> PollenStatus.PENDING_STATS
        PollenStatus.PENDING_STATS -> PollenStatus.PENDING_QUIZ
        PollenStatus.PENDING_QUIZ -> PollenStatus.PENDING_TRANSLATION
        PollenStatus.PENDING_TRANSLATION -> PollenStatus.FORGED
        else -> currentStatus
    }

    // BOURDON'S REFACTOR V3: L'Orchestrateur Royal "Maître de Cérémonie"
    private fun launchCompetitionExecution(propertyName: String, singleTaskToRun: AnalysisResult? = null) {
        competitionJob?.cancel()
        competitionJob = viewModelScope.launch(Dispatchers.IO) {
            val tasksToRun = singleTaskToRun?.let { listOf(it) }
                ?: _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.PENDING } ?: emptyList()

            if (tasksToRun.isEmpty()) {
                Log.w(TAG, "[ORCHESTRATOR] Launch requested for '$propertyName', but no pending tasks found.")
                return@launch
            }

            val tasksByQueen = tasksToRun.groupBy { gson.fromJson(it.modelConfigJson, ModelConfiguration::class.java).modelName }
            Log.i(TAG, "[ORCHESTRATOR] Launching for ${tasksToRun.size} tasks, grouped by ${tasksByQueen.size} Queen(s).")

            for ((modelName, tasksForQueen) in tasksByQueen) {
                Log.i(TAG, "[ORCHESTRATOR] Summoning Queen '$modelName' for ${tasksForQueen.size} task(s).")
                val firstTaskConfig = gson.fromJson(tasksForQueen.first().modelConfigJson, ModelConfiguration::class.java)
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) {
                    Log.e(TAG, "[ORCHESTRATOR] FAILED: AI Queen file '$modelName' not found.")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Model file not found") }
                    continue
                }

                val isMultimodal = tasksForQueen.any { it.propertyName == "identification" || it.propertyName == "description" }
                val queenModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = modelName.contains("gemma-3n", ignoreCase = true))
                val initError = llmHelper.initialize(queenModel, firstTaskConfig.accelerator, isMultimodal)
                if (initError != null) {
                    Log.e(TAG, "[ORCHESTRATOR] Failed to initialize Queen '$modelName': $initError")
                    tasksForQueen.forEach { updateTaskStatusInDb(it.id, it.pollenGrainId, it.propertyName, AnalysisStatus.FAILED, "Initialization failed: $initError") }
                    continue
                }

                try {
                    for (task in tasksForQueen) {
                        if (!runSingleTask(task)) {
                            Log.w(TAG, "[ORCHESTRATOR] Task ${task.id.substring(0,4)} failed. Queen '$modelName' will continue with next task.")
                        }
                    }
                } finally {
                    Log.i(TAG, "[ORCHESTRATOR] Queen '$modelName' has completed her duties. Cleaning up resources.")
                    llmHelper.cleanUp()
                }
            }
            Log.i(TAG, "[ORCHESTRATOR] All Queens have completed their duties for property '$propertyName'.")
        }
    }

    private suspend fun runSingleTask(task: AnalysisResult): Boolean {
        return try {
            withContext(Dispatchers.Main) { updateTaskStatusInUi(task.id, task.propertyName) { it.copy(status = AnalysisStatus.RUNNING, streamingResponse = "") } }

            val config = gson.fromJson(task.modelConfigJson, ModelConfiguration::class.java)
            val parentGrain = _uiState.value.selectedGrain ?: throw IllegalStateException("Parent pollen grain not found")
            val card = forgeRepository.getCardForGrain(parentGrain)
            val swarmReportJson = parentGrain.swarmAnalysisReportJson ?: throw IOException("Swarm report missing")

            val isMultimodalTask = task.propertyName == "identification" || task.propertyName == "description"
            val images = if (isMultimodalTask) parentGrain.pollenImagePaths.mapNotNull { BitmapFactory.decodeFile(it) } else emptyList()

            val prompt = when(task.propertyName) {
                "identification" -> ForgePromptGenerator.generateIdentificationTournamentPrompt(swarmReportJson)
                else -> {
                    val currentCard = card ?: throw IllegalStateException("Card not found for refinement")
                    ForgePromptGenerator.generatePropertyForgePrompt(
                        propertyName = task.propertyName, deckName = currentCard.deckName, specificName = currentCard.specificName,
                        swarmReportJson = swarmReportJson, existingDescription = currentCard.description, dependencyDataJson = null
                    )
                }
            }

            llmHelper.resetSession(Model(name=config.modelName, url="", downloadFileName="", sizeInBytes=0), isMultimodalTask, config.temperature, config.topK)

            val fullResponse = suspendCoroutine<String> { continuation ->
                val responseBuilder = StringBuilder()
                llmHelper.runInference(prompt, images) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    if (done) {
                        if (continuation.context.isActive) {
                            continuation.resume(responseBuilder.toString())
                        }
                    }
                }
            }

            val updatedTask = task.copy(status = AnalysisStatus.COMPLETED, rawResponse = fullResponse, streamingResponse = null)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) { refreshAnalysisResults(task.pollenGrainId, task.propertyName) }
            true
        } catch (e: Exception) {
            val status = if (e is CancellationException) AnalysisStatus.CANCELLED else AnalysisStatus.FAILED
            updateTaskStatusInDb(task.id, task.pollenGrainId, task.propertyName, status, e.message)
            false
        }
    }

    fun launchFinalJudgment(propertyName: String) {
        judgmentJob?.cancel()
        val proposals = _uiState.value.analysisResults[propertyName]?.filter { it.status == AnalysisStatus.COMPLETED }
        if (proposals.isNullOrEmpty()) {
            viewModelScope.launch { _uiState.update { it.copy(statusMessage = "Aucune proposition valide à juger.") } }
            return
        }

        judgmentJob = viewModelScope.launch(Dispatchers.IO) {
            val prompt = ForgePromptGenerator.generateJudgmentPrompt(propertyName, proposals)
            withContext(Dispatchers.Main) {
                _uiState.update { it.copy(judgmentState = JudgmentState.InProgress(propertyName, prompt)) }
            }

            try {
                val prefs = getApplication<Application>().getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
                val modelName = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null) ?: throw IOException("Aucune Reine sélectionnée pour être l'Arbitre.")
                val accelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!
                val modelFile = File(getApplication<Application>().filesDir, "imported_models").resolve(modelName)
                if (!modelFile.exists()) throw IOException("Fichier de la Reine Arbitre introuvable.")
                val arbiterModel = Model(name = modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0)
                val config = ModelConfiguration(modelName, accelerator, 0.1f, 1)

                val initError = llmHelper.initialize(arbiterModel, accelerator, false)
                if(initError != null) throw RuntimeException("Échec de l'initialisation de l'Arbitre: $initError")

                val responseBuilder = StringBuilder()
                llmHelper.runInferenceWithConfig(prompt, emptyList(), config) { partialResult, done ->
                    responseBuilder.append(partialResult)
                    viewModelScope.launch(Dispatchers.Main) {
                        _uiState.update {
                            val currentState = it.judgmentState
                            if(currentState is JudgmentState.InProgress) {
                                it.copy(judgmentState = currentState.copy(streamingResponse = responseBuilder.toString()))
                            } else it
                        }
                    }

                    if (done) {
                        val arbiterResponse = parseArbiterResponse(responseBuilder.toString(), proposals)
                        viewModelScope.launch(Dispatchers.Main) {
                            if (arbiterResponse != null) {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Complete(propertyName, arbiterResponse.first, arbiterResponse.second)) }
                            } else {
                                _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, "Impossible de parser le verdict de l'Arbitre.")) }
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _uiState.update { it.copy(judgmentState = JudgmentState.Failed(propertyName, e.message ?: "Erreur inconnue de l'Arbitre."))}
                }
            }
        }
    }

    private data class ArbiterVerdict(val arbiterReasoning: String, val bestProposal: JsonObject)

    private fun parseArbiterResponse(rawResponse: String, originalProposals: List<AnalysisResult>): Pair<String, AnalysisResult>? {
        val verdict = parseIntelligentJson<ArbiterVerdict>(rawResponse) ?: return null

        val winningProposal = originalProposals.find {
            it.rawResponse?.let { originalRaw ->
                try {
                    val originalJsonObj = parseIntelligentJson<JsonObject>(originalRaw)
                    originalJsonObj != null && originalJsonObj == verdict.bestProposal
                } catch (e: Exception) { false }
            } ?: false
        }

        return winningProposal?.let { Pair(verdict.arbiterReasoning, it) }
    }

    fun confirmJudgment() {
        val currentState = _uiState.value.judgmentState
        if (currentState is JudgmentState.Complete) {
            validateProperty(currentState.winningProposal)
            dismissJudgment()
        }
    }

    fun dismissJudgment() {
        _uiState.update { it.copy(judgmentState = JudgmentState.None) }
    }

    fun cancelCompetition(propertyName: String) {
        competitionJob?.cancel()
        Log.i(TAG, "[AUTO-FORGE] Compétition pour '$propertyName' annulée par l'utilisateur.")
    }

    fun retryAnalysisTask(task: AnalysisResult) {
        launchCompetitionExecution(task.propertyName, singleTaskToRun = task)
    }

    fun deleteSelectedGrain() {
        val grainToDelete = _uiState.value.selectedGrain ?: return
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                forgeRepository.deletePollenGrainAndAssociatedData(grainToDelete)
            }
            loadWorkshopGrains()
        }
    }

    private suspend fun updateTaskStatusInDb(taskId: String, grainId: String, propertyName: String, newStatus: AnalysisStatus, errorMessage: String? = null) {
        val currentTask = forgeRepository.getAnalysisResults(grainId, propertyName).find { it.id == taskId }
        if (currentTask != null) {
            val updatedTask = currentTask.copy(status = newStatus, errorMessage = errorMessage)
            forgeRepository.updateAnalysisResult(updatedTask)
            withContext(Dispatchers.Main) {
                refreshAnalysisResults(grainId, propertyName)
            }
        }
    }

    private fun updateTaskStatusInUi(taskId: String, propertyName: String, updateAction: (AnalysisResult) -> AnalysisResult) {
        _uiState.update { currentState ->
            val newMap = currentState.analysisResults.toMutableMap()
            val propertyTasks = newMap[propertyName]?.toMutableList()
            val taskIndex = propertyTasks?.indexOfFirst { it.id == taskId }

            if (propertyTasks != null && taskIndex != null && taskIndex != -1) {
                propertyTasks[taskIndex] = updateAction(propertyTasks[taskIndex])
                newMap[propertyName] = propertyTasks
                currentState.copy(analysisResults = newMap)
            } else {
                currentState
            }
        }
    }

    private suspend fun loadWorkshopGrains() {
        _uiState.update { it.copy(isLoading = true, statusMessage = getString(R.string.workshop_loading_grains)) }

        val grains = forgeRepository.getGrainsForWorkshop() + pollenGrainDao.getByStatus(PollenStatus.AWAITING_VALIDATION) + pollenGrainDao.getByStatus(PollenStatus.ERROR)
        val items = grains.distinctBy { it.id }.sortedByDescending { it.timestamp }.map { grain ->
            val card = forgeRepository.getCardForGrain(grain)
            Pair(grain, card)
        }
        allWorkshopItems = items

        _uiState.update { it.copy(isLoading = false) }
        updateFilteredGrains()

        val grainToSelect = _uiState.value.workshopGrains.firstOrNull()
        if (grainToSelect != null) {
            selectGrain(grainToSelect)
        } else {
            _uiState.update { it.copy(selectedGrain = null, selectedCard = null, statusMessage = getString(R.string.workshop_no_grains_to_forge)) }
        }
    }

    private suspend fun refreshAnalysisResults(pollenGrainId: String, propertyName: String) {
        val results = forgeRepository.getAnalysisResults(pollenGrainId, propertyName)

        _uiState.update { currentState ->
            val newAnalysisMap = currentState.analysisResults.toMutableMap().apply { this[propertyName] = results }
            val newSummariesMap = currentState.competitionSummaries.toMutableMap()

            val hasCompletedTasks = results.any { it.status == AnalysisStatus.COMPLETED }
            if (hasCompletedTasks) {
                val summary = createCompetitionSummary(propertyName, results)
                if (summary.items.isNotEmpty()) {
                    newSummariesMap[propertyName] = summary
                } else {
                    newSummariesMap.remove(propertyName)
                }
            } else {
                newSummariesMap.remove(propertyName)
            }
            currentState.copy(analysisResults = newAnalysisMap, competitionSummaries = newSummariesMap)
        }
    }

    private fun createCompetitionSummary(propertyName: String, results: List<AnalysisResult>): CompetitionSummary {
        val completedTasks = results.filter { it.status == AnalysisStatus.COMPLETED && !it.rawResponse.isNullOrBlank() }
        if (completedTasks.isEmpty()) return CompetitionSummary(propertyName, emptyList())

        val responseGroups = completedTasks.groupBy { task ->
            extractValueFromResponse(task.rawResponse!!, propertyName)
        }.filterKeys { it.isNotBlank() }

        val summaryItems = responseGroups.map { (response, tasks) ->
            CompetitionSummaryItem(response = response, voteCount = tasks.size, firstValidTask = tasks.first())
        }.sortedByDescending { it.voteCount }
        return CompetitionSummary(propertyName, summaryItems)
    }

    private fun extractValueFromResponse(rawResponse: String, propertyName: String): String {
        try {
            val propertyJson = parseIntelligentJson<JsonObject>(rawResponse)
            if (propertyJson != null) {
                return when (propertyName) {
                    "identification" -> {
                        val name = propertyJson.get("specificName")?.asString ?: ""
                        val deck = propertyJson.get("deckName")?.asString ?: ""
                        if (name.isNotBlank() && deck.isNotBlank()) "$deck: $name" else ""
                    }
                    else -> {
                        val valueElement = propertyJson.get(propertyName)
                        if (valueElement != null) {
                            if (valueElement.isJsonPrimitive) valueElement.asString else gson.toJson(valueElement)
                        } else ""
                    }
                }
            }
        } catch (e: Exception) {
            Log.w(TAG, "[PARSER] Le parsing JSON a échoué pour '$propertyName', tentative de fallback. Erreur: ${e.message}")
        }

        if (propertyName == "identification") {
            val name = """"specificName"\s*:\s*"(.*?)"""".toRegex().find(rawResponse)?.groups?.get(1)?.value
            val deck = """"(deckName|DeckName)"\s*:\s*"(.*?)"""".toRegex(RegexOption.IGNORE_CASE).find(rawResponse)?.groups?.get(2)?.value
            if (name != null && deck != null) {
                return "$deck: $name"
            }
        }
        return ""
    }


    private inline fun <reified T> parseIntelligentJson(rawString: String): T? {
        val firstBrace = rawString.indexOf('{')
        if (firstBrace == -1) return null

        var braceCount = 0
        var lastBrace = -1
        for (i in firstBrace until rawString.length) {
            when (rawString[i]) {
                '{' -> braceCount++
                '}' -> braceCount--
            }
            if (braceCount == 0) {
                lastBrace = i
                break
            }
        }

        if (lastBrace == -1) return null
        val jsonSubstring = rawString.substring(firstBrace, lastBrace + 1)
        Log.d(TAG, "[PARSER] JSON isolé pour l'analyse: $jsonSubstring")

        return try {
            val type = object : TypeToken<T>() {}.type
            gson.fromJson(jsonSubstring, type)
        } catch (e: JsonSyntaxException) {
            Log.e(TAG, "[PARSER] Erreur de syntaxe Gson pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        } catch (e: Exception) {
            Log.e(TAG, "[PARSER] Erreur inattendue lors du parsing pour le type ${T::class.java.simpleName}: '$jsonSubstring'", e)
            throw IOException(getString(R.string.error_json_malformed_or_incomplete), e)
        }
    }

    private fun getString(resId: Int, vararg formatArgs: Any): String {
        return getApplication<Application>().getString(resId, *formatArgs)
    }

    override fun onCleared() {
        super.onCleared()
        competitionJob?.cancel()
        judgmentJob?.cancel()
        llmHelper.cleanUp()
    }
}
// --- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/forge/ForgeWorkshopViewModel.kt ---

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/royal_audience/RoyalAudienceViewModel.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/CardPreviewAdapter.kt ---

package be.heyman.android.ai.kikko.ui.adapters

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import java.io.File

/**
 * BOURDON'S REFACTOR: Cet adaptateur est maintenant aligné sur celui du DeckViewer.
 * Il utilise le layout de vignette compact pour une expérience utilisateur cohérente.
 * Déplacé depuis le package `debug` car il est utilisé par des fonctionnalités principales
 * (ex: sélection de cartes dans le Clash, mais avec le layout `item_clash_champion_thumbnail`).
 *
 * @param cards La liste mutable des KnowledgeCard à afficher.
 * @param onCardClickListener Callback lors du clic sur une carte.
 */
class CardPreviewAdapter(
    private val cards: MutableList<KnowledgeCard> = mutableListOf(),
    private val onCardClickListener: (KnowledgeCard) -> Unit
) : RecyclerView.Adapter<CardPreviewAdapter.ViewHolder>() {

    private var selectedCard: KnowledgeCard? = null

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        // BOURDON'S FIX: Les IDs correspondent maintenant à item_clash_champion_thumbnail.xml.
        val nameTextView: TextView = view.findViewById(R.id.card_thumbnail_name)
        val imageView: ImageView = view.findViewById(R.id.card_thumbnail_image)
        // La vue des stats n'existe plus dans ce layout, donc elle est retirée.
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        // BOURDON'S FIX: Utilisation du layout correct et compact pour les vignettes de champion.
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_clash_champion_thumbnail, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val card = cards[position]
        holder.nameTextView.text = card.specificName

        card.imagePath?.let { path ->
            val imgFile = File(path)
            if (imgFile.exists()) {
                val bitmap = BitmapFactory.decodeFile(imgFile.absolutePath)
                holder.imageView.setImageBitmap(bitmap)
            } else {
                holder.imageView.setImageResource(R.drawable.ic_placeholder_card)
            }
        } ?: holder.imageView.setImageResource(R.drawable.ic_placeholder_card)

        holder.itemView.setOnClickListener { onCardClickListener(card) }
    }

    override fun getItemCount() = cards.size

    fun updateCards(newCards: List<KnowledgeCard>) {
        cards.clear()
        cards.addAll(newCards)
        notifyDataSetChanged()
    }

    fun setSelectedCard(card: KnowledgeCard?) {
        selectedCard = card
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/CardPreviewAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/KnowledgeCardAdapter.kt ---

package be.heyman.android.ai.kikko.ui.adapters

import android.graphics.BitmapFactory
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R // BOURDON'S FIX: Import R
import be.heyman.android.ai.kikko.model.KnowledgeCard
import com.bumptech.glide.Glide
import java.io.File // BOURDON'S FIX: Import File

// BOURDON'S FIX: Changement de ListAdapter à RecyclerView.Adapter pour simplifier la gestion.
// ListAdapter nécessite un DiffUtil qui n'était pas la source directe de l'erreur,
// mais revenons à la base pour s'assurer de la correction du ViewBinding.
class KnowledgeCardAdapter(
    private val onCardClicked: (KnowledgeCard) -> Unit
) : RecyclerView.Adapter<KnowledgeCardAdapter.ViewHolder>() { // BOURDON'S FIX: Hérite de RecyclerView.Adapter

    // BOURDON'S FIX: Le ViewHolder prend maintenant une View et utilise findViewById
    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val cardName: TextView = view.findViewById(R.id.card_title) // BOURDON'S FIX: ID correct pour item_knowledge_card_reforged
        val cardDeck: TextView = view.findViewById(R.id.card_deck_name) // BOURDON'S FIX: ID correct
        val cardImage: ImageView = view.findViewById(R.id.card_image) // BOURDON'S FIX: ID correct

        init {
            itemView.setOnClickListener {
                if (adapterPosition != RecyclerView.NO_POSITION) {
                    onCardClicked(currentList[adapterPosition]) // BOURDON'S FIX: Accès à currentList
                }
            }
        }

        fun bind(card: KnowledgeCard) {
            cardName.text = card.specificName
            cardDeck.text = card.deckName
            // BOURDON'S FIX: Utilisation de Glide avec le contexte de la vue et gestion des chemins locaux
            card.imagePath?.let { path ->
                val imgFile = File(path)
                if (imgFile.exists()) {
                    Glide.with(itemView.context)
                        .load(imgFile)
                        .into(cardImage)
                } else {
                    cardImage.setImageResource(R.drawable.ic_placeholder_card) // Image par défaut si le fichier n'existe pas
                }
            } ?: cardImage.setImageResource(R.drawable.ic_placeholder_card)
        }
    }

    // BOURDON'S FIX: Ajout d'une liste interne pour gérer les données, comme dans ListAdapter
    private var currentList: List<KnowledgeCard> = emptyList()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        // BOURDON'S FIX: Inflate le layout de carte refait pour le Clash
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_knowledge_card_reforged, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val card = currentList[position] // BOURDON'S FIX: Accès à currentList
        holder.bind(card)
    }

    override fun getItemCount() = currentList.size // BOURDON'S FIX: Taille de currentList

    // BOURDON'S FIX: Méthode pour soumettre une nouvelle liste de cartes
    fun submitList(newList: List<KnowledgeCard>) {
        currentList = newList
        notifyDataSetChanged() // BOURDON'S FIX: Notifie le changement de données
    }
}

// BOURDON'S FIX: DiffUtil est conservé si on souhaite le remettre en place avec ListAdapter plus tard.
// Pour l'instant, il n'est plus directement utilisé par KnowledgeCardAdapter.
class KnowledgeCardDiffCallback : DiffUtil.ItemCallback<KnowledgeCard>() {
    override fun areItemsTheSame(oldItem: KnowledgeCard, newItem: KnowledgeCard): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: KnowledgeCard, newItem: KnowledgeCard): Boolean {
        return oldItem == newItem
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/KnowledgeCardAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/LocalModelAdapter.kt ---

package be.heyman.android.ai.kikko.ui.adapters

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import be.heyman.android.ai.kikko.R
import java.io.File

/**
 * Adaptateur pour afficher une liste de modèles IA locaux (fichiers .task).
 * Déplacé depuis le package `debug` car il est essentiel pour `ToolsDialogFragment`.
 *
 * @param models La liste mutable des fichiers de modèle à afficher.
 * @param onDeleteClick Une fonction lambda appelée lorsqu'un utilisateur clique sur le bouton de suppression.
 */
class LocalModelAdapter(
    private var models: MutableList<File>,
    private val onDeleteClick: (File) -> Unit
) : RecyclerView.Adapter<LocalModelAdapter.ViewHolder>() {

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val modelName: TextView = view.findViewById(R.id.local_model_name_textview)
        val deleteButton: ImageButton = view.findViewById(R.id.local_model_delete_button)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_local_model, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val modelFile = models[position]
        holder.modelName.text = modelFile.name
        holder.deleteButton.setOnClickListener {
            onDeleteClick(modelFile)
        }
    }

    override fun getItemCount() = models.size

    fun updateModels(newModels: List<File>) {
        models.clear()
        models.addAll(newModels)
        notifyDataSetChanged()
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/ui/adapters/LocalModelAdapter.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/PreferenceHelper.kt ---

package be.heyman.android.ai.kikko.util

import android.content.Context
import android.content.SharedPreferences

object PreferenceHelper {

    const val PREFS_NAME = "kikko_prefs"

    // Onboarding
    const val PREF_ONBOARDING_COMPLETED = "onboarding_completed"

    // Queen AI Configuration
    const val KEY_SELECTED_FORGE_QUEEN = "selected_forge_queen"
    const val KEY_SELECTED_FORGE_QUEEN_ACCELERATOR = "selected_forge_queen_accelerator"

    // Worker Constraints
    const val KEY_REQUIRE_CHARGING = "require_charging"
    const val KEY_REQUIRE_IDLE = "require_idle"


    private fun getPrefs(context: Context): SharedPreferences {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }

    fun setBoolean(context: Context, key: String, value: Boolean) {
        getPrefs(context).edit().putBoolean(key, value).apply()
    }

    fun getBoolean(context: Context, key: String, defaultValue: Boolean): Boolean {
        return getPrefs(context).getBoolean(key, defaultValue)
    }

    fun setString(context: Context, key: String, value: String?) {
        getPrefs(context).edit().putString(key, value).apply()
    }

    fun getString(context: Context, key: String, defaultValue: String?): String? {
        return getPrefs(context).getString(key, defaultValue)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/PreferenceHelper.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLog.kt ---

package be.heyman.android.ai.kikko.util.logging

import kotlinx.serialization.Serializable

/**
 * Représente une seule entrée dans le journal de forge (Journal de Bord).
 * Capture l'intégralité d'une transaction avec un modèle LLM pour analyse et débogage.
 * Déplacé depuis le package `debug` vers un nouveau package `util.logging`
 * car il est une fonctionnalité de logging générale.
 */
@Serializable
data class InferenceLog(
    val inferenceId: String,
    val timestamp: String,
    val useCase: String,
    val model: ModelInfo,
    val prompt: String, // AJOUTÉ : Le prompt exact envoyé au modèle.
    val rawResponse: String, // AJOUTÉ : La réponse brute complète reçue.
    val metadata: InferenceMetadata
)

/**
 * Contient les informations sur le modèle utilisé pour l'inférence.
 */
@Serializable
data class ModelInfo(
    val name: String,
    val configuration: ModelConfiguration
)

/**
 * Contient les paramètres de configuration clés utilisés pour cette inférence spécifique.
 */
@Serializable
data class ModelConfiguration(
    val temperature: Float,
    val topK: Int,
    val maxTokens: Int,
    val accelerator: String
)

/**
 * Contient les métadonnées de performance de l'inférence.
 */
@Serializable
data class InferenceMetadata(
    val latencyMs: Long,
    val tokensPerSecond: Float
)

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLog.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLogger.kt ---

package be.heyman.android.ai.kikko.util.logging

import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

/**
 * Un logger singleton en mémoire pour conserver une trace de toutes les inférences LLM
 * effectuées pendant une session de débogage.
 *
 * NOTE : Ce logger est volatile. Son contenu est perdu lorsque l'application est fermée.
 * Déplacé depuis le package `debug` vers un nouveau package `util.logging`
 * car il est une fonctionnalité de logging générale.
 */
object InferenceLogger {

    // Configure l'encodeur JSON pour une sortie lisible (pretty print).
    private val json = Json { prettyPrint = true }

    // La liste privée et mutable qui stocke nos entrées de journal.
    private val logEntries = mutableListOf<InferenceLog>()

    /**
     * Ajoute une nouvelle entrée de journal à la liste de manière thread-safe.
     * @param entry L'objet InferenceLog à ajouter.
     */
    @Synchronized
    fun add(entry: InferenceLog) {
        logEntries.add(entry)
    }

    /**
     * Vide complètement le journal de manière thread-safe.
     */
    @Synchronized
    fun clear() {
        logEntries.clear()
    }

    /**
     * Renvoie une copie immuable de toutes les entrées du journal.
     * @return Une List<InferenceLog> des entrées actuelles.
     */
    fun getLogs(): List<InferenceLog> {
        return logEntries.toList()
    }

    /**
     * Compte le nombre d'entrées actuellement dans le journal.
     * @return Le nombre d'inférences enregistrées.
     */
    fun count(): Int {
        return logEntries.size
    }

    /**
     * Sérialise l'ensemble du journal en une chaîne de caractères JSON formatée.
     * @return Une chaîne JSON représentant la liste des entrées, ou un message d'erreur.
     */
    @Synchronized
    fun exportToJson(): String {
        if (logEntries.isEmpty()) {
            return "{\"status\": \"Le journal de forge est vide.\"}"
        }
        return try {
            json.encodeToString(logEntries)
        } catch (e: Exception) {
            "{\"error\": \"Échec de la sérialisation du journal en JSON.\", \"details\": \"${e.message}\"}"
        }
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/util/logging/InferenceLogger.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/DownloadManagerKikko.kt ---

package be.heyman.android.ai.kikko.worker

import android.content.Context
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import be.heyman.android.ai.kikko.data.KEY_MODEL_DOWNLOAD_FILE_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_IS_ZIP
import be.heyman.android.ai.kikko.data.KEY_MODEL_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_TOTAL_BYTES
import be.heyman.android.ai.kikko.data.KEY_MODEL_UNZIPPED_DIR
import be.heyman.android.ai.kikko.data.KEY_MODEL_URL
import be.heyman.android.ai.kikko.data.Model

/**
 * Manager pour initier les téléchargements de modèles via WorkManager.
 * Déplacé depuis le package `debug` car il gère les modèles locaux de l'application.
 */
object DownloadManagerKikko {

    /**
     * Lance le téléchargement d'un modèle spécifié.
     * Le modèle est identifié par son nom unique pour éviter les téléchargements multiples.
     *
     * @param context Contexte de l'application.
     * @param model Le modèle à télécharger.
     */
    fun startDownload(context: Context, model: Model) {
        val workManager = WorkManager.getInstance(context.applicationContext)

        val inputData = Data.Builder()
            .putString(KEY_MODEL_NAME, model.name)
            .putString(KEY_MODEL_URL, model.url)
            .putString(KEY_MODEL_DOWNLOAD_FILE_NAME, model.downloadFileName)
            .putLong(KEY_MODEL_TOTAL_BYTES, model.sizeInBytes)
            .putBoolean(KEY_MODEL_IS_ZIP, model.isZip)
            .putString(KEY_MODEL_UNZIPPED_DIR, model.unzipDir)
            .build()

        val downloadWorkRequest = OneTimeWorkRequestBuilder<KikkoDownloadWorker>()
            .setInputData(inputData)
            .addTag(model.name) // On utilise le nom comme tag unique pour identifier ce travail
            .build()

        workManager.enqueueUniqueWork(
            model.name, // Nom unique pour la tâche de téléchargement
            ExistingWorkPolicy.REPLACE, // Remplace la tâche si elle existe déjà
            downloadWorkRequest
        )
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/DownloadManagerKikko.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/ForgeWorker.kt ---

package be.heyman.android.ai.kikko.worker

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.pm.ServiceInfo
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import be.heyman.android.ai.kikko.KikkoApplication
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.ToolsDialogFragment
import be.heyman.android.ai.kikko.data.Model
import be.heyman.android.ai.kikko.forge.ForgeLlmHelper
import be.heyman.android.ai.kikko.forge.PromptGenerator
import be.heyman.android.ai.kikko.model.CardStats
import be.heyman.android.ai.kikko.model.KnowledgeCard
import be.heyman.android.ai.kikko.model.ModelConfiguration
import be.heyman.android.ai.kikko.model.PollenGrain
import be.heyman.android.ai.kikko.model.PollenStatus
import be.heyman.android.ai.kikko.model.QuizQuestion
import be.heyman.android.ai.kikko.model.Reasoning
import be.heyman.android.ai.kikko.model.SwarmAnalysisResult
import be.heyman.android.ai.kikko.model.TranslatedContent
import be.heyman.android.ai.kikko.persistence.CardDao
import be.heyman.android.ai.kikko.persistence.PollenGrainDao
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Locale

class ForgeWorker(val appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {

    private val pollenGrainDao: PollenGrainDao = (appContext.applicationContext as KikkoApplication).pollenGrainDao
    private val cardDao: CardDao = (appContext.applicationContext as KikkoApplication).cardDao
    private val llmHelper: ForgeLlmHelper = (appContext.applicationContext as KikkoApplication).forgeLlmHelper
    private val gson = Gson()
    private val targetLanguages = mapOf("fr" to "French", "ja" to "Japanese")

    private data class IdentificationResult(
        val reasoning: Reasoning,
        val deckName: String,
        val specificName: String,
        val confidence: Float
    )
    private data class StatsResponse(val stats: Map<String, String>?)
    private data class FoodStatsResult(
        val stats: Map<String, String>?,
        val ingredients: List<String>?,
        val allergens: List<String>?
    )
    private data class BiologicalNamesResult(
        val scientificName: String?,
        val vernacularName: String?
    )

    companion object {
        const val TAG = "ForgeWorker"
        const val NOTIFICATION_ID = 1001
        const val NOTIFICATION_CHANNEL_ID = "KikkoForgeChannel"
        private const val THUMBNAIL_SIZE = 256

        val processingOrder = listOf(
            PollenStatus.RAW,
            PollenStatus.PENDING_DESCRIPTION,
            PollenStatus.PENDING_STATS,
            PollenStatus.PENDING_QUIZ,
            PollenStatus.PENDING_TRANSLATION
        )
    }

    override suspend fun doWork(): Result {
        Log.i(TAG, "WORKER MONOLITHIQUE DÉMARRÉ.")
        setForeground(createForegroundInfo("La Forge s'éveille..."))

        try {
            for (statusToProcess in processingOrder) {
                while (true) {
                    val grain = pollenGrainDao.getByStatus(statusToProcess).firstOrNull() ?: break
                    Log.i(TAG, "Traitement du grain ${grain.id} au statut $statusToProcess")

                    val thumbnail = withContext(Dispatchers.IO) { grain.pollenImagePaths.firstOrNull()?.let { createThumbnail(BitmapFactory.decodeFile(it), THUMBNAIL_SIZE) } }

                    try {
                        when (grain.status) {
                            PollenStatus.RAW -> {
                                setForeground(createForegroundInfo("Étape 1/5: Identification du Pollen...", thumbnail))
                                val card = runIdentification(grain)
                                pollenGrainDao.updateForgingResult(grain.id, PollenStatus.PENDING_DESCRIPTION, card.id)
                            }
                            PollenStatus.PENDING_DESCRIPTION -> {
                                setForeground(createForegroundInfo("Étape 2/5: Génération de la Description...", thumbnail))
                                runDescription(grain.forgedCardId!!)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_STATS)
                            }
                            PollenStatus.PENDING_STATS -> {
                                setForeground(createForegroundInfo("Étape 3/5: Extraction des Statistiques...", thumbnail))
                                runStats(grain.forgedCardId!!, grain.swarmAnalysisReportJson)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_QUIZ)
                            }
                            PollenStatus.PENDING_QUIZ -> {
                                setForeground(createForegroundInfo("Étape 4/5: Création du Quiz...", thumbnail))
                                runQuiz(grain.forgedCardId!!)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.PENDING_TRANSLATION)
                            }
                            PollenStatus.PENDING_TRANSLATION -> {
                                setForeground(createForegroundInfo("Étape 5/5: Traduction du Miel...", thumbnail))
                                runTranslation(grain.forgedCardId!!)
                                pollenGrainDao.updateStatus(grain.id, PollenStatus.FORGED)
                                Log.i(TAG, "FORGE TERMINÉE AVEC SUCCÈS pour le grain ${grain.id}.")
                            }
                            else -> Log.w(TAG, "Statut inattendu trouvé: ${grain.status}")
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "ÉCHEC d'une étape pour le grain ${grain.id}", e)
                        pollenGrainDao.updateStatus(grain.id, PollenStatus.ERROR)
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Une erreur générale a interrompu le worker", e)
            return Result.failure()
        }

        Log.i(TAG, "Toutes les tâches disponibles sont terminées. Le worker va se rendormir.")
        return Result.success()
    }

    private suspend fun runIdentification(grain: PollenGrain): KnowledgeCard {
        val config = getQueenModelConfig()
        try {
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = config.modelName.contains("gemma-3n", ignoreCase = true))

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = true)
            if (initError != null) throw RuntimeException("Échec de l'initialisation (Identification): $initError")

            val swarmReportJson = grain.swarmAnalysisReportJson ?: throw IOException("Rapport d'essaim manquant.")
            val prompt = PromptGenerator.generateIdentificationPrompt(swarmReportJson)
            val bitmaps = withContext(Dispatchers.IO) { grain.pollenImagePaths.mapNotNull { BitmapFactory.decodeFile(it) } }

            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, bitmaps, config)
            val result = parseIntelligentJson<IdentificationResult>(fullResponse) ?: throw IOException("Réponse d'identification invalide: $fullResponse")

            val newCard = KnowledgeCard(
                specificName = result.specificName, deckName = result.deckName,
                imagePath = grain.pollenImagePaths.firstOrNull(), confidence = result.confidence,
                reasoning = result.reasoning, description = null, stats = null, allergens = null, ingredients = null, quiz = null, translations = null,
                scientificName = null, vernacularName = null
            )
            val newId = cardDao.insert(newCard)
            return newCard.copy(id = newId)
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runDescription(cardId: Long) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour la description.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("Échec de l'initialisation (Description): $initError")

            val prompt = PromptGenerator.generateNarrationDescriptionPrompt(card.specificName, card.deckName, Locale.getDefault())
            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)
            cardDao.updateDescription(cardId, fullResponse.trim())
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runStats(cardId: Long, swarmReportJson: String?) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour les stats.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("Échec de l'initialisation (Stats): $initError")

            val ocr = gson.fromJson(swarmReportJson, SwarmAnalysisResult::class.java)?.reports?.joinToString("\n") { it.ocrText }?.trim() ?: ""
            val prompt = PromptGenerator.generateStatsExtractionPrompt(card.specificName, card.deckName, ocr, card.description ?: "")
            if (prompt.isBlank()) {
                Log.w(TAG, "Aucun prompt généré pour le deck ${card.deckName}. Pas de stats à extraire.")
                return
            }

            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)

            if (card.deckName == "Food") {
                val foodResult = parseIntelligentJson<FoodStatsResult>(fullResponse)
                cardDao.updateStats(cardId, foodResult?.stats?.let { CardStats("Statistics", it) }, foodResult?.allergens, foodResult?.ingredients)
            } else {
                val statsResult = parseIntelligentJson<StatsResponse>(fullResponse)
                cardDao.updateStats(cardId, statsResult?.stats?.let { CardStats("Statistics", it) }, null, null)

                if (card.deckName == "Plant" || card.deckName == "Insect" || card.deckName == "Bird") {
                    val biologicalNamesResult = parseIntelligentJson<BiologicalNamesResult>(fullResponse)
                    cardDao.updateScientificAndVernacularNames(cardId, biologicalNamesResult?.scientificName, biologicalNamesResult?.vernacularName)
                }
            }
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runQuiz(cardId: Long) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour le quiz.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("Échec de l'initialisation (Quiz): $initError")

            val prompt = PromptGenerator.generateQuizPrompt(card.specificName, card.description ?: "", card.stats, Locale.getDefault())
            val fullResponse = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)
            val quiz = parseIntelligentJson<List<QuizQuestion>>(fullResponse) ?: throw IOException("La Reine IA a fourni un quiz vide ou dans un format invalide. Réponse brute: $fullResponse")
            cardDao.updateQuiz(cardId, quiz)
        } finally {
            llmHelper.cleanUp()
        }
    }

    private suspend fun runTranslation(cardId: Long) {
        val config = getQueenModelConfig()
        try {
            val card = cardDao.getCardById(cardId) ?: throw IOException("Carte $cardId introuvable pour la traduction.")
            val modelFile = File(appContext.filesDir, "imported_models").resolve(config.modelName)
            if (!modelFile.exists()) throw IOException("Fichier de la Reine IA '${config.modelName}' introuvable.")
            val queenModel = Model(name = config.modelName, url = modelFile.absolutePath, downloadFileName = "", sizeInBytes = 0, llmSupportImage = false)

            val initError = llmHelper.initialize(queenModel, config.accelerator, isMultimodal = false)
            if (initError != null) throw RuntimeException("Échec de l'initialisation (Traduction): $initError")
            val newTranslations = card.translations?.toMutableMap() ?: mutableMapOf()

            for ((langCode, langName) in targetLanguages) {
                if (newTranslations.containsKey(langCode)) continue
                Log.d(TAG, "Traduction en cours vers '$langName'...")

                val originalContent = TranslatableCardContent(card.description, card.reasoning, card.quiz)
                val originalJson = gson.toJson(originalContent)
                val prompt = PromptGenerator.generateFullCardTranslationPrompt(originalJson, langName)
                val translatedJson = llmHelper.inferenceWithCoroutineAndConfig(prompt, emptyList(), config)
                val translatedContent = parseIntelligentJson<TranslatedContent>(translatedJson)

                if(translatedContent != null) {
                    newTranslations[langCode] = translatedContent
                } else {
                    Log.w(TAG, "Échec du parsing de la traduction pour la langue $langName. Réponse brute: $translatedJson")
                }
            }
            cardDao.updateTranslations(cardId, newTranslations)
        } finally {
            llmHelper.cleanUp()
        }
    }

    private fun getQueenModelConfig(): ModelConfiguration {
        val prefs = appContext.getSharedPreferences(ToolsDialogFragment.PREFS_NAME, Context.MODE_PRIVATE)
        val name = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN, null) ?: throw IllegalStateException("Aucune Reine IA sélectionnée.")
        val accelerator = prefs.getString(ToolsDialogFragment.KEY_SELECTED_FORGE_QUEEN_ACCELERATOR, "GPU")!!
        val temperature = prefs.getFloat("forge_temp", 0.2f)
        val topK = prefs.getInt("forge_topK", 40)
        return ModelConfiguration(name, accelerator, temperature, topK)
    }

    private inline fun <reified T> parseIntelligentJson(rawString: String): T? {
        return try {
            val jsonSubstring = rawString.substringAfter("```json", rawString).substringBeforeLast("```").trim()
            val type = object : TypeToken<T>() {}.type
            gson.fromJson(jsonSubstring, type)
        } catch (e: Exception) {
            Log.e(TAG, "Le parsing intelligent a échoué pour le type ${T::class.java.simpleName}: '$rawString'", e)
            null
        }
    }

    override suspend fun getForegroundInfo(): ForegroundInfo = createForegroundInfo("La Forge de la Ruche se prépare...")

    private fun createThumbnail(source: Bitmap?, size: Int): Bitmap? {
        if (source == null) return null
        val scaledWidth = if (source.width > source.height) size * source.width / source.height else size
        val scaledHeight = if (source.height >= source.width) size * source.height / source.width else size
        return Bitmap.createScaledBitmap(source, scaledWidth, scaledHeight, false)
    }

    private fun createForegroundInfo(progress: String, thumbnail: Bitmap? = null): ForegroundInfo {
        val channelId = NOTIFICATION_CHANNEL_ID
        val channelName = "Forge Kikko en Arrière-Plan"
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_LOW)
            val notificationManager = appContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }

        val notificationBuilder = NotificationCompat.Builder(applicationContext, channelId)
            .setContentTitle("La Ruche travaille...")
            .setContentText(progress)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setOngoing(true)
            .setProgress(100, 0, true)

        if (thumbnail != null) {
            notificationBuilder.setLargeIcon(thumbnail)
        }

        val notification = notificationBuilder.build()

        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ForegroundInfo(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)
        } else {
            ForegroundInfo(NOTIFICATION_ID, notification)
        }
    }

    private data class TranslatableCardContent(
        val description: String?,
        val reasoning: Reasoning?,
        val quiz: List<QuizQuestion>?
    )
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/ForgeWorker.kt ---


--- START OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/KikkoDownloadWorker.kt ---

package be.heyman.android.ai.kikko.worker

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import be.heyman.android.ai.kikko.R
import be.heyman.android.ai.kikko.data.KEY_MODEL_DOWNLOAD_FILE_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_DOWNLOAD_REMAINING_MS
import be.heyman.android.ai.kikko.data.KEY_MODEL_IS_ZIP
import be.heyman.android.ai.kikko.data.KEY_MODEL_NAME
import be.heyman.android.ai.kikko.data.KEY_MODEL_START_UNZIPPING
import be.heyman.android.ai.kikko.data.KEY_MODEL_TOTAL_BYTES
import be.heyman.android.ai.kikko.data.KEY_MODEL_UNZIPPED_DIR
import be.heyman.android.ai.kikko.data.KEY_MODEL_URL
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.delay
import java.io.BufferedInputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URL
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

/**
 * Worker Hilt pour le téléchargement et la décompression de modèles.
 * Déplacé depuis le package `debug` car il est central à la gestion des modèles.
 */
class KikkoDownloadWorker(val context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {

    companion object {
        const val ACTION_PROGRESS_UPDATE = "com.google.edge.kikko.debug.PROGRESS_UPDATE"
        const val EXTRA_MODEL_NAME = "EXTRA_MODEL_NAME"
        const val EXTRA_RECEIVED_BYTES = "EXTRA_RECEIVED_BYTES"
        const val EXTRA_TOTAL_BYTES = "EXTRA_TOTAL_BYTES"
        const val EXTRA_DOWNLOAD_SPEED_BPS = "EXTRA_DOWNLOAD_SPEED_BPS"
        const val NOTIFICATION_CHANNEL_ID = "kikko_download_channel"
    }

    private val TAG = "KikkoDownloadWorker"
    private val notificationManager = NotificationManagerCompat.from(applicationContext)

    init {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Téléchargements de modèles Kikko",
                NotificationManager.IMPORTANCE_LOW
            )
            notificationManager.createNotificationChannel(channel)
        }
    }

    override suspend fun doWork(): Result {
        val modelName = inputData.getString(KEY_MODEL_NAME) ?: return Result.failure()
        val fileUrl = inputData.getString(KEY_MODEL_URL) ?: return Result.failure()
        val fileName = inputData.getString(KEY_MODEL_DOWNLOAD_FILE_NAME) ?: return Result.failure()
        val estimatedTotalBytes = inputData.getLong(KEY_MODEL_TOTAL_BYTES, 0L)
        val isZip = inputData.getBoolean(KEY_MODEL_IS_ZIP, false)
        val unzipDir = inputData.getString(KEY_MODEL_UNZIPPED_DIR)

        val modelBaseDir = File(applicationContext.getExternalFilesDir(null), "imported_models") // BOURDON'S FIX: Utilisation du dossier "imported_models"
        if (!modelBaseDir.exists()) modelBaseDir.mkdirs()
        val modelDir = File(modelBaseDir, modelName)
        if (!modelDir.exists()) modelDir.mkdirs()

        val outputFile = File(modelDir, fileName)

        try {
            setForeground(createForegroundInfo("Démarrage du téléchargement pour $modelName", 0))
            downloadFile(fileUrl, outputFile, estimatedTotalBytes, modelName)

            if (isZip) { // BOURDON'S FIX: Le dossier de décompression est maintenant le dossier du modèle lui-même, pas un sous-dossier spécifié par `unzipDir`
                setForeground(createForegroundInfo("Décompression de $modelName...", 0, true))
                setProgress(Data.Builder().putBoolean(KEY_MODEL_START_UNZIPPING, true).build())
                unzip(outputFile, modelDir) // Décompresse directement dans le dossier du modèle
                outputFile.delete() // Supprime le fichier zip après décompression
            }
            return Result.success()
        } catch (e: Exception) {
            if (e is CancellationException || e is InterruptedException) {
                Log.i(TAG, "Download cancelled for $modelName")
            } else {
                Log.e(TAG, "Download or Unzip failed for $modelName", e)
                if(outputFile.exists()) outputFile.delete()
                return Result.failure()
            }
            return Result.success() // En cas d'annulation, on termine le worker proprement
        }
    }

    private suspend fun downloadFile(downloadUrl: String, outputFile: File, estimatedTotalBytes: Long, modelName: String) {
        val url = URL(downloadUrl)
        val connection = url.openConnection() as HttpURLConnection
        connection.connect()

        if (connection.responseCode != HttpURLConnection.HTTP_OK) {
            throw IOException("Server returned HTTP ${connection.responseCode} ${connection.responseMessage}")
        }

        val actualTotalBytes = if (connection.contentLength > 0) connection.contentLength.toLong() else estimatedTotalBytes

        val inputStream = connection.inputStream
        val outputStream = FileOutputStream(outputFile)
        val buffer = ByteArray(8 * 1024)
        var bytesCopied: Long = 0
        var bytesRead: Int
        var lastReportTime = System.currentTimeMillis()
        var lastReportedBytes: Long = 0
        val bytesReadSizeBuffer: MutableList<Long> = mutableListOf()
        val bytesReadLatencyBuffer: MutableList<Long> = mutableListOf()

        try {
            while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                if (isStopped) throw InterruptedException("Download cancelled")
                outputStream.write(buffer, 0, bytesRead)
                bytesCopied += bytesRead

                val currentTime = System.currentTimeMillis()
                if (currentTime - lastReportTime >= 500) { // Update notification less frequently
                    val timeDelta = (currentTime - lastReportTime)
                    val bytesDelta = bytesCopied - lastReportedBytes
                    val speedBps = if (timeDelta > 0) (bytesDelta * 1000 / timeDelta) else 0L

                    var remainingMs = -1L
                    bytesReadSizeBuffer.add(bytesDelta)
                    if (bytesReadSizeBuffer.size > 5) bytesReadSizeBuffer.removeAt(0)
                    bytesReadLatencyBuffer.add(timeDelta)
                    if (bytesReadLatencyBuffer.size > 5) bytesReadLatencyBuffer.removeAt(0)

                    val totalRecentBytes = bytesReadSizeBuffer.sum()
                    val totalRecentTime = bytesReadLatencyBuffer.sum()
                    if (totalRecentTime > 0 && totalRecentBytes > 0) {
                        val avgSpeedBps = totalRecentBytes * 1000 / totalRecentTime
                        if (avgSpeedBps > 0) {
                            remainingMs = (actualTotalBytes - bytesCopied) * 1000 / avgSpeedBps
                        }
                    }

                    val progressPercent = if (actualTotalBytes > 0) (bytesCopied * 100 / actualTotalBytes).toInt() else 0
                    val progressText = "Téléchargement de $modelName ($progressPercent%)"
                    setForeground(createForegroundInfo(progressText, progressPercent))

                    val intent = Intent(ACTION_PROGRESS_UPDATE).apply {
                        putExtra(EXTRA_MODEL_NAME, modelName)
                        putExtra(EXTRA_RECEIVED_BYTES, bytesCopied)
                        putExtra(EXTRA_TOTAL_BYTES, actualTotalBytes)
                        putExtra(EXTRA_DOWNLOAD_SPEED_BPS, speedBps)
                        putExtra(KEY_MODEL_DOWNLOAD_REMAINING_MS, remainingMs)
                    }
                    LocalBroadcastManager.getInstance(context).sendBroadcast(intent)

                    lastReportTime = currentTime
                    lastReportedBytes = bytesCopied
                    delay(50)
                }
            }
        } finally {
            outputStream.close()
            inputStream.close()
        }
    }

    private fun unzip(zipFile: File, targetDirectory: File) {
        Log.d(TAG, "Unzipping ${zipFile.name} into ${targetDirectory.name}")
        ZipInputStream(BufferedInputStream(FileInputStream(zipFile))).use { zis ->
            var entry: ZipEntry? = zis.nextEntry
            while (entry != null) {
                if (isStopped) throw InterruptedException("Unzip cancelled")

                val newFile = File(targetDirectory, entry.name)
                // Protection contre les Zip Slip Attacks
                if (!newFile.canonicalPath.startsWith(targetDirectory.canonicalPath + File.separator)) {
                    throw IOException("Zip Slip Attack détectée: ${entry.name}")
                }

                if (entry.isDirectory) {
                    if (!newFile.isDirectory && !newFile.mkdirs()) {
                        throw IOException("Échec de la création du répertoire ${newFile.absolutePath}")
                    }
                } else {
                    val parent = newFile.parentFile
                    if (parent != null && !parent.isDirectory && !parent.mkdirs()) {
                        throw IOException("Échec de la création du répertoire parent ${parent.absolutePath}")
                    }
                    FileOutputStream(newFile).use { fos -> zis.copyTo(fos) }
                }
                zis.closeEntry()
                entry = zis.nextEntry
            }
        }
    }

    override suspend fun getForegroundInfo(): ForegroundInfo {
        return createForegroundInfo("Préparation du téléchargement...", 0)
    }

    private fun createForegroundInfo(text: String, progress: Int, indeterminate: Boolean = false): ForegroundInfo {
        val notification = NotificationCompat.Builder(applicationContext, NOTIFICATION_CHANNEL_ID)
            .setContentTitle("Forge de la Ruche Kikko")
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_launcher_foreground) // Assurez-vous d'avoir une icône ici
            .setOngoing(true)
            .setProgress(100, progress, indeterminate)
            .build()

        return ForegroundInfo(id.hashCode(), notification)
    }
}

--- END OF FILE app/src/main/java/be/heyman/android/ai/kikko/worker/KikkoDownloadWorker.kt ---


--- START OF FILE app/src/main/res/font/luckiest_guy.xml ---

<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/luckiest_guy_regular" />
</font-family>

--- END OF FILE app/src/main/res/font/luckiest_guy.xml ---


--- START OF FILE app/src/main/res/font/poppins.xml ---

<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/poppins_regular" />
    <font
        android:fontStyle="normal"
        android:fontWeight="700"
        android:font="@font/poppins_bold" />
</font-family>

--- END OF FILE app/src/main/res/font/poppins.xml ---


--- START OF FILE app/src/main/res/layout/activity_clash_arena.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/clash_arena_root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/kikko_bark_brown"
    tools:context=".clash.ui.ClashActivity"
    tools:ignore="ContentDescription">

    <!-- BOURDON'S REFACTOR: Le ViewPager pour les duels -->
    <androidx.viewpager2.widget.ViewPager2
        android:id="@+id/tournament_viewpager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="?attr/colorSurfaceContainer"
        android:visibility="gone"
        tools:visibility="gone" />

    <!-- BOURDON'S REFACTOR V3: Remplacement de VideoView par PlayerView pour la sélection -->
    <androidx.media3.ui.PlayerView
        android:id="@+id/clash_background_video_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:resize_mode="zoom"
        app:use_controller="false" />

    <!-- BOURDON'S REFACTOR: Le groupe pour la vue de préparation -->
    <androidx.constraintlayout.widget.Group
        android:id="@+id/clash_setup_group"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:constraint_referenced_ids="clash_background_video_view,clash_title,clash_button_random,clash_button_settings,clash_button_radar,clash_button_start_solo,player1_selection_container,player2_selection_container,clash_queen_status,guideline_center"
        android:visibility="visible"
        tools:visibility="visible"/>

    <!-- Le reste du layout reste identique -->

    <LinearLayout
        android:id="@+id/clash_judge_loading_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center"
        android:padding="24dp"
        android:background="@drawable/scroll_background"
        android:backgroundTint="#A0000000"
        android:elevation="10dp"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">
        <ProgressBar
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"/>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:text="@string/clash_judge_awakening"
            android:fontFamily="@font/luckiest_guy"
            android:textColor="@color/kikko_honey_yellow"
            android:textSize="18sp"/>
    </LinearLayout>

    <TextView
        android:id="@+id/clash_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:fontFamily="@font/luckiest_guy"
        android:shadowColor="@color/black"
        android:shadowDx="1"
        android:shadowDy="1"
        android:shadowRadius="2"
        android:text="@string/clash_title"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="34sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <ImageButton
        android:id="@+id/clash_button_random"
        style="@style/Widget.AppCompat.Button.Borderless"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginStart="16dp"
        android:layout_marginTop="16dp"
        android:src="@android:drawable/ic_menu_rotate"
        android:contentDescription="@string/clash_button_random_desc"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:tint="@color/kikko_honey_yellow" />

    <ImageButton
        android:id="@+id/clash_button_settings"
        style="@style/Widget.AppCompat.Button.Borderless"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginTop="16dp"
        android:layout_marginEnd="16dp"
        android:src="@android:drawable/ic_menu_manage"
        android:contentDescription="@string/clash_button_settings_desc"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:tint="@color/kikko_honey_yellow" />

    <ImageButton
        android:id="@+id/clash_button_radar"
        style="@style/Widget.AppCompat.Button.Borderless"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginEnd="16dp"
        android:src="@android:drawable/ic_menu_compass"
        android:contentDescription="@string/clash_button_radar_desc"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:tint="@color/kikko_honey_yellow" />

    <com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
        android:id="@+id/clash_button_start_solo"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/clash_button_start_solo"
        android:enabled="false"
        app:icon="@drawable/ic_swords"
        app:layout_constraintBottom_toTopOf="@id/clash_queen_status"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/clash_title"
        app:layout_constraintVertical_bias="0.9" />

    <LinearLayout
        android:id="@+id/player1_selection_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="4dp"
        android:layout_marginBottom="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toStartOf="@id/guideline_center">
        <FrameLayout android:id="@+id/p1_slot_food" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_food" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🍔" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_food" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p1_slot_plant" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_plant" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🌿" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_plant" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p1_slot_insect" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_insect" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🐞" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_insect" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p1_slot_bird" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p1_deck_bird" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🐦" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p1_thumb_bird" android:visibility="gone"/>
        </FrameLayout>
    </LinearLayout>
    <LinearLayout
        android:id="@+id/player2_selection_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="4dp"
        android:layout_marginBottom="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toEndOf="@id/guideline_center"
        app:layout_constraintEnd_toEndOf="parent">
        <FrameLayout android:id="@+id/p2_slot_food" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_food" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🍔" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_food" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p2_slot_plant" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_plant" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🌿" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_plant" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p2_slot_insect" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_insect" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🐞" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_insect" android:visibility="gone"/>
        </FrameLayout>
        <FrameLayout android:id="@+id/p2_slot_bird" android:layout_width="80dp" android:layout_height="100dp" android:layout_margin="4dp">
            <Button android:id="@+id/p2_deck_bird" style="@style/Widget.AppCompat.Button.Borderless" android:layout_width="match_parent" android:layout_height="match_parent" android:text="🐦" android:textSize="34sp" android:background="@drawable/scroll_background" android:clickable="false" android:focusable="false"/>
            <include layout="@layout/item_clash_champion_thumbnail" android:id="@+id/p2_thumb_bird" android:visibility="gone"/>
        </FrameLayout>
    </LinearLayout>

    <TextView
        android:id="@+id/clash_queen_status"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:background="#A0000000"
        android:gravity="center"
        android:padding="4dp"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="12sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        tools:text="La Reine est prête pour le jugement." />

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline_center"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintGuide_percent="0.5" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/p2p_panel"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:background="#E61C1C1E"
        android:elevation="16dp"
        android:translationX="2000dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintWidth_percent="0.5"
        tools:translationX="0dp">

        <be.heyman.android.ai.kikko.clash.ui.views.RadarView
            android:id="@+id/p2p_panel_radar_view"
            android:background="@drawable/radar_bourdon"
            android:layout_width="0dp"
            android:layout_height="0dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        <ImageButton
            android:id="@+id/p2p_panel_close_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_menu_close_clear_cancel"
            app:tint="@color/kikko_honey_yellow"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/p2p_panel_close_desc"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            android:layout_margin="8dp"/>

        <TextView
            android:id="@+id/p2p_panel_status_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_margin="16dp"
            android:gravity="center"
            android:textColor="@color/kikko_honey_yellow"
            app:layout_constraintBottom_toTopOf="@id/p2p_panel_recycler_view"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            tools:text="Recherche en cours..." />

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/p2p_panel_recycler_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="#99000000"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHeight_percent="0.4"
            app:layout_constraintStart_toStartOf="parent"
            tools:listitem="@layout/item_player_card" />

    </androidx.constraintlayout.widget.ConstraintLayout>

    <include
        layout="@layout/layout_card_selector_panel"
        android:id="@+id/card_selector_panel_include" />

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_clash_arena.xml ---


--- START OF FILE app/src/main/res/layout/activity_deck_selection.xml ---

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black">

    <VideoView
        android:id="@+id/background_video_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_alignParentBottom="true" />

    <FrameLayout
        android:id="@+id/main_content_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_above="@+id/bottom_navigation_bar" />

    <LinearLayout
        android:id="@+id/bottom_navigation_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="horizontal"
        android:elevation="8dp"
        android:weightSum="4">

        <!-- BOUTON 1: DECK -->
        <LinearLayout
            android:id="@+id/nav_button_deck"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Deck" />
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Deck"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>

        <!-- BOUTON 2: POLLEN -->
        <LinearLayout
            android:id="@+id/nav_button_pollen"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Pollen" />
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Pollen"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>

        <!-- BOUTON 3: RUCHE -->
        <LinearLayout
            android:id="@+id/nav_button_ruche"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Ruche"/>
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Ruche"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>

        <!-- BOUTON 4: CLASH -->
        <LinearLayout
            android:id="@+id/nav_button_clash"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center"
            android:paddingVertical="8dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless">
            <ImageView
                android:layout_width="92dp"
                android:layout_height="92dp"
                android:contentDescription="Clash"/>
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Clash"
                android:textSize="12sp"
                android:textColor="@color/kikko_gold"/>
        </LinearLayout>
    </LinearLayout>

</RelativeLayout>

--- END OF FILE app/src/main/res/layout/activity_deck_selection.xml ---


--- START OF FILE app/src/main/res/layout/activity_deck_viewer.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black"
    tools:context=".deck.DeckViewerActivity">

    <VideoView
        android:id="@+id/background_video_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/top_guideline"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_percent="0.45" />

    <!-- BOURDON'S FIX: Augmentation du nombre de colonnes pour des cartes plus petites -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/deck_cards_recyclerview"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:clipToPadding="false"
        android:paddingStart="8dp"
        android:paddingEnd="8dp"
        android:paddingTop="8dp"
        android:paddingBottom="8dp"
        app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
        app:spanCount="3"
        app:layout_constraintTop_toTopOf="@id/top_guideline"
        app:layout_constraintBottom_toTopOf="@id/deck_selection_bar"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:listitem="@layout/item_clash_deck_thumbnail" />

    <LinearLayout
        android:id="@+id/deck_selection_bar"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:background="#A0000000"
        android:orientation="horizontal"
        android:paddingVertical="4dp"
        android:weightSum="4"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:id="@+id/deck_button_food"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_food_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_food"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_food"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/deck_button_plant"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_plant_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_plant"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_plant"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/deck_button_insect"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_insect_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_insect"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_insect"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/deck_button_bird"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="8dp"
            android:contentDescription="@string/deck_select_bird_desc">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_emoji_bird"
                android:textSize="24sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/deck_name_bird"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="12sp" />
        </LinearLayout>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_deck_viewer.xml ---


--- START OF FILE app/src/main/res/layout/activity_forge_live.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".pollen.ForgeLiveActivity">

    <androidx.camera.view.PreviewView
        android:id="@+id/live_preview_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <ImageView
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:alpha="0.7"
        android:scaleType="centerCrop"
        android:src="@drawable/kikko_pollen"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:contentDescription="Fond d'écran de la forge de pollen" />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/captured_pollen_recyclerview"
        android:layout_width="0dp"
        android:layout_height="110dp"
        android:orientation="horizontal"
        android:clipToPadding="false"
        android:paddingStart="16dp"
        android:paddingEnd="16dp"
        android:paddingTop="8dp"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:listitem="@layout/item_pollen_preview"
        tools:visibility="visible"/>

    <LinearLayout
        android:id="@+id/bourdon_dialogue_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center_horizontal"
        android:padding="16dp"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintTop_toBottomOf="@id/captured_pollen_recyclerview"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <ImageView
                android:id="@+id/bourdon_avatar"
                android:layout_width="64dp"
                android:layout_height="64dp"
                android:src="@mipmap/ic_launcher"
                android:contentDescription="@string/bourdon_avatar_desc"/>

            <com.google.android.material.card.MaterialCardView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginStart="16dp"
                app:cardBackgroundColor="?attr/colorSurface"
                app:cardCornerRadius="12dp">

                <TextView
                    android:id="@+id/bourdon_message_textview"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:padding="12dp"
                    android:textAppearance="?attr/textAppearanceBodyLarge"
                    tools:text="@string/bourdon_message_placeholder"/>
            </com.google.android.material.card.MaterialCardView>
        </LinearLayout>

    </LinearLayout>

    <ToggleButton
        android:visibility="gone"
        android:id="@+id/facing_switch"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginStart="16dp"
        android:layout_marginBottom="16dp"
        android:background="@android:drawable/ic_menu_camera"
        android:contentDescription="@string/button_switch_camera_desc"
        android:textOff=""
        android:textOn=""
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent" />

    <LinearLayout
        android:id="@+id/capture_button_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:visibility="gone"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.95">

        <Button
            android:id="@+id/finish_harvest_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_finish_harvest"
            android:layout_marginEnd="8dp"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Button
            android:id="@+id/capture_and_forge_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/pollen_capture_button_default" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/final_choice_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.95">

        <Button
            android:id="@+id/restart_harvest_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_restart_harvest"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/send_to_hive_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_send_to_hive" />

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_forge_live.xml ---


--- START OF FILE app/src/main/res/layout/activity_forge_workshop.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".forge.ForgeWorkshopActivity">



    <!-- BOURDON'S REFORGE: Le contenu principal est maintenant dans un ConstraintLayout pour mieux gérer la barre du bas -->
    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <TextView
            android:id="@+id/workshop_status_message"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:background="?attr/colorSurface"
            android:gravity="center"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyMedium"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="3 grains de pollen attendent votre expertise." />

        <ProgressBar
            android:id="@+id/workshop_progress_bar"
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:indeterminate="true"
            android:visibility="gone"
            app:layout_constraintTop_toBottomOf="@id/workshop_status_message"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:visibility="visible" />

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/workshop_grains_recyclerview"
            android:layout_width="0dp"
            android:layout_height="150dp"
            android:clipToPadding="false"
            android:orientation="horizontal"
            android:padding="8dp"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            app:layout_constraintTop_toBottomOf="@id/workshop_progress_bar"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:listitem="@layout/item_pollen_grain_preview" />

        <com.google.android.material.divider.MaterialDivider
            android:id="@+id/workshop_divider"
            android:layout_width="0dp"
            android:layout_height="2dp"
            app:layout_constraintTop_toBottomOf="@id/workshop_grains_recyclerview"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <androidx.core.widget.NestedScrollView
            android:id="@+id/workshop_detail_container"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:visibility="gone"
            app:layout_constraintTop_toBottomOf="@id/workshop_divider"
            app:layout_constraintBottom_toTopOf="@id/workshop_filter_bar"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:visibility="visible">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <!-- Le contenu détaillé du grain (image, nom, propriétés) reste identique -->
                <TextView
                    android:id="@+id/grain_id_label"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="end"
                    android:textAppearance="?attr/textAppearanceCaption"
                    tools:text="Grain ID: a1b2c3d4..."/>

                <com.google.android.material.card.MaterialCardView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">
                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:padding="8dp">
                        <ImageView
                            android:id="@+id/workshop_selected_image"
                            android:layout_width="100dp"
                            android:layout_height="100dp"
                            android:scaleType="centerCrop"
                            android:contentDescription="@string/workshop_selected_image_desc"
                            tools:src="@tools:sample/backgrounds/scenic"/>
                        <LinearLayout
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:orientation="vertical"
                            android:layout_marginStart="16dp">
                            <TextView
                                android:id="@+id/workshop_selected_name"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAppearance="?attr/textAppearanceTitleLarge"
                                tools:text="Dandelion"/>
                            <TextView
                                android:id="@+id/workshop_selected_deck"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAppearance="?attr/textAppearanceTitleSmall"
                                tools:text="Deck: Plant"/>

                            <Button
                                android:id="@+id/workshop_delete_grain_button"
                                style="?attr/materialButtonOutlinedStyle"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:layout_marginTop="8dp"
                                android:text="@string/workshop_button_reject_grain"
                                app:icon="@android:drawable/ic_menu_delete"
                                app:iconTint="?attr/colorError"
                                android:textColor="?attr/colorError"
                                app:strokeColor="?attr/colorError" />

                        </LinearLayout>
                    </LinearLayout>
                </com.google.android.material.card.MaterialCardView>

                <LinearLayout
                    android:id="@+id/workshop_properties_container"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="16dp" />

            </LinearLayout>
        </androidx.core.widget.NestedScrollView>

        <!-- BOURDON'S REFORGE: La nouvelle barre de filtres en bas -->
        <LinearLayout
            android:id="@+id/workshop_filter_bar"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:background="?attr/colorSurfaceContainer"
            android:orientation="horizontal"
            android:paddingVertical="4dp"
            android:elevation="4dp"
            android:weightSum="5"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent">

            <LinearLayout
                android:id="@+id/filter_button_raw"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/workshop_filter_raw_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_raw"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_raw"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_food"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_food_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_food"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_food"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_plant"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_plant_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_plant"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_plant"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_insect"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_insect_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_insect"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_insect"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/filter_button_bird"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="8dp"
                android:contentDescription="@string/deck_select_bird_desc">
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_emoji_bird"
                    android:textSize="24sp" />
                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/deck_name_bird"
                    android:textColor="?attr/colorOnSurface"
                    android:textSize="12sp" />
            </LinearLayout>
        </LinearLayout>
    </androidx.constraintlayout.widget.ConstraintLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>

--- END OF FILE app/src/main/res/layout/activity_forge_workshop.xml ---


--- START OF FILE app/src/main/res/layout/activity_prompt_editor.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".prompt.PromptEditorActivity">

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/prompt_editor_appbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <!-- BOURDON'S DEFINITIVE FIX:
             - Le style est explicitement forcé pour éviter tout héritage parasite.
             - Il n'y a AUCUN élément enfant à l'intérieur de cette balise. -->
        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/prompt_editor_toolbar"
            style="@style/Widget.Material3.Toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:menu="@menu/prompt_editor_menu"
            app:navigationIcon="@drawable/ic_close"
            app:title="@string/prompt_editor_title" />

    </com.google.android.material.appbar.AppBarLayout>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/prompt_selector_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="@string/prompt_selector_label"
                android:textAppearance="?attr/textAppearanceLabelLarge" />

            <Spinner
                android:id="@+id/prompt_selector_spinner"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"

                android:minHeight="48dp" />

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/prompt_editor_layout"
                style="?attr/textInputOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/prompt_editor_hint">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/prompt_editor_edittext"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="top"
                    android:inputType="textMultiLine"
                    android:minHeight="300dp"
                    android:scrollbars="vertical"
                    android:textColor="@color/kikko_gold"
                    android:typeface="monospace" />

            </com.google.android.material.textfield.TextInputLayout>

            <Button
                android:id="@+id/prompt_editor_save_button"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:text="@string/button_save_prompts"
                app:icon="@android:drawable/ic_menu_save" />

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

</androidx.coordinatorlayout.widget.CoordinatorLayout>

--- END OF FILE app/src/main/res/layout/activity_prompt_editor.xml ---


--- START OF FILE app/src/main/res/layout/activity_quiz.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".quiz.QuizActivity">

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/quiz_appbar"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/quiz_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:navigationIcon="@drawable/ic_close"
            tools:title="Quiz : Abeille Domestique" />
    </com.google.android.material.appbar.AppBarLayout>

    <TextView
        android:id="@+id/quiz_progress_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="24dp"
        android:textAppearance="?attr/textAppearanceTitleMedium"
        app:layout_constraintTop_toBottomOf="@id/quiz_appbar"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:text="Question 1 / 4" />

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/quiz_question_card"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        app:layout_constraintTop_toBottomOf="@id/quiz_progress_textview"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <TextView
            android:id="@+id/quiz_question_textview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="16dp"
            android:minHeight="100dp"
            android:gravity="center"
            android:textAppearance="?attr/textAppearanceHeadlineSmall"
            tools:text="Quelle est la vitesse de vol moyenne d'une abeille ?" />
    </com.google.android.material.card.MaterialCardView>

    <RadioGroup
        android:id="@+id/quiz_answers_radiogroup"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        app:layout_constraintTop_toBottomOf="@id/quiz_question_card"
        app:layout_constraintStart_toStartOf="@id/quiz_question_card"
        app:layout_constraintEnd_toEndOf="@id/quiz_question_card">

        <RadioButton
            android:id="@+id/quiz_answer_1"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="10 km/h" />

        <RadioButton
            android:id="@+id/quiz_answer_2"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="24 km/h" />

        <RadioButton
            android:id="@+id/quiz_answer_3"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="40 km/h" />

        <RadioButton
            android:id="@+id/quiz_answer_4"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:padding="12dp"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            tools:text="5 km/h" />
    </RadioGroup>

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/quiz_feedback_card"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginHorizontal="16dp"
        android:layout_marginBottom="16dp"
        android:visibility="gone"
        tools:visibility="visible"
        app:cardBackgroundColor="@color/kikko_leaf_green"
        app:layout_constraintBottom_toTopOf="@id/quiz_submit_button"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">
        <TextView
            android:id="@+id/quiz_feedback_textview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="16dp"
            android:gravity="center"
            android:textAppearance="?attr/textAppearanceBodyLarge"
            android:textColor="?attr/colorOnPrimaryContainer"
            tools:text="Bonne réponse !"/>
    </com.google.android.material.card.MaterialCardView>

    <Button
        android:id="@+id/quiz_submit_button"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Valider"
        android:layout_margin="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <Button
        android:id="@+id/quiz_next_button"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Question Suivante"
        android:visibility="gone"
        android:layout_margin="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/activity_quiz.xml ---


--- START OF FILE app/src/main/res/layout/activity_royal_audience.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S REFORGE V3: Remplacement par RelativeLayout pour une gestion robuste du clavier avec adjustResize -->
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/audience_root_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurfaceContainer"
    tools:context=".royal_audience.RoyalAudienceActivity">

    <androidx.media3.ui.PlayerView
        android:id="@+id/audience_background_video_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:resize_mode="zoom"
        app:use_controller="false" />

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/audience_app_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:color/transparent"
        android:fitsSystemWindows="true"
        app:elevation="0dp">

        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/audience_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize">

            <androidx.constraintlayout.widget.ConstraintLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent">

                <ImageButton
                    android:id="@+id/audience_back_button"
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:src="?attr/homeAsUpIndicator"
                    android:background="?attr/selectableItemBackgroundBorderless"
                    android:contentDescription="@string/audience_button_back_description"
                    app:tint="?attr/colorOnSurface"
                    app:layout_constraintStart_toStartOf="parent"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintBottom_toBottomOf="parent"/>

                <LinearLayout
                    android:id="@+id/audience_model_selector_container"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:gravity="center_horizontal"
                    android:background="?attr/selectableItemBackground"
                    android:clickable="true"
                    android:focusable="true"
                    android:paddingStart="16dp"
                    android:paddingEnd="16dp"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintBottom_toBottomOf="parent"
                    app:layout_constraintStart_toStartOf="parent"
                    app:layout_constraintEnd_toEndOf="parent">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/audience_toolbar_title"
                        android:textAppearance="?attr/textAppearanceLabelMedium"
                        android:textColor="?attr/colorOnSurfaceVariant"/>

                    <LinearLayout
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:gravity="center_vertical">

                        <ImageView
                            android:layout_width="16dp"
                            android:layout_height="16dp"
                            android:src="@drawable/ic_circle_dot"
                            app:tint="?attr/colorPrimary"/>

                        <TextView
                            android:id="@+id/audience_model_name"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:layout_marginStart="4dp"
                            android:textAppearance="?attr/textAppearanceTitleSmall"
                            android:textColor="?attr/colorOnSurface"
                            tools:text="Qwen2.5-1.5B-Instruct q8" />

                    </LinearLayout>
                </LinearLayout>

                <ImageButton
                    android:id="@+id/audience_settings_button"
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:src="@drawable/ic_settings_sliders"
                    android:background="?attr/selectableItemBackgroundBorderless"
                    android:contentDescription="@string/audience_button_settings_description"
                    app:layout_constraintEnd_toEndOf="parent"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintBottom_toBottomOf="parent"/>

            </androidx.constraintlayout.widget.ConstraintLayout>

        </com.google.android.material.appbar.MaterialToolbar>
    </com.google.android.material.appbar.AppBarLayout>

    <include
        android:id="@+id/audience_input_bar"
        layout="@layout/layout_chat_input_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true" />

    <FrameLayout
        android:id="@+id/audience_image_preview_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_above="@id/audience_input_bar"
        android:visibility="gone"
        tools:visibility="visible">
    </FrameLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/audience_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/audience_app_bar"
        android:layout_above="@id/audience_image_preview_container"
        android:clipToPadding="false"
        android:padding="8dp"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        tools:listitem="@layout/item_chat_queen" />

</RelativeLayout>

--- END OF FILE app/src/main/res/layout/activity_royal_audience.xml ---


--- START OF FILE app/src/main/res/layout/activity_start.xml ---

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black"
    tools:context=".StartActivity">

    <!-- Le reste du fichier est identique -->

    <VideoView
        android:id="@+id/background_video_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_alignParentBottom="true" />

    <!-- BOURDON'S FIX: Ajout d'un ID au conteneur principal pour la gestion des insets -->
    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/start_root_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <TextView
            android:id="@+id/start_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="32dp"
            android:fontFamily="@font/luckiest_guy"
            android:text="KiKKo's\nSaga Forge"
            android:textAlignment="center"
            android:textColor="@color/kikko_honey_yellow"
            android:textSize="40sp"
            android:shadowColor="@color/kikko_bark_brown"
            android:shadowDx="2"
            android:shadowDy="2"
            android:shadowRadius="3"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        <ImageButton
            android:id="@+id/start_button_tools"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:layout_margin="16dp"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="Outils"
            android:src="@android:drawable/ic_menu_manage"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:tint="@color/kikko_honey_yellow" />


        <LinearLayout
            android:id="@+id/bottom_navigation_bar"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:orientation="horizontal"
            android:weightSum="4"
            app:layout_constraintBottom_toTopOf="@id/status_counters_container"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent">

            <LinearLayout
                android:id="@+id/button_kikko"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@android:drawable/ic_menu_gallery"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Decks"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Decks"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/button_pollen"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@android:drawable/ic_menu_camera"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Pollen Live"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Pollen Live"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/button_forge"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@android:drawable/ic_menu_manage"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Forge"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Forge"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/button_clash"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingVertical="8dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:background="@drawable/circle"
                    android:backgroundTint="@color/kikko_honey_yellow"
                    android:padding="12dp"
                    android:src="@drawable/ic_swords"
                    app:tint="@color/kikko_bark_brown"
                    android:contentDescription="Clash"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Clash"
                    android:textColor="@color/kikko_honey_yellow"
                    android:textSize="12sp" />
            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:id="@+id/status_counters_container"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:orientation="horizontal"
            android:gravity="center"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent">

            <TextView
                android:id="@+id/raw_pollen_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="Brut: 12" />

            <TextView
                android:id="@+id/in_forge_pollen_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="En Forge: 5" />

            <TextView
                android:id="@+id/total_honey_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="Miel: 152" />

            <TextView
                android:id="@+id/error_pollen_counter"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:textColor="@color/kikko_error_red"
                android:textSize="14sp"
                android:textStyle="bold"
                tools:text="Erreurs: 2" />

        </LinearLayout>

    </androidx.constraintlayout.widget.ConstraintLayout>

</RelativeLayout>

--- END OF FILE app/src/main/res/layout/activity_start.xml ---


--- START OF FILE app/src/main/res/layout/dialog_audience_settings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Un nouveau dialogue pour configurer la Reine de l'Audience. -->
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Décrets de la Reine"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_marginBottom="20dp"/>

    <TextView
        android:id="@+id/audience_settings_temperature_label"
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Tempérament (Créativité)"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.slider.Slider
        android:id="@+id/audience_settings_temperature_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:valueFrom="0.0"
        android:valueTo="1.0"
        android:stepSize="0.01"
        android:value="0.20"
        android:layout_marginBottom="16dp"/>

    <TextView
        android:id="@+id/audience_settings_topk_label"
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Focalisation (Top-K)"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.slider.Slider
        android:id="@+id/audience_settings_topk_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:valueFrom="1"
        android:valueTo="100"
        android:stepSize="1"
        android:value="40"
        android:layout_marginBottom="24dp"/>

    <Button
        android:id="@+id/audience_settings_confirm_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Confirmer les Décrets"/>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_audience_settings.xml ---


--- START OF FILE app/src/main/res/layout/dialog_card_details.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurface">



    <androidx.core.widget.NestedScrollView
        android:id="@+id/card_details_scrollview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="24dp">

            <ImageView
                android:id="@+id/card_details_image"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic" />

            <TextView
                android:id="@+id/card_details_specific_name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:textAppearance="?attr/textAppearanceHeadline5"
                tools:text="Specific Name" />

            <com.google.android.material.chip.Chip
                android:id="@+id/card_details_deck_name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:chipIcon="@drawable/ic_folder"
                tools:text="Deck Name" />

            <TextView
                android:id="@+id/card_details_confidence"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceCaption"
                tools:text="Confidence: 0.99" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:text="@string/card_details_description_title"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <TextView
                android:id="@+id/card_details_description"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:textAppearance="?attr/textAppearanceBody2"
                tools:text="This is a detailed description of the card's subject, containing interesting facts and origins." />

            <TextView
                android:id="@+id/card_details_stats"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:lineSpacingExtra="4dp"
                android:textAppearance="?attr/textAppearanceBodyMedium"
                android:textStyle="bold"
                tools:text="Stat 1: Value 1\nStat 2: Value 2" />

            <TextView
                android:id="@+id/card_details_reasoning"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:textAppearance="?attr/textAppearanceBody2"
                android:textStyle="italic"
                tools:text="Visual Analysis: ...\nEvidence Correlation: ..." />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="80dp"
                android:orientation="horizontal">

                <Button
                    android:id="@+id/card_details_button_delete"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:text="@string/card_details_button_delete"
                    app:icon="@android:drawable/ic_menu_delete" />

                <Button
                    android:id="@+id/card_details_button_quiz"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="8dp"
                    android:text="@string/card_details_button_quiz"
                    android:visibility="gone"
                    app:icon="@drawable/ic_dice" />
            </LinearLayout>

        </LinearLayout>
    </androidx.core.widget.NestedScrollView>

    <LinearLayout
        android:id="@+id/card_details_footer_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp"
        android:background="?attr/colorSurfaceContainer"
        android:elevation="8dp"
        android:layout_gravity="bottom">

        <Button
            android:id="@+id/card_details_button_translate"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/card_details_button_translate"
            android:visibility="gone"
            tools:visibility="visible"
            app:icon="@android:drawable/ic_menu_rotate"/>

        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1"/>

        <Button
            android:id="@+id/card_details_button_chat"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/card_details_button_chat"
            app:icon="@drawable/chat_spark" />
    </LinearLayout>

</androidx.coordinatorlayout.widget.CoordinatorLayout>

--- END OF FILE app/src/main/res/layout/dialog_card_details.xml ---


--- START OF FILE app/src/main/res/layout/dialog_card_selection.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="?attr/colorSurfaceContainer">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <com.google.android.material.appbar.MaterialToolbar
            android:id="@+id/card_selection_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:title="Sélectionnez votre Champion"
            app:navigationIcon="@drawable/ic_close" />

    </com.google.android.material.appbar.AppBarLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp"
        android:gravity="center_vertical">

        <com.google.android.material.textfield.TextInputLayout
            style="?attr/textInputFilledStyle"
            android:id="@+id/card_selection_search_layout"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Rechercher par nom..."
            app:endIconMode="clear_text">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/card_selection_search_edittext"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:imeOptions="actionSearch"
                android:inputType="text"/>

        </com.google.android.material.textfield.TextInputLayout>

        <Spinner
            android:id="@+id/card_selection_sort_spinner"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:prompt="@string/sort_by_prompt"
            tools:listitem="@android:layout/simple_spinner_dropdown_item" />

    </LinearLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/card_selection_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:padding="8dp"
        android:clipToPadding="false"
        tools:listitem="@layout/item_card_preview"
        app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
        app:spanCount="3" />

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_card_selection.xml ---


--- START OF FILE app/src/main/res/layout/dialog_clash_setup.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Préparation au Clash"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_marginBottom="20dp"/>

    <TextView
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Sélection de la Reine IA"
        android:layout_marginBottom="8dp"/>

    <Spinner
        android:id="@+id/clash_setup_model_spinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="16dp" />

    <TextView
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Choix du Cerveau"
        android:layout_marginBottom="8dp"/>

    <RadioGroup
        android:id="@+id/clash_setup_accelerator_radiogroup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginBottom="16dp">

        <RadioButton
            android:id="@+id/clash_setup_cpu_radio"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="CPU (Stable)"
            android:checked="true"/>

        <RadioButton
            android:id="@+id/clash_setup_gpu_radio"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:text="GPU (Rapide)"/>
    </RadioGroup>

    <TextView
        android:id="@+id/clash_setup_temperature_label"
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Tempérament du Juge (0.20)"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.slider.Slider
        android:id="@+id/clash_setup_temperature_slider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:valueFrom="0.0"
        android:valueTo="1.0"
        android:stepSize="0.01"
        android:value="0.20"
        android:layout_marginBottom="16dp"/>

    <TextView
        style="?attr/textAppearanceTitleMedium"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Options Audio"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/clash_setup_tts_switch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Activer la lecture des verdicts"
        android:checked="true"
        android:layout_marginBottom="24dp"/>


    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <CheckBox
            android:id="@+id/clash_setup_dont_show_again_checkbox"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Ne plus afficher cette fenêtre au démarrage"/>

        <Button
            android:id="@+id/clash_setup_confirm_button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:text="Accéder à l'Arène"/>
    </LinearLayout>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_clash_setup.xml ---


--- START OF FILE app/src/main/res/layout/dialog_judgment.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?attr/colorSurface"
    android:orientation="vertical">

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/judgment_section_title_deliberation"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <!-- BOURDON'S DEFINITIVE FIX: Utilisation des attributs de couleur d'erreur existants. -->
            <com.google.android.material.card.MaterialCardView
                android:id="@+id/judgment_warning_card"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                app:cardBackgroundColor="?attr/colorErrorContainer"
                app:strokeColor="?attr/colorError"
                app:strokeWidth="1dp"
                android:visibility="gone"
                tools:visibility="visible">

                <TextView
                    android:id="@+id/judgment_warning_text"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:padding="12dp"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:textColor="?attr/colorOnErrorContainer"
                    app:drawableStartCompat="@android:drawable/ic_dialog_alert"
                    app:drawableTint="?attr/colorOnErrorContainer"
                    android:drawablePadding="8dp"
                    tools:text="Attention : 2 sur 4 Reines ont terminé. Votre jugement sera basé sur des preuves partielles." />

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                app:cardBackgroundColor="?attr/colorSurfaceContainerHigh">

                <TextView
                    android:id="@+id/judgment_streaming_response"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:minHeight="150dp"
                    android:padding="12dp"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:typeface="monospace"
                    tools:text="[La délibération en direct de la Reine Arbitre apparaîtra ici...]" />

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginVertical="24dp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/judgment_section_title_decree"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <TextView
                android:id="@+id/judgment_prompt_content"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:typeface="monospace"
                tools:text="[Le prompt complet envoyé à la Reine Arbitre sera affiché ici pour une transparence totale.]" />

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginVertical="24dp" />

            <TextView
                android:id="@+id/judgment_evidence_title"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/judgment_section_title_evidence"
                android:textAppearance="?attr/textAppearanceTitleMedium" />

            <TextView
                android:id="@+id/judgment_evidence_content"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:typeface="monospace"
                android:visibility="gone"
                tools:visibility="visible"
                tools:text="[Le rapport d'essaim et la liste des propositions des Reines seront affichés ici.]" />

        </LinearLayout>
    </androidx.core.widget.NestedScrollView>

    <LinearLayout
        android:id="@+id/judgment_actions_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/colorSurfaceContainer"
        android:elevation="8dp"
        android:orientation="horizontal"
        android:padding="16dp">

        <Button
            android:id="@+id/judgment_button_override"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/judgment_button_override" />

        <Button
            android:id="@+id/judgment_button_confirm"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_weight="1"
            android:enabled="false"
            android:text="@string/judgment_button_confirm" />
    </LinearLayout>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_judgment.xml ---


--- START OF FILE app/src/main/res/layout/dialog_queen_selector.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Le layout pour le dialogue de sélection de la Reine. -->
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp"
    android:minWidth="320dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Choisir la Reine"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_marginBottom="16dp"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/queen_selector_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:maxHeight="400dp"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        tools:listitem="@layout/item_queen_model_selection"
        tools:itemCount="3"/>

    <TextView
        android:id="@+id/queen_selector_empty_state"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Aucune Reine IA n'est disponible. Veuillez en ajouter via les Outils."
        android:gravity="center"
        android:padding="16dp"
        android:visibility="gone"
        tools:visibility="visible"/>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_queen_selector.xml ---


--- START OF FILE app/src/main/res/layout/dialog_specialist_report.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="#333333">

    <TextView
        android:id="@+id/dialog_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Rapport du Spécialiste"
        android:textColor="@android:color/white"
        android:textSize="18sp"
        android:textStyle="bold"
        android:layout_gravity="center_horizontal"/>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/format_switch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Voir en JSON"
        android:textColor="@android:color/white"
        android:layout_gravity="center_horizontal"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="400dp"
        android:layout_marginTop="16dp"
        android:background="#222222"
        android:padding="8dp">

        <TextView
            android:id="@+id/report_content_textview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@android:color/white"
            android:textSize="12sp"
            android:fontFamily="monospace"/>

    </ScrollView>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_specialist_report.xml ---


--- START OF FILE app/src/main/res/layout/dialog_tools.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="8dp"
    android:minWidth="360dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/tools_dialog_title"
        android:textAppearance="?attr/textAppearanceHeadlineSmall"
        android:layout_gravity="center_horizontal"
        android:layout_marginBottom="16dp"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_active_queen_forge"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/tools_recyclerview_queen_selector"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:maxHeight="180dp"
                android:background="@drawable/scroll_background"
                android:padding="8dp"
                tools:listitem="@layout/item_queen_model_selection"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                android:layout_marginBottom="8dp"/>

            <TextView
                style="?attr/textAppearanceBodyMedium"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_queen_accelerator"
                android:layout_marginTop="8dp"/>
            <RadioGroup
                android:id="@+id/tools_radiogroup_queen_accelerator"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">
                <RadioButton
                    android:id="@+id/tools_radio_cpu"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/tools_accelerator_cpu" />
                <RadioButton
                    android:id="@+id/tools_radio_gpu"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="16dp"
                    android:text="@string/tools_accelerator_gpu"
                    android:checked="true"/>
            </RadioGroup>

            <!-- BOURDON'S REFACTOR: Section Vosk mise en sommeil -->
            <LinearLayout
                android:id="@+id/vosk_section_container"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:visibility="gone"
                tools:visibility="gone">

                <com.google.android.material.divider.MaterialDivider
                    android:layout_width="match_parent"
                    android:layout_height="1dp"
                    android:layout_marginTop="16dp"
                    android:layout_marginBottom="16dp"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/tools_voice_recognition"
                    android:textAppearance="?attr/textAppearanceTitleMedium"
                    android:layout_marginBottom="8dp"/>

                <androidx.recyclerview.widget.RecyclerView
                    android:id="@+id/tools_recyclerview_vosk_models"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:maxHeight="180dp"
                    android:background="@drawable/scroll_background"
                    android:padding="8dp"
                    tools:listitem="@layout/item_vosk_model"
                    app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                    android:layout_marginBottom="8dp"/>

                <TextView
                    android:id="@+id/vosk_result_textview"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:minHeight="80dp"
                    android:padding="8dp"
                    android:background="@drawable/scroll_background"
                    android:textIsSelectable="true"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:layout_marginBottom="8dp"
                    android:visibility="gone"
                    tools:visibility="visible"
                    tools:text="Appuyez sur 'play' pour commencer l'écoute..."/>

                <Button
                    android:id="@+id/tools_button_import_vosk_model"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/tools_button_load_vosk"
                    app:icon="@android:drawable/ic_menu_add" />
            </LinearLayout>

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_forge_settings"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/tools_switch_require_charging"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_forge_require_charging" />

            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/tools_switch_require_idle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_forge_require_idle" />

            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="16dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_manage_local_queens"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/tools_recyclerview_models"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:maxHeight="250dp"
                android:background="@drawable/scroll_background"
                android:padding="8dp"
                tools:listitem="@layout/item_local_model"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"/>

            <Button
                android:id="@+id/tools_button_add_model"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/tools_button_add_queen"
                app:icon="@android:drawable/ic_menu_add" />

            <Button
                android:id="@+id/tools_button_download_models"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/tools_button_download_more_queens"
                app:icon="@android:drawable/ic_menu_gallery" />


            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_saga_management"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">

                <Button
                    android:id="@+id/tools_button_import_saga"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:layout_marginEnd="8dp"
                    android:text="@string/tools_button_import_saga"
                    app:icon="@android:drawable/ic_menu_save"/>

                <Button
                    android:id="@+id/tools_button_export_saga"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/tools_button_export_saga"
                    app:icon="@android:drawable/ic_menu_upload"/>
            </LinearLayout>

            <Button
                android:id="@+id/tools_button_download_decks"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/tools_button_download_decks"
                app:icon="@android:drawable/ic_menu_gallery" />

            <!-- BOURDON'S ADDITION: Section pour la gestion des prompts -->
            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_prompt_management_title"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <Button
                android:id="@+id/tools_button_manage_prompts"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_button_manage_prompts"
                app:icon="@android:drawable/ic_menu_edit" />


            <com.google.android.material.divider.MaterialDivider
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/tools_danger_zone"
                android:textColor="?attr/colorError"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:layout_marginBottom="8dp"/>

            <Button
                android:id="@+id/tools_button_nuke_db"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/tools_button_nuke_db"
                app:icon="@android:drawable/ic_delete"
                app:backgroundTint="?attr/colorErrorContainer"
                android:textColor="?attr/colorOnErrorContainer"/>
        </LinearLayout>
    </ScrollView>
</LinearLayout>

--- END OF FILE app/src/main/res/layout/dialog_tools.xml ---


--- START OF FILE app/src/main/res/layout/fragment_deck_page.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    tools:context=".deck.DeckPageFragment">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/deck_page_recyclerview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:padding="8dp"
        android:clipToPadding="false"
        app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
        app:spanCount="2"
        tools:listitem="@layout/item_card_preview" />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/fragment_deck_page.xml ---


--- START OF FILE app/src/main/res/layout/fragment_duel_page.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S FINAL & CORRECTED REFORGE: This is the definitive version. -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".clash.ui.ClashDuelFragment">

    <!-- La vidéo de fond, gérée par ExoPlayer pour un rendu parfait -->
    <androidx.media3.ui.PlayerView
        android:id="@+id/duel_background_video_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:resize_mode="zoom"
        app:use_controller="false"/>

    <!-- La question, toujours au sommet -->
    <TextView
        android:id="@+id/duel_question_textview"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:gravity="center"
        android:fontFamily="@font/luckiest_guy"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="22sp"
        android:shadowColor="@color/black"
        android:shadowDx="1"
        android:shadowDy="1"
        android:shadowRadius="2"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="Quel aliment a un indice glycémique plus bas ?" />

    <include
        android:id="@+id/duel_player1_card"
        layout="@layout/item_clash_champion_card"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:rotation="-30"
        app:layout_constraintDimensionRatio="W,1.4"
        app:layout_constraintBottom_toTopOf="@id/guideline_bottom_cards"
        app:layout_constraintEnd_toStartOf="@+id/guideline_middle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/duel_question_textview"
        app:layout_constraintWidth_percent="0.20"
        app:layout_constraintVertical_bias="0.4" />

    <TextView
        android:id="@+id/duel_vs_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:fontFamily="@font/luckiest_guy"
        android:shadowColor="@color/black"
        android:shadowDx="2"
        android:shadowDy="2"
        android:shadowRadius="3"
        android:text="@string/clash_duel_vs"
        android:textColor="@color/kikko_honey_yellow"
        android:textSize="48sp"
        app:layout_constraintBottom_toBottomOf="@id/duel_player1_card"
        app:layout_constraintEnd_toStartOf="@id/duel_player2_card"
        app:layout_constraintStart_toEndOf="@id/duel_player1_card"
        app:layout_constraintTop_toTopOf="@id/duel_player1_card" />

    <include
        android:id="@+id/duel_player2_card"
        layout="@layout/item_clash_champion_card"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:rotation="30"
        app:layout_constraintDimensionRatio="W,1.4"
        app:layout_constraintBottom_toBottomOf="@id/duel_player1_card"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/guideline_middle"
        app:layout_constraintTop_toTopOf="@id/duel_player1_card"
        app:layout_constraintWidth_percent="0.20" />

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline_middle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintGuide_percent="0.5" />

    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline_bottom_cards"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintGuide_percent="0.65" />


    <ScrollView
        android:id="@+id/duel_reasoning_scrollview"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="8dp"
        app:layout_constraintBottom_toTopOf="@id/duel_navigation_container"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/guideline_bottom_cards">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:gravity="center_horizontal">

            <TextView
                android:id="@+id/duel_streaming_reasoning_textview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="@drawable/debug_border"
                android:padding="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:textColor="@color/kikko_honey_yellow"
                android:visibility="gone"
                tools:text="Streaming tokens from the judge will appear here..." />

            <TextView
                android:id="@+id/duel_reasoning_textview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:gravity="center"
                android:visibility="invisible"
                android:fontFamily="@font/luckiest_guy"
                android:textColor="@color/kikko_honey_yellow"
                android:textSize="20sp"
                android:shadowColor="@color/black"
                android:shadowDx="1"
                android:shadowDy="1"
                android:shadowRadius="2"
                tools:text="L'HONEY A UN INDICE GLYCÉMIQUE PLUS BAS..."
                tools:visibility="visible" />
        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/duel_navigation_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/duel_previous_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/clash_duel_button_previous"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Space
            android:id="@+id/duel_nav_spacer"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:visibility="gone"
            tools:visibility="visible"/>

        <com.google.android.material.progressindicator.CircularProgressIndicator
            android:id="@+id/duel_loading_indicator"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:indeterminate="true"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Button
            android:id="@+id/duel_next_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/clash_duel_button_next"
            android:visibility="gone"
            tools:visibility="visible"/>

        <Button
            android:id="@+id/duel_finish_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/clash_duel_button_finish"
            android:visibility="gone"
            tools:visibility="visible"/>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/fragment_duel_page.xml ---


--- START OF FILE app/src/main/res/layout/item_analysis_result.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginBottom="8dp"
    app:cardElevation="1dp"
    app:strokeWidth="1dp"
    app:strokeColor="?attr/colorOutlineVariant">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <!-- BOURDON'S REFORGE: Cet en-tête est maintenant la zone cliquable pour déplier -->
        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/analysis_header_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="12dp"
            android:background="?attr/selectableItemBackground">

            <TextView
                android:id="@+id/analysis_model_config"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:textColor="@color/black"
                android:textSize="14dp"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toStartOf="@id/analysis_status_chip"
                android:layout_marginEnd="8dp"
                tools:text="gemma-3n-E2B (GPU, T:0.9)" />

            <com.google.android.material.chip.Chip
                android:id="@+id/analysis_status_chip"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                tools:text="COMPLETED" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <!-- BOURDON'S REFORGE: Ce conteneur sera caché/affiché -->
        <LinearLayout
            android:id="@+id/analysis_details_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingStart="12dp"
            android:paddingEnd="12dp"
            android:paddingBottom="12dp"
            android:visibility="gone"
            tools:visibility="visible">

            <TextView
                android:id="@+id/analysis_error_message"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textAppearance="?attr/textAppearanceBodySmall"
                android:textColor="?attr/colorError"
                android:visibility="gone"
                tools:visibility="visible"
                tools:text="Error: Inference failed due to invalid parameters."/>

            <TextView
                android:id="@+id/analysis_raw_response"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textSize="12sp"
                android:padding="8dp"
                android:background="@color/black"
                android:textColor="@color/kikko_honey_yellow"
                android:typeface="monospace"
                android:textIsSelectable="true"
                android:visibility="gone"
                tools:visibility="visible"
                tools:text="{ 'description': 'A dandelion is...', 'stats': {...} }"/>

            <HorizontalScrollView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:scrollbars="none">

                <LinearLayout
                    android:id="@+id/analysis_actions_container"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="end">

                    <Button
                        android:id="@+id/analysis_validate_button"
                        style="?attr/materialButtonStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Valider"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_set_as" />

                    <Button
                        android:id="@+id/analysis_view_error_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Voir Erreur"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_info_details" />

                    <Button
                        android:id="@+id/analysis_retry_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Relancer"
                        android:layout_marginStart="8dp"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_revert" />

                    <Button
                        android:id="@+id/analysis_run_button"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Lancer"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_media_play" />

                    <Button
                        android:id="@+id/analysis_pause_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Pause"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_media_pause" />

                    <Button
                        android:id="@+id/analysis_cancel_button"
                        style="?attr/materialButtonOutlinedStyle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="8dp"
                        android:text="Annuler"
                        app:iconTint="?attr/colorError"
                        android:textColor="?attr/colorError"
                        app:strokeColor="?attr/colorError"
                        android:visibility="gone"
                        tools:visibility="visible"
                        app:icon="@android:drawable/ic_menu_close_clear_cancel" />
                </LinearLayout>
            </HorizontalScrollView>
        </LinearLayout>
    </LinearLayout>
</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_analysis_result.xml ---


--- START OF FILE app/src/main/res/layout/item_card_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="140dp"
    android:layout_height="180dp"
    android:layout_margin="8dp"
    app:cardElevation="4dp"
    app:cardCornerRadius="12dp">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_preview_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Illustration du champion" />

        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_bottom_dark"
            app:layout_constraintHeight_percent="0.4"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_preview_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@color/white"
            android:layout_marginStart="8dp"
            android:layout_marginEnd="8dp"
            android:layout_marginBottom="8dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Kikko Cookies" />

        <TextView
            android:id="@+id/card_preview_stats"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"
            tools:visibility="gone"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"/>

        <View
            android:id="@+id/card_preview_loser_veil"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="#99000000"
            android:visibility="gone"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_card_preview.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_card_context.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="280dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        app:cardElevation="4dp"
        app:cardCornerRadius="12dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <ImageView
                android:id="@+id/chat_card_image"
                android:layout_width="match_parent"
                android:layout_height="180dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic"
                android:contentDescription="Image de la carte en cours de discussion" />

            <TextView
                android:id="@+id/chat_card_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textAppearance="?attr/textAppearanceTitleMedium"
                android:paddingHorizontal="16dp"
                android:paddingTop="12dp"
                tools:text="Sujet de la Carte" />

            <ScrollView
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:paddingHorizontal="16dp"
                android:paddingVertical="8dp">

                <TextView
                    android:id="@+id/chat_card_description"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textAppearance="?attr/textAppearanceBodyMedium"
                    android:textColor="?attr/colorOnSurfaceVariant"
                    tools:text="Ceci est une description détaillée de la carte qui peut être assez longue et nécessiter un défilement pour être lue en entier." />
            </ScrollView>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>
</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_card_context.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_queen.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="4dp"
    android:paddingStart="8dp"
    android:paddingEnd="64dp" android:alpha="0.8">

    <TextView
        android:id="@+id/chat_queen_message_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="start"
        android:background="@color/black"
        android:elevation="2dp"
        android:paddingHorizontal="16dp"
        android:paddingVertical="10dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        android:textColor="@color/kikko_gold"
        tools:text="D'après les informations de la carte, cette plante n'est pas répertoriée comme toxique." />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_queen.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_user.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="4dp"
    android:paddingStart="64dp"
    android:paddingEnd="8dp" android:alpha="0.8">

    <TextView
        android:id="@+id/chat_user_message_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:background="@color/kikko_gold"
        android:elevation="2dp"
        android:paddingHorizontal="16dp"
        android:paddingVertical="10dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        android:textColor="@color/black"
        tools:text="Est-ce que cette plante est toxique pour les chats ?" />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_user.xml ---


--- START OF FILE app/src/main/res/layout/item_chat_user_with_image.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Un nouveau layout pour les messages utilisateur contenant une image. -->
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingVertical="4dp"
    android:paddingStart="64dp"
    android:paddingEnd="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        app:cardBackgroundColor="@color/kikko_gold"
        app:cardCornerRadius="18dp"
        app:cardElevation="2dp">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:maxWidth="280dp">

            <ImageView
                android:id="@+id/chat_user_imageview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:adjustViewBounds="true"
                android:maxHeight="250dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic"
                android:contentDescription="Image jointe par l'utilisateur" />

            <TextView
                android:id="@+id/chat_user_message_textview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingHorizontal="16dp"
                android:paddingVertical="10dp"
                android:textAppearance="?attr/textAppearanceBodyMedium"
                android:textColor="@color/black"
                tools:text="Regarde cette fleur, est-ce que tu la reconnais ?" />

        </LinearLayout>
    </com.google.android.material.card.MaterialCardView>
</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_chat_user_with_image.xml ---


--- START OF FILE app/src/main/res/layout/item_clash_champion_card.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S REFORGE: Le design est maintenant inspiré du thumbnail pour une esthétique supérieure. -->
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:cardCornerRadius="12dp"
    app:cardElevation="8dp"
    app:cardUseCompatPadding="true"
    app:cardBackgroundColor="@android:color/black">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Image du champion" />

        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.5"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_deck_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="12dp"
            android:layout_marginBottom="4dp"
            android:textAppearance="?attr/textAppearanceLabelMedium"
            android:textColor="@color/kikko_honey_yellow"
            android:alpha="0.9"
            app:layout_constraintBottom_toTopOf="@id/card_title"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Food" android:visibility="gone"/>
        <ImageView
            android:layout_width="match_parent" android:scaleType="fitXY"
            android:layout_height="match_parent" android:src="@drawable/kikko_pollen"/>

        <TextView
            android:id="@+id/card_title"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            android:layout_marginHorizontal="12dp"
            android:layout_marginBottom="12dp"
            android:maxLines="3"
            android:ellipsize="end"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Haribo Haribo Haribo" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_clash_champion_card.xml ---


--- START OF FILE app/src/main/res/layout/item_clash_champion_thumbnail.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:cardCornerRadius="8dp"
    app:cardElevation="2dp"
    app:cardUseCompatPadding="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_thumbnail_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Vignette du champion sélectionné" />
<ImageView
    android:layout_width="match_parent" android:scaleType="fitXY"
    android:layout_height="match_parent" android:src="@drawable/kikko_pollen"/>
        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.6"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_thumbnail_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            android:layout_marginHorizontal="4dp"
            android:layout_marginBottom="4dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal|bottom"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Nom Très Long du Champion de la Mort" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_clash_champion_thumbnail.xml ---


--- START OF FILE app/src/main/res/layout/item_clash_deck_thumbnail.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="120dp"
    android:layout_height="160dp"
    app:cardCornerRadius="8dp"
    app:cardElevation="2dp"
    app:cardUseCompatPadding="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/card_thumbnail_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Vignette du champion sélectionné" />
        <ImageView
            android:layout_width="match_parent" android:scaleType="fitXY"
            android:layout_height="match_parent" android:src="@drawable/kikko_pollen"/>
        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.6"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/card_thumbnail_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            android:layout_marginHorizontal="4dp"
            android:layout_marginBottom="4dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal|bottom"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Nom Très Long du Champion de la Mort" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_clash_deck_thumbnail.xml ---


--- START OF FILE app/src/main/res/layout/item_competition_summary.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: La "Stèle des Propositions" pour l'Atelier. -->
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginBottom="8dp"
    app:cardElevation="0dp"
    app:strokeWidth="1dp"
    app:strokeColor="?attr/colorPrimary">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:padding="12dp">

        <TextView
            android:id="@+id/summary_response_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:textColor="@color/black"
            android:textSize="14dp"
            tools:text="3 Reines proposent : &quot;Plant: Dandelion&quot;" />

        <Button
            android:id="@+id/summary_validate_button"
            style="?attr/materialButtonOutlinedStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:text="@string/workshop_button_validate"
            app:icon="@android:drawable/ic_menu_set_as" />

    </LinearLayout>
</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_competition_summary.xml ---


--- START OF FILE app/src/main/res/layout/item_knowledge_card_reforged.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:cardCornerRadius="12dp"
    app:cardElevation="4dp"
    app:cardUseCompatPadding="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <ImageView
            android:id="@+id/card_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintDimensionRatio="1:1"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"/>

        <View
            android:id="@+id/scrim_view"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintTop_toTopOf="@id/card_image"
            app:layout_constraintBottom_toBottomOf="@id/card_image"
            app:layout_constraintStart_toStartOf="@id/card_image"
            app:layout_constraintEnd_toEndOf="@id/card_image"/>

        <TextView
            android:id="@+id/card_deck_name"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="12dp"
            android:layout_marginBottom="8dp"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            android:textColor="@android:color/white"
            android:shadowColor="#80000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="2"
            app:layout_constraintBottom_toTopOf="@id/card_title"
            app:layout_constraintStart_toStartOf="parent"
            tools:text="Insect Deck" />

        <TextView
            android:id="@+id/card_title"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="12dp"
            android:layout_marginBottom="12dp"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@android:color/white"
            android:shadowColor="#C0000000"
            android:shadowDx="1"
            android:shadowDy="1"
            android:shadowRadius="3"
            app:layout_constraintBottom_toBottomOf="@id/card_image"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Honey Bee" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_knowledge_card_reforged.xml ---


--- START OF FILE app/src/main/res/layout/item_local_model.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:gravity="center_vertical"
    android:padding="8dp"
    android:background="?attr/selectableItemBackground">

    <TextView
        android:id="@+id/local_model_name_textview"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        tools:text="gemma3-1B-it-int4.task" />

    <ImageButton
        android:id="@+id/local_model_delete_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:src="@android:drawable/ic_menu_delete"
        android:contentDescription="Supprimer le modèle local"
        android:layout_marginStart="8dp"/>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/item_local_model.xml ---


--- START OF FILE app/src/main/res/layout/item_player_card.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="200dp"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardElevation="4dp"
    app:cardCornerRadius="8dp"
    android:backgroundTint="@color/black">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="12dp"
        android:background="@color/black"
        >

        <ImageView
            android:id="@+id/player_icon"
            android:layout_width="40dp"
            android:layout_height="40dp"
            android:src="@drawable/ic_turtle"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            android:contentDescription="Icône de joueur tortue" />

        <TextView
            android:id="@+id/player_name_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="12dp"
            android:textStyle="bold"
            android:textSize="16sp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/player_icon"
            app:layout_constraintTop_toTopOf="@id/player_icon"
            tools:text="KikkoUser123" />

        <TextView
            android:id="@+id/player_record_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="4dp"
            android:textSize="12sp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintStart_toStartOf="@id/player_name_text"
            app:layout_constraintTop_toBottomOf="@id/player_name_text"
            tools:text="🏆 15 / 💔 4" />

        <TextView
            android:id="@+id/player_distance_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="@id/player_record_text"
            tools:text="11.6m" />

        <View
            android:id="@+id/separator_line"
            android:layout_width="0dp"
            android:layout_height="1dp"
            android:layout_marginTop="8dp"
            android:background="?attr/colorPrimary"
            android:alpha="0.3"
            app:layout_constraintTop_toBottomOf="@id/player_record_text"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <TextView
            android:id="@+id/decks_column_1_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:textSize="14sp"
            android:lineSpacingExtra="4dp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/separator_line"
            tools:text="🐢(123)\n🌿(78)" />

        <TextView
            android:id="@+id/decks_column_2_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:textSize="14sp"
            android:lineSpacingExtra="4dp"
            android:textColor="@color/kikko_gold"
            app:layout_constraintStart_toEndOf="@+id/decks_column_1_text"
            app:layout_constraintTop_toTopOf="@id/decks_column_1_text"
            tools:text="🎂(45)\n🍎(289)" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_player_card.xml ---


--- START OF FILE app/src/main/res/layout/item_pollen_grain_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="120dp"
    android:layout_height="140dp"
    android:layout_margin="8dp"
    app:cardElevation="2dp"
    app:cardCornerRadius="12dp"
    android:clickable="true"
    android:focusable="true">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/pollen_preview_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Aperçu du grain de pollen" />

        <View
            android:id="@+id/pollen_preview_scrim"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/gradient_scrim_bottom"
            app:layout_constraintHeight_percent="0.5"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

        <com.google.android.material.chip.Chip
            android:id="@+id/pollen_preview_status_chip"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="4dp"
            android:textAppearance="?attr/textAppearanceLabelSmall"
            app:chipMinHeight="20dp"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            tools:text="RAW" />

        <TextView
            android:id="@+id/pollen_preview_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="8dp"
            android:layout_marginBottom="8dp"
            android:maxLines="2"
            android:ellipsize="end"
            android:gravity="center_horizontal"
            android:textAppearance="?attr/textAppearanceBodySmall"
            android:textColor="@android:color/white"
            android:textStyle="bold"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="Pollen #A4F3" />

        <View
            android:id="@+id/pollen_preview_selection_border"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:background="@drawable/selection_halo"
            android:visibility="gone"
            tools:visibility="visible"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/item_pollen_grain_preview.xml ---


--- START OF FILE app/src/main/res/layout/item_pollen_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginEnd="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="100dp"
        android:layout_height="100dp"
        app:cardCornerRadius="8dp"
        app:cardElevation="2dp"
        android:layout_marginTop="8dp"
        android:layout_marginEnd="8dp">

        <ImageView
            android:id="@+id/pollen_preview_imageview"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerCrop"
            tools:src="@tools:sample/backgrounds/scenic"
            android:contentDescription="Pollen visuel sélectionné"/>

    </com.google.android.material.card.MaterialCardView>

    <ProgressBar
        android:id="@+id/pollen_progress_indicator"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:layout_gravity="center"
        android:visibility="gone"
        tools:visibility="visible"/>

    <ImageView
        android:id="@+id/pollen_done_icon"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:layout_gravity="bottom|end"
        android:layout_marginEnd="12dp"
        android:layout_marginBottom="4dp"
        android:src="@drawable/ic_victory_cockade"
        android:visibility="gone"
        tools:visibility="visible" />

    <ImageButton
        android:id="@+id/pollen_remove_button"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:layout_gravity="top|end"
        android:src="@drawable/ic_close"
        android:background="@drawable/selection_halo"
        android:backgroundTint="?attr/colorError"
        app:tint="?attr/colorOnError"
        android:contentDescription="Retirer cette image"/>

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_pollen_preview.xml ---


--- START OF FILE app/src/main/res/layout/item_property_refinement.xml ---

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <com.google.android.material.divider.MaterialDivider
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="16dp"/>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/property_refinement_header"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/selectableItemBackground"
        android:paddingVertical="8dp">

        <TextView
            android:id="@+id/property_refinement_title"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toStartOf="@id/property_refinement_result_count"
            tools:text="Raffinage de la Description" />

        <TextView
            android:id="@+id/property_refinement_result_count"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textAppearance="?attr/textAppearanceBodyMedium"
            android:textColor="?attr/colorOnSurfaceVariant"
            android:layout_marginEnd="8dp"
            app:layout_constraintEnd_toStartOf="@id/property_refinement_expand_icon"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            tools:text="(8 résultats)" />

        <ImageView
            android:id="@+id/property_refinement_expand_icon"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@android:drawable/arrow_down_float"
            app:tint="?attr/colorOnSurfaceVariant"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:contentDescription="@string/workshop_expand_section_desc"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

    <LinearLayout
        android:id="@+id/property_refinement_content"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:visibility="gone"
        tools:visibility="visible">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="8dp">

            <Button
                android:id="@+id/property_refinement_launch_button"
                style="?attr/materialButtonOutlinedStyle"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                tools:text="Relancer la Compétition 🔄"/>

            <Button
                android:id="@+id/property_refinement_launch_judgment_button"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginStart="8dp"
                android:text="@string/workshop_button_launch_judgment"
                android:visibility="gone"
                tools:visibility="visible"/>
        </LinearLayout>


        <com.google.android.material.card.MaterialCardView
            android:id="@+id/property_refinement_summary_card"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            app:cardBackgroundColor="?attr/colorSurfaceContainerHigh"
            app:strokeWidth="0dp"
            android:visibility="gone"
            tools:visibility="visible">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="12dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/workshop_competition_summary_title"
                    android:textAppearance="?attr/textAppearanceTitleSmall"
                    android:layout_marginBottom="8dp"/>

                <LinearLayout
                    android:id="@+id/property_refinement_summary_container"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"/>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/property_refinement_results_recyclerview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:nestedScrollingEnabled="false"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:itemCount="2"
            tools:listitem="@layout/item_analysis_result"/>
    </LinearLayout>

</LinearLayout>

--- END OF FILE app/src/main/res/layout/item_property_refinement.xml ---


--- START OF FILE app/src/main/res/layout/item_queen_model_selection.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingStart="8dp"
    android:paddingEnd="8dp">

    <RadioButton
        android:id="@+id/queen_model_radio_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingTop="12dp"
        android:paddingBottom="12dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        tools:text="gemma-3n-E4B-it-int4.task" />

</FrameLayout>

--- END OF FILE app/src/main/res/layout/item_queen_model_selection.xml ---


--- START OF FILE app/src/main/res/layout/item_vosk_model.xml ---

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="8dp">

    <ImageButton
        android:id="@+id/button_test_vosk_model"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@android:drawable/ic_media_play"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:contentDescription="Tester le modèle vocal" />

    <TextView
        android:id="@+id/vosk_model_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:layout_marginEnd="16dp"
        android:textAppearance="?attr/textAppearanceBodyMedium"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toStartOf="@+id/button_delete_vosk_model"
        app:layout_constraintStart_toEndOf="@+id/button_test_vosk_model"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="vosk-model-fr-0.22" />

    <ImageButton
        android:id="@+id/button_delete_vosk_model"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@android:drawable/ic_menu_delete"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:contentDescription="Supprimer le modèle vocal" />

</androidx.constraintlayout.widget.ConstraintLayout>

--- END OF FILE app/src/main/res/layout/item_vosk_model.xml ---


--- START OF FILE app/src/main/res/layout/layout_card_selector_panel.xml ---

<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/card_selector_panel"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:visibility="gone"
    tools:visibility="visible"
    app:cardBackgroundColor="@color/kikko_dark_gray"
    app:strokeColor="@color/kikko_gold_light"
    app:strokeWidth="1dp"
    app:cardElevation="8dp"
    app:cardCornerRadius="16dp"
    app:layout_constraintWidth_percent="0.8"
    app:layout_constraintTop_toTopOf="parent"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintEnd_toEndOf="parent">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="16dp">

        <ImageView
            android:id="@+id/selector_panel_deck_icon"
            android:layout_width="32dp"
            android:layout_height="32dp"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:src="@drawable/ic_deck_food"
            app:tint="@color/kikko_honey_yellow"/>

        <TextView
            android:id="@+id/selector_panel_deck_name"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:textAppearance="?attr/textAppearanceTitleMedium"
            android:textColor="@color/kikko_honey_yellow"
            app:layout_constraintStart_toEndOf="@id/selector_panel_deck_icon"
            app:layout_constraintTop_toTopOf="@id/selector_panel_deck_icon"
            app:layout_constraintBottom_toBottomOf="@id/selector_panel_deck_icon"
            app:layout_constraintEnd_toStartOf="@id/selector_panel_close_button"
            tools:text="Sélectionnez un champion du Deck Food"/>

        <ImageButton
            android:id="@+id/selector_panel_close_button"
            android:layout_width="32dp"
            android:layout_height="32dp"
            android:src="@android:drawable/ic_menu_close_clear_cancel"
            android:background="?attr/selectableItemBackgroundBorderless"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:tint="@color/kikko_honey_yellow"/>

        <!-- BOURDON'S FIX: Hauteur ajustée pour permettre une grille visible -->
        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/selector_panel_recyclerview"
            android:layout_width="0dp"
            android:layout_height="240dp"
            android:layout_marginTop="16dp"
            android:clipToPadding="false"
            app:layout_constraintTop_toBottomOf="@id/selector_panel_deck_icon"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:listitem="@layout/item_card_preview"
            tools:layout_manager="androidx.recyclerview.widget.GridLayoutManager"
            tools:spanCount="4"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/layout_card_selector_panel.xml ---


--- START OF FILE app/src/main/res/layout/layout_chat_image_preview.xml ---

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:paddingTop="8dp">

    <com.google.android.material.card.MaterialCardView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="start"
        app:cardCornerRadius="12dp"
        app:cardElevation="2dp">

        <FrameLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content">

            <ImageView
                android:id="@+id/preview_image_view"
                android:layout_width="100dp"
                android:layout_height="100dp"
                android:scaleType="centerCrop"
                tools:src="@tools:sample/backgrounds/scenic"
                android:contentDescription="Prévisualisation de l'image à envoyer"/>

            <ImageButton
                android:id="@+id/remove_preview_button"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:layout_gravity="top|end"
                android:layout_margin="4dp"
                android:src="@android:drawable/ic_menu_close_clear_cancel"
                android:background="@drawable/circle"
                android:backgroundTint="#80000000"
                app:tint="@android:color/white"/>

        </FrameLayout>

    </com.google.android.material.card.MaterialCardView>

</FrameLayout>

--- END OF FILE app/src/main/res/layout/layout_chat_image_preview.xml ---


--- START OF FILE app/src/main/res/layout/layout_chat_input_bar.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!-- BOURDON'S ADDITION: Un composant réutilisable pour une barre de saisie de chat moderne. -->
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardElevation="4dp"
    app:cardCornerRadius="28dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingStart="8dp"
        android:paddingEnd="8dp"
        android:minHeight="56dp">

        <ImageButton
            android:id="@+id/chat_attach_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_menu_add"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/chat_attach_button_desc"
            app:tint="?attr/colorOnSurfaceVariant"/>

        <EditText
            android:id="@+id/chat_input_edittext"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="@string/chat_input_hint"
            android:background="@android:color/transparent"
            android:inputType="textMultiLine|textCapSentences"
            android:maxLines="5"
            android:paddingTop="16dp"
            android:paddingBottom="16dp"
            android:paddingStart="8dp"
            android:paddingEnd="8dp" />

        <ImageButton
            android:id="@+id/chat_mic_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_btn_speak_now"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/chat_mic_button_desc"
            app:tint="?attr/colorOnSurfaceVariant"
            android:visibility="visible"/>

        <ImageButton
            android:id="@+id/chat_send_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@android:drawable/ic_menu_send"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/chat_send_button_desc"
            app:tint="?attr/colorPrimary"
            android:visibility="gone"
            tools:visibility="visible"/>
    </LinearLayout>

</com.google.android.material.card.MaterialCardView>

--- END OF FILE app/src/main/res/layout/layout_chat_input_bar.xml ---


--- START OF FILE app/src/main/res/menu/prompt_editor_menu.xml ---

<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/action_import_prompts"
        android:title="@string/menu_import_prompts"
        android:icon="@android:drawable/ic_menu_save"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_export_prompts"
        android:title="@string/menu_export_prompts"
        android:icon="@android:drawable/ic_menu_upload"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_reset_prompts"
        android:title="@string/menu_reset_prompts"
        android:icon="@android:drawable/ic_menu_revert"
        app:showAsAction="never" />

</menu>

--- END OF FILE app/src/main/res/menu/prompt_editor_menu.xml ---


--- START OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- END OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml ---


--- START OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

--- END OF FILE app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml ---


--- START OF FILE app/src/main/res/values-fr/strings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="sort_by_prompt">Trier par…</string>
    <string name="app_name">KiKKo Saga Forge</string>
    <string name="model_manager">Gestion des Modèles</string>
    <string name="downloaded_size">%1$s téléchargé</string>
    <string name="cancel">Annuler</string>
    <string name="ok">OK</string>
    <string name="confirm_delete_model_dialog_title">Supprimer le téléchargement</string>
    <string name="confirm_delete_model_dialog_content">Êtes-vous sûr de vouloir supprimer le modèle téléchargé \"%s\" ?</string>
    <string name="notification_title_success">Téléchargement du modèle réussi</string>
    <string name="notification_content_success">Le modèle \"%s\" a été téléchargé</string>
    <string name="notification_title_fail">Échec du téléchargement du modèle</string>
    <string name="notification_content_fail">Impossible de télécharger le modèle \"%s\"</string>
    <string name="chat_textinput_placeholder">Écrire un message…</string>
    <string name="chat_you">Vous</string>
    <string name="chat_llm_agent_name">LLM</string>
    <string name="chat_generic_agent_name">Modèle</string>
    <string name="chat_generic_result_name">Résultat</string>
    <string name="model_not_downloaded_msg">Modèle non encore téléchargé</string>
    <string name="model_is_initializing_msg">Initialisation du modèle…</string>
    <string name="text_input_placeholder_text_classification">Écrire une critique de film à classifier…</string>
    <string name="text_image_generation_text_field_placeholder">Écrire un prompt…</string>
    <string name="text_input_placeholder_llm_chat">Écrire un prompt…</string>
    <string name="run_again">Ré-exécuter</string>
    <string name="benchmark">Lancer le benchmark</string>
    <string name="warming_up">préparation…</string>
    <string name="running">en cours</string>

    <string name="debug_activity_title">Kikko Labo de Test &amp; Débug</string>
    <string name="model_management_title">Gestion des Modèles</string>
    <string name="service_testing_title">Test des Services</string>

    <string name="status_downloading">Téléchargement... %1$d%%</string>
    <string name="status_unzipping">Décompression...</string>
    <string name="status_ready">Prêt</string>
    <string name="status_not_downloaded">Non Téléchargé</string>
    <string name="status_error">Erreur</string>
    <string name="button_download">Télécharger</string>
    <string name="button_delete">Supprimer</string>

    <string name="vosk_test_title">Vosk Reconnaissance Vocale</string>
    <string name="button_test_vosk">Démarrer l\'écoute</string>
    <string name="button_stop_vosk">Arrêter l\'écoute</string>
    <string name="vosk_status_idle">Statut : Inactif</string>
    <string name="vosk_status_listening">Statut : Écoute en cours...</string>
    <string name="vosk_status_result">Résultat :</string>
    <string name="vosk_permission_denied">Erreur : Permission du microphone refusée.</string>

    <string name="ml_kit_test_title">Tests ML Kit</string>
    <string name="ocr_test_title">Reconnaissance de Texte (OCR)</string>
    <string name="button_run_ocr_test">Lancer test OCR</string>
    <string name="object_detection_title">Détection d\'Objets</string>
    <string name="button_run_object_test">Lancer test Détection</string>

    <string name="language_id_title">Identification &amp; Traduction de Langue</string>
    <string name="language_id_hint">Écrivez du texte ici...</string>
    <string name="button_run_language_test">Identifier &amp; Traduire (vers FR)</string>

    <string name="gemma_test_title">Test Gemma LLM</string>
    <string name="gemma_prompt_hint">Entrez un prompt pour Gemma...</string>
    <string name="button_run_gemma_test">Envoyer à Gemma</string>
    <string name="gemma_status_thinking">Gemma réfléchit...</string>
    <string name="gemma_status_result">Réponse de Gemma :</string>
    <string name="model_not_initialized">Modèle non initialisé</string>

    <string name="dialog_connection_title">Accepter la connexion de %1$s ?</string>
    <string name="dialog_connection_message">Confirmez que le code est : %1$s</string>
    <string name="dialog_accept">Accepter</string>
    <string name="dialog_decline">Refuser</string>
    <string name="card_record_format" translatable="false">🏆 %1$d / 💔 %2$d</string>
    <string name="card_distance_format_m" translatable="false">%.1fm</string>
    <string name="card_distance_format_cm" translatable="false">%.0fcm</string>

</resources>

--- END OF FILE app/src/main/res/values-fr/strings.xml ---


--- START OF FILE app/src/main/res/values-jp/strings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="sort_by_prompt">並べ替え…</string>
    <string name="app_name">KiKKo サーガフォージ</string>
    <string name="model_manager">モデル管理</string>
    <string name="downloaded_size">%1$s ダウンロード済み</string>
    <string name="cancel">キャンセル</string>
    <string name="ok">OK</string>
    <string name="confirm_delete_model_dialog_title">ダウンロードを削除</string>
    <string name="confirm_delete_model_dialog_content">ダウンロードしたモデル「%s」を本当に削除しますか？</string>
    <string name="notification_title_success">モデルのダウンロードに成功しました</string>
    <string name="notification_content_success">モデル「%s」がダウンロードされました</string>
    <string name="notification_title_fail">モデルのダウンロードに失敗しました</string>
    <string name="notification_content_fail">モデル「%s」のダウンロードに失敗しました</string>
    <string name="chat_textinput_placeholder">メッセージを入力…</string>
    <string name="chat_you">あなた</string>
    <string name="chat_llm_agent_name">LLM</string>
    <string name="chat_generic_agent_name">モデル</string>
    <string name="chat_generic_result_name">結果</string>
    <string name="model_not_downloaded_msg">モデルはまだダウンロードされていません</string>
    <string name="model_is_initializing_msg">モデルを初期化中…</string>
    <string name="text_input_placeholder_text_classification">分類する映画のレビューを入力…</string>
    <string name="text_image_generation_text_field_placeholder">プロンプトを入力…</string>
    <string name="text_input_placeholder_llm_chat">プロンプトを入力…</string>
    <string name="run_again">再実行</string>
    <string name="benchmark">ベンチマークを実行</string>
    <string name="warming_up">準備中…</string>
    <string name="running">実行中</string>

    <string name="debug_activity_title">Kikkoデバッグ＆テストラボ</string>
    <string name="model_management_title">モデル管理</string>
    <string name="service_testing_title">サービス テスト</string>

    <string name="status_downloading">ダウンロード中... %1$d%%</string>
    <string name="status_unzipping">解凍中...</string>
    <string name="status_ready">準備完了</string>
    <string name="status_not_downloaded">未ダウンロード</string>
    <string name="status_error">エラー</string>
    <string name="button_download">ダウンロード</string>
    <string name="button_delete">削除</string>

    <string name="vosk_test_title">Vosk 音声認識</string>
    <string name="button_test_vosk">聞き取り開始</string>
    <string name="button_stop_vosk">聞き取り停止</string>
    <string name="vosk_status_idle">状態：待機中</string>
    <string name="vosk_status_listening">状態：聞き取り中...</string>
    <string name="vosk_status_result">結果：</string>
    <string name="vosk_permission_denied">エラー：マイクの使用許可がありません。</string>

    <string name="ml_kit_test_title">ML Kit テスト</string>
    <string name="ocr_test_title">テキスト認識 (OCR)</string>
    <string name="button_run_ocr_test">OCRテスト実行</string>
    <string name="object_detection_title">物体検出</string>
    <string name="button_run_object_test">物体検出テスト実行</string>

    <string name="language_id_title">言語の識別と翻訳</string>
    <string name="language_id_hint">ここにテキストを入力...</string>
    <string name="button_run_language_test">識別して翻訳 (日本語へ)</string>

    <string name="gemma_test_title">Gemma LLM テスト</string>
    <string name="gemma_prompt_hint">Gemmaへのプロンプトを入力...</string>
    <string name="button_run_gemma_test">Gemmaに送信</string>
    <string name="gemma_status_thinking">Gemmaは考え中です...</string>
    <string name="gemma_status_result">Gemmaの応答：</string>
    <string name="model_not_initialized">モデルが初期化されていません</string>

    <string name="dialog_connection_title">%1$sからの接続を承認しますか？</string>
    <string name="dialog_connection_message">コードが %1$s であることを確認してください</string>
    <string name="dialog_accept">承認</string>
    <string name="dialog_decline">拒否</string>
    <string name="card_record_format" translatable="false">🏆 %1$d / 💔 %2$d</string>
    <string name="card_distance_format_m" translatable="false">%.1fm</string>
    <string name="card_distance_format_cm" translatable="false">%.0fcm</string>

</resources>

--- END OF FILE app/src/main/res/values-jp/strings.xml ---


--- START OF FILE app/src/main/res/values-night/themes.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
  <style name="Theme.Gallery" parent="android:Theme.Material.Light.NoActionBar" />
  <style name="Theme.Gallery.SplashScreen" parent="Theme.SplashScreen">
    <item name="windowSplashScreenBackground">#2A2A34</item>
    <item name="postSplashScreenTheme">@style/Theme.Gallery</item>
  </style>
  <style name="Theme.Gallery.OssLicenses" parent="Theme.AppCompat.Light.DarkActionBar">
    <item name="android:windowOptOutEdgeToEdgeEnforcement" tools:targetApi="35">true</item>
  </style>
  <style name="Theme.Kikko.FullScreenDialog" parent="Theme.Material3.DayNight.Dialog">
    <item name="android:windowIsFloating">false</item>
    <item name="android:windowBackground">@android:color/transparent</item>
    <item name="android:windowContentOverlay">@null</item>
    <item name="android:windowTitleStyle">@null</item>
    <item name="android:backgroundDimEnabled">true</item>
  </style>

  <style name="Theme.KikkoSagaForge" parent="Theme.Material3.DayNight.NoActionBar">
    <!-- BOURDON'S FIX: Rendre la barre de statut transparente et les icônes claires -->
    <item name="android:statusBarColor">@android:color/transparent</item>
    <item name="android:windowLightStatusBar">false</item>

    <!-- Palette de couleurs primaires -->
    <item name="colorPrimary">@color/kikko_honey_yellow</item>
    <item name="colorPrimaryContainer">@color/kikko_leaf_green</item>
    <item name="colorOnPrimaryContainer">@color/kikko_bark_brown</item>
    <item name="colorSecondary">@color/kikko_magic_cyan</item>
    <item name="colorSecondaryContainer">@color/kikko_sky_blue</item>
    <item name="colorOnSecondaryContainer">@color/kikko_bark_brown</item>
    <item name="android:colorBackground">@color/kikko_light_gray</item>
    <item name="colorSurface">@color/white</item>
    <item name="colorOnBackground">@color/kikko_bark_brown</item>
    <item name="colorOnSurface">@color/kikko_bark_brown</item>
    <item name="colorError">@color/kikko_error_red</item>

    <item name="materialAlertDialogTheme">@style/KikkoAlertDialogTheme</item>
  </style>

  <style name="KikkoAlertDialogTheme" parent="ThemeOverlay.Material3.MaterialAlertDialog">
    <item name="colorPrimary">@color/kikko_honey_yellow</item>
    <item name="colorSecondary">@color/kikko_magic_cyan</item>
    <item name="colorSurface">@color/white</item>
    <item name="colorOnSurface">@color/kikko_bark_brown</item>
    <item name="android:background">@color/white</item>
    <item name="android:textColorPrimary">@color/kikko_bark_brown</item>
    <item name="android:textColorSecondary">@color/kikko_dark_gray</item>
    <item name="shapeAppearance">@style/KikkoDialogShape</item>
  </style>

  <style name="KikkoDialogShape" parent="ShapeAppearance.Material3.MediumComponent">
    <item name="cornerFamily">rounded</item>
    <item name="cornerSize">16dp</item>
  </style>
</resources>

--- END OF FILE app/src/main/res/values-night/themes.xml ---


--- START OF FILE app/src/main/res/values/arrays.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="sort_options">
        <item>Trier par Nom</item>
        <item>Trier par Deck</item>
    </string-array>
</resources>

--- END OF FILE app/src/main/res/values/arrays.xml ---


--- START OF FILE app/src/main/res/values/colors.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#ffffff</color>
    <color name="kikko_gold">#FFD700</color>
    <color name="kikko_gold_light">#40FFD700</color>

    <!-- BOURDON'S REFORGE: Parchment Theme Colors -->
    <color name="kikko_parchment">#FBF5E6</color>
    <color name="kikko_ink_brown">#5D4037</color>
    <color name="kikko_sepia_outline">#D7CCC8</color>
    <!-- End of Reforge -->

    <color name="kikko_success_green">@color/kikko_leaf_green</color>
    <color name="kikko_honey_yellow">#FFC300</color>
    <color name="kikko_bark_brown">#582F0E</color>
    <color name="kikko_leaf_green">#A4D4AE</color>
    <color name="kikko_sky_blue">#A9D6E5</color>
    <color name="kikko_magic_cyan">#45B69C</color>
    <color name="kikko_bud_pink">#F28FAD</color>

    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="kikko_light_gray">#FFF6F6F6</color>
    <color name="kikko_dark_gray">#FF333333</color>
    <color name="kikko_error_red">#B00020</color>

    <color name="turtle_blue">#03A9F4</color>
    <color name="turtle_green">#4CAF50</color>
    <color name="turtle_red">#F44336</color>
    <color name="turtle_purple">#9C27B0</color>
    <color name="turtle_orange">#FF9800</color>
    <color name="turtle_pink">#E91E63</color>

    <array name="turtle_colors">
        <item>@color/turtle_blue</item>
        <item>@color/turtle_green</item>
        <item>@color/turtle_red</item>
        <item>@color/turtle_purple</item>
        <item>@color/turtle_orange</item>
        <item>@color/turtle_pink</item>
    </array>

    <color name="kikko_background">#FEF7FF</color>
    <color name="kikko_primary">#6750A4</color>
    <color name="kikko_primary_variant">#4F378B</color>
    <color name="kikko_secondary">#625B71</color>
    <color name="kikko_secondary_variant">#4A4458</color>
    <color name="kikko_surface">#FEF7FF</color>
    <color name="kikko_surface_variant">#E7E0EC</color>
    <color name="kikko_outline">#79747E</color>
    <color name="kikko_on_primary">#FFFFFF</color>
    <color name="kikko_on_secondary">#FFFFFF</color>
    <color name="kikko_on_surface">#1D1B20</color>
    <color name="kikko_on_surface_variant">#49454F</color>
    <color name="kikko_error">#B3261E</color>
    <color name="kikko_on_error">#FFFFFF</color>

</resources>

--- END OF FILE app/src/main/res/values/colors.xml ---


--- START OF FILE app/src/main/res/values/dimens.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->


<resources>
    <dimen name="model_selector_height">54dp</dimen>
    <dimen name="chat_bubble_corner_radius">24dp</dimen>
</resources>

--- END OF FILE app/src/main/res/values/dimens.xml ---


--- START OF FILE app/src/main/res/values/plurals.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- BOURDON'S NOTE: This file handles strings that change based on quantity (singular/plural). -->
    <plurals name="import_saga_success" translatable="false">
        <item quantity="one">%1$d new card imported successfully!</item>
        <item quantity="other">%1$d new cards imported successfully!</item>
    </plurals>
    <plurals name="workshop_tasks_ready" translatable="false">
        <item quantity="one">%1$d task ready for the tournament.</item>
        <item quantity="other">%1$d tasks ready for the tournament.</item>
    </plurals>
</resources>

--- END OF FILE app/src/main/res/values/plurals.xml ---


--- START OF FILE app/src/main/res/values/strings.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- =============================================================== -->
    <!-- ORIGINAL STRINGS (TRANSLATABLE) -->
    <!-- =============================================================== -->
    <string name="app_name">KiKKo Saga Forge</string>
    <string name="model_manager">Model Manager</string>
    <string name="downloaded_size">%1$s downloaded</string>
    <string name="cancel">Cancel</string>
    <string name="ok">OK</string>
    <string name="confirm_delete_model_dialog_title">Delete download</string>
    <string name="confirm_delete_model_dialog_content">Are you sure you want to delete the downloaded model \"%s\"?</string>
    <string name="notification_title_success">Model download succeeded</string>
    <string name="notification_content_success">Model \"%s\" has been downloaded</string>
    <string name="notification_title_fail">Model download failed</string>
    <string name="notification_content_fail">Failed to download model \"%s\"</string>
    <string name="chat_textinput_placeholder">Type message…</string>
    <string name="chat_you">You</string>
    <string name="chat_llm_agent_name">LLM</string>
    <string name="chat_generic_agent_name">Model</string>
    <string name="chat_generic_result_name">Result</string>
    <string name="model_not_downloaded_msg">Model not downloaded yet</string>
    <string name="model_is_initializing_msg">Initializing model…</string>
    <string name="text_input_placeholder_text_classification">Type movie review to classify…</string>
    <string name="text_image_generation_text_field_placeholder">Type prompt…</string>
    <string name="text_input_placeholder_llm_chat">Type prompt…</string>
    <string name="run_again">Run again</string>
    <string name="benchmark">Run benchmark</string>
    <string name="warming_up">warming up…</string>
    <string name="running">running</string>
    <string name="debug_activity_title">Kikko Debug &amp; Test Lab</string>
    <string name="model_management_title">Model Management</string>
    <string name="service_testing_title">Service Testing</string>
    <string name="status_downloading">Downloading... %1$d%%</string>
    <string name="status_unzipping">Unzipping...</string>
    <string name="status_ready">Ready</string>
    <string name="status_not_downloaded">Not Downloaded</string>
    <string name="status_error">Error</string>
    <string name="button_download">Download</string>
    <string name="button_delete">Delete</string>
    <string name="sort_by_prompt">Sort by…</string>
    <string name="vosk_test_title">Vosk Speech-to-Text</string>
    <string name="button_test_vosk">Start Listening</string>
    <string name="button_stop_vosk">Stop Listening</string>
    <string name="vosk_status_idle">Status: Idle</string>
    <string name="vosk_status_listening">Status: Listening...</string>
    <string name="vosk_status_result">Result:</string>
    <string name="vosk_permission_denied">Error: Microphone permission denied.</string>
    <string name="ml_kit_test_title">ML Kit Tests</string>
    <string name="ocr_test_title">Text Recognition (OCR)</string>
    <string name="button_run_ocr_test">Run OCR Test</string>
    <string name="object_detection_title">Object Detection</string>
    <string name="button_run_object_test">Run Object Test</string>
    <string name="language_id_title">Language ID &amp; Translation</string>
    <string name="language_id_hint">Type text here...</string>
    <string name="button_run_language_test">Identify &amp; Translate (to FR)</string>
    <string name="gemma_test_title">Gemma LLM Test</string>
    <string name="gemma_prompt_hint">Enter a prompt for Gemma...</string>
    <string name="button_run_gemma_test">Send to Gemma</string>
    <string name="gemma_status_thinking">Gemma is thinking...</string>
    <string name="gemma_status_result">Gemma\'s response:</string>
    <string name="model_not_initialized">Model not initialized</string>
    <string name="dialog_connection_title">Accept connection from %1$s?</string>
    <string name="dialog_connection_message">Confirm the code is: %1$s</string>
    <string name="dialog_accept">Accept</string>
    <string name="dialog_decline">Decline</string>
    <string name="card_record_format" translatable="false">🏆 %1$d / 💔 %2$d</string>
    <string name="card_distance_format_m" translatable="false">%.1fm</string>
    <string name="card_distance_format_cm" translatable="false">%.0fcm</string>

    <!-- =================================================================================== -->
    <!-- BOURDON'S I18N AUDIT - NEW CENTRALIZED STRINGS (CURRENTLY NON-TRANSLATABLE) -->
    <!-- =================================================================================== -->

    <!-- Generic Errors -->
    <string name="error_unknown" translatable="false">Unknown error</string>
    <string name="error_title" translatable="false">Error</string>
    <string name="error_generic_prefix" translatable="false">Error: %1$s</string>
    <string name="error_no_model_selected" translatable="false">No AI model is selected or available.</string>
    <string name="dialog_ok" translatable="false">OK</string>

    <!-- StartActivity Layout -->
    <string name="app_title_multiline" translatable="false">KiKKo\'s\nSaga Forge</string>
    <string name="navigation_decks" translatable="false">Decks</string>
    <string name="navigation_pollen_live" translatable="false">Pollen Live</string>
    <string name="navigation_forge" translatable="false">Forge</string>
    <string name="navigation_clash" translatable="false">Clash</string>

    <!-- StartActivity & ToolsDialog Logic -->
    <string name="import_saga_failure" translatable="false">Saga import failed.</string>
    <string name="importing_new_model" translatable="false">Importing new model...</string>
    <string name="import_new_model_success" translatable="false">New model added successfully!</string>
    <string name="import_new_model_failure" translatable="false">Error importing new model.</string>
    <string name="vosk_model_import_success" translatable="false">Vosk model \'%1$s\' imported!</string>
    <string name="vosk_model_import_failure" translatable="false">Error: %1$s</string>
    <string name="vosk_model_import_invalid_zip" translatable="false">Invalid Zip or does not contain a model folder.</string>
    <string name="secret_interaction_unlocked" translatable="false">Secret interaction unlocked!</string>
    <string name="hive_memory_cleared" translatable="false">Hive Memory cleared!</string>
    <string name="dialog_confirmation_required_title" translatable="false">Confirmation Required</string>
    <string name="dialog_nuke_db_message" translatable="false">Are you absolutely sure you want to erase ALL Hive memory (cards and pollen)? This action is irreversible.</string>
    <string name="dialog_confirm_nuke" translatable="false">Yes, clear everything</string>
    <string name="dialog_cancel" translatable="false">Cancel</string>
    <string name="mic_permission_denied" translatable="false">Microphone permission denied.</string>
    <string name="mic_permission_granted" translatable="false">Permission granted. Hold to speak.</string>
    <string name="counter_label_raw" translatable="false">Raw: %1$d</string>
    <string name="counter_label_forging" translatable="false">In Forge: %1$d</string>
    <string name="counter_label_honey" translatable="false">Honey: %1$d</string>
    <string name="counter_label_error" translatable="false">Errors: %1$d</string>
    <string name="vosk_loading_model" translatable="false">Loading %1$s...</string>
    <string name="vosk_loading_model_failed" translatable="false">Failed to load model.</string>
    <string name="vosk_model_deleted_success" translatable="false">Model \'%1$s\' deleted.</string>
    <string name="vosk_model_deleted_failure" translatable="false">Failed to delete model \'%1$s\'.</string>
    <string name="share_saga_title" translatable="false">Share Kikko Saga</string>
    <string name="export_saga_failure" translatable="false">Export failed. No cards to export?</string>
    <string name="model_deleted_success" translatable="false">\'%1$s\' deleted.</string>
    <string name="model_deleted_failure" translatable="false">Failed to delete \'%1$s\'.</string>

    <!-- ToolsDialog Layout -->
    <string name="tools_dialog_title" translatable="false">Forager\'s Toolbox</string>
    <string name="tools_active_queen_forge" translatable="false">Active AI Queen for the Forge</string>
    <string name="tools_queen_accelerator" translatable="false">Queen\'s Brain</string>
    <string name="tools_accelerator_cpu" translatable="false">CPU (Stable)</string>
    <string name="tools_accelerator_gpu" translatable="false">GPU (Fast)</string>
    <string name="tools_voice_recognition" translatable="false">Voice Recognition (Vosk)</string>
    <string name="tools_button_load_vosk" translatable="false">Load a new voice model (.zip)</string>
    <string name="tools_forge_settings" translatable="false">Forge Settings</string>
    <string name="tools_forge_require_charging" translatable="false">Forge only while charging</string>
    <string name="tools_forge_require_idle" translatable="false">Forge only when device is idle</string>
    <string name="tools_manage_local_queens" translatable="false">Manage Local AI Queens</string>
    <string name="tools_button_add_queen" translatable="false">Add a new AI Queen (.task)</string>
    <string name="tools_saga_management" translatable="false">Saga Management (Card Decks)</string>
    <string name="tools_button_import_saga" translatable="false">Import Saga</string>
    <string name="tools_button_export_saga" translatable="false">Export Saga</string>
    <string name="tools_danger_zone" translatable="false">⚠️ Danger Zone</string>
    <string name="tools_button_nuke_db" translatable="false">Erase Entire Hive Memory</string>
    <string name="queen_selected_toast" translatable="false">\'%1$s\' is now the Queen of the Forge.</string>
    <string name="accelerator_set_toast" translatable="false">Queen\'s Brain set to: %1$s</string>
    <string name="forge_charging_toast" translatable="false">Forge while charging: %1$s</string>
    <string name="forge_idle_toast" translatable="false">Forge when idle: %1$s</string>
    <string name="generic_enabled" translatable="false">Enabled</string>
    <string name="generic_disabled" translatable="false">Disabled</string>
    <string name="tools_button_download_more_queens" translatable="false">Download More Queens</string>
    <string name="tools_button_download_decks" translatable="false">Download Decks</string>
    <string name="tools_prompt_management_title" translatable="false">Queen\'s Decrees (Prompts)</string>
    <string name="tools_button_manage_prompts" translatable="false">Manage Queen\'s Decrees</string>

    <!-- Clash -->
    <string name="clash_title" translatable="false">CLASH</string>
    <string name="clash_judge_awakening" translatable="false">The AI Judge is awakening...</string>
    <string name="clash_button_random_desc" translatable="false">Generate random teams</string>
    <string name="clash_button_settings_desc" translatable="false">Clash settings</string>
    <string name="clash_button_radar_desc" translatable="false">Find P2P opponents</string>
    <string name="clash_button_start_solo" translatable="false">Start Clash</string>
    <string name="p2p_panel_close_desc" translatable="false">Close P2P panel</string>
    <string name="p2p_permissions_required" translatable="false">P2P permissions are required.</string>
    <string name="p2p_default_player_name" translatable="false">KikkoUser%1$d</string>
    <string name="p2p_status_inactive" translatable="false">P2P Arena inactive.</string>
    <string name="p2p_status_connected" translatable="false">Connected! Choose your champions.</string>
    <string name="p2p_status_connection_failed" translatable="false">Connection failed.</string>
    <string name="p2p_status_disconnected" translatable="false">Disconnected.</string>
    <string name="judge_awakening_please_wait" translatable="false">The AI Judge is awakening, please wait.</string>
    <string name="inference_error_generic" translatable="false">Generic inference error</string>
    <string name="judge_ready_toast" translatable="false">AI Judge \'%1$s\' is ready for the Clash!</string>
    <string name="judge_error_toast" translatable="false">AI Judge Error: %1$s</string>
    <string name="error_not_enough_cards_in_deck" translatable="false">You need at least 2 cards in the \'%1$s\' deck.</string>
    <string name="verdict_parse_reasoning_fallback" translatable="false">The Judge remained silent.</string>
    <string name="verdict_parse_tts_fallback_script" translatable="false">The verdict is in!</string>
    <string name="verdict_parse_error_reasoning" translatable="false">The AI Judge provided a verdict in an unexpected format.</string>
    <string name="verdict_parse_error_tts" translatable="false">The Judge is perplexed.</string>
    <string name="clash_waiting_for_opponent" translatable="false">Waiting for your opponent\'s choice.</string>
    <string name="clash_waiting_for_judge" translatable="false">Please wait for the AI Judge to awaken.</string>
    <string name="clash_no_cards_in_deck" translatable="false">No cards in deck \'%1$s\'.</string>
    <string name="clash_tournament_finished" translatable="false">Tournament finished!</string>
    <string name="dialog_arena_ready_title" translatable="false">Arena Ready!</string>
    <string name="dialog_arena_ready_message" translatable="false">Your teams are complete. Start the Clash?</string>
    <string name="dialog_launch" translatable="false">Launch</string>
    <string name="dialog_teams_complete_title" translatable="false">Teams Complete</string>
    <string name="dialog_waiting_for_host_message" translatable="false">Waiting for the host to start the Clash...</string>
    <string name="clash_setup_dialog_title" translatable="false">Clash Preparation</string>
    <string name="clash_judge_status_placeholder" translatable="false">Waiting for Judge configuration...</string>
    <string name="clash_judge_status_format" translatable="false">Queen: %1$s | Brain: %2$s | Temp: %3$.2f</string>
    <string name="clash_selector_title_format" translatable="false">Player %1$d - Deck %2$s</string>

    <!-- Clash Duel -->
    <string name="clash_duel_vs" translatable="false">VS</string>
    <string name="clash_duel_button_previous" translatable="false">Previous</string>
    <string name="clash_duel_button_next" translatable="false">Next</string>
    <string name="clash_duel_button_finish" translatable="false">Finish</string>
    <string name="clash_duel_question_placeholder" translatable="false">...</string>

    <!-- ForgeLive -->
    <string name="bourdon_avatar_desc" translatable="false">Bourdon\'s avatar</string>
    <string name="bourdon_message_placeholder" translatable="false">Bourdon\'s message...</string>
    <string name="button_capture_now" translatable="false">Capture now</string>
    <string name="button_hold_to_speak_desc" translatable="false">Hold to speak</string>
    <string name="button_skip" translatable="false">Skip</string>
    <string name="button_switch_camera_desc" translatable="false">Switch camera</string>
    <string name="bourdon_ask_intent" translatable="false">Hey Forager, do you have an idea of what pollen you want to collect?</string>
    <string name="bourdon_confirm_intent" translatable="false">Okay, I got it: \"%1$s\"! We\'ll make some Honey out of this. You can now capture your pollen.</string>
    <string name="bourdon_skip_intent" translatable="false">Perfect! Show me directly what you want to forge.</string>
    <string name="bourdon_harvest_complete" translatable="false">Great harvest! Shall we start forging or do you want to try again?</string>
    <string name="bourdon_harvest_complete_alt" translatable="false">Good harvest! Do you want to start making Honey or restart the pollen capture?</string>
    <string name="bourdon_save_pollen" translatable="false">Saving pollen to the Hive...</string>
    <string name="bourdon_save_error" translatable="false">Error: could not save pollen images.</string>
    <string name="bourdon_save_success" translatable="false">Pollen saved! Automatic identification has started.</string>
    <string name="pollen_capture_button_default" translatable="false">Capture</string>
    <string name="pollen_capture_button_full" translatable="false">Maximum Reached</string>
    <string name="pollen_capture_button_format" translatable="false">Capture (%1$d/4)</string>
    <string name="pollen_save_toast" translatable="false">Pollen saved!</string>
    <string name="pollen_capture_error_toast" translatable="false">Capture error.</string>
    <string name="pollen_capture_failed_toast" translatable="false">Capture failed</string>
    <string name="button_finish_harvest" translatable="false">Finish</string>
    <string name="button_restart_harvest" translatable="false">Restart</string>
    <string name="button_send_to_hive" translatable="false">Send to Hive</string>
    <string name="specialist_report_dialog_title" translatable="false">Specialist Analysis Report</string>
    <string name="specialist_report_global_title" translatable="false">--- Global Analysis Report ---</string>
    <string name="specialist_report_no_global" translatable="false">No global classification found.</string>
    <string name="specialist_report_specialist_opinion" translatable="false">Specialist Opinion (%1$s):</string>
    <string name="specialist_report_item" translatable="false">  - %1$s (%.1f%%)</string>
    <string name="specialist_report_objects_title" translatable="false">\n--- Detected Objects (%1$d) ---</string>
    <string name="specialist_report_no_objects" translatable="false">No objects detected.</string>
    <string name="specialist_report_object_item" translatable="false">%1$d. %2$s (%.1f%%)</string>
    <string name="specialist_report_unknown_object" translatable="false">Unknown Object</string>
    <string name="specialist_report_object_specialist_item" translatable="false">  - %1$s: %2$s</string>
    <string name="vosk_model_loaded_toast" translatable="false">Voice model \'%1$s\' loaded.</string>
    <string name="bourdon_welcome_capture" translatable="false">Welcome Forager! Point your camera at anything you wish to forge.</string>


    <!-- ForgeWorkshop -->
    <string name="workshop_title" translatable="false">Royal Forge Workshop</string>
    <string name="deck_emoji_raw" translatable="false">?</string>
    <string name="deck_name_raw" translatable="false">Raw</string>
    <string name="workshop_button_back_desc" translatable="false">Back</string>
    <string name="workshop_filter_raw_desc" translatable="false">Filter by Raw Pollen</string>
    <string name="workshop_filter_food_desc" translatable="false">Filter by Food Deck</string>
    <string name="workshop_filter_plant_desc" translatable="false">Filter by Plant Deck</string>
    <string name="workshop_filter_insect_desc" translatable="false">Filter by Insect Deck</string>
    <string name="workshop_filter_bird_desc" translatable="false">Filter by Bird Deck</string>
    <string name="workshop_selected_image_desc" translatable="false">Selected pollen grain image</string>
    <string name="workshop_button_reject_grain" translatable="false">Reject this Grain</string>
    <string name="workshop_expand_section_desc" translatable="false">Expand/Collapse section</string>
    <string name="workshop_grain_id_format" translatable="false">Grain ID: %1$s...</string>
    <string name="workshop_deck_format" translatable="false">Deck: %1$s</string>
    <string name="workshop_results_count" translatable="false">(%1$d results)</string>
    <string name="workshop_validate_identification_first" translatable="false">Validate identification first</string>
    <string name="workshop_forge_ingredients_first" translatable="false">Forge Ingredients first</string>
    <string name="dialog_error_details_title" translatable="false">Error Details</string>
    <string name="error_identification_not_validated" translatable="false">Identification must be validated before refining other properties.</string>
    <string name="error_ingredients_not_forged" translatable="false">Cannot forge allergens until ingredients have been successfully forged.</string>
    <string name="error_queen_model_file_not_found_format" translatable="false">AI Queen file \'%1$s\' not found.</string>
    <string name="error_queen_init_failed_format" translatable="false">AI Queen initialization failed: %1$s</string>
    <string name="error_pollen_parent_not_found" translatable="false">Parent pollen grain not found.</string>
    <string name="error_swarm_report_missing" translatable="false">Swarm report is missing.</string>
    <string name="error_card_not_found_for_refinement" translatable="false">Card not available for property refinement.</string>
    <string name="error_json_malformed_or_incomplete" translatable="false">The JSON result is malformed or incomplete.</string>
    <string name="fallback_reasoning_visual" translatable="false">Visual analysis not extracted</string>
    <string name="fallback_reasoning_correlation" translatable="false">Correlation by Regex</string>
    <string name="error_validation_parsing_failed" translatable="false">Both smart JSON parsing and Regex fallback failed.</string>
    <string name="error_json_malformed" translatable="false">The JSON response is malformed.</string>
    <string name="error_json_key_missing" translatable="false">Key \'%1$s\' is missing in the JSON response.</string>
    <string name="workshop_loading_grains" translatable="false">Loading pollen grains...</string>
    <string name="workshop_no_grains_to_forge" translatable="false">No pollen grains to forge.</string>
    <string name="workshop_awaiting_validation" translatable="false">Identification awaiting validation.</string>
    <string name="workshop_ready_to_refine" translatable="false">Ready to refine.</string>
    <string name="workshop_preparing_competition" translatable="false">Preparing competition for \'%1$s\'...</string>
    <string name="workshop_no_queens_installed" translatable="false">Error: No AI Queens are installed for the competition!</string>
    <string name="workshop_validating_identification" translatable="false">Validating identification...</string>
    <string name="workshop_validation_error" translatable="false">Validation error: %1$s</string>
    <string name="workshop_validating_property" translatable="false">Validating \'%1$s\'...</string>
    <string name="workshop_delete_grain_dialog_title" translatable="false">Confirmation Required</string>
    <string name="workshop_delete_grain_dialog_message" translatable="false">Are you sure you want to delete this pollen grain and all associated data (card, analyses, images)? This action is irreversible.</string>
    <string name="workshop_button_delete" translatable="false">Yes, delete</string>
    <string name="workshop_competition_summary_title" translatable="false">Competition Summary</string>
    <string name="workshop_summary_proposal_format" translatable="false">%1$d Queens propose: \"%2$s\"</string>
    <string name="workshop_button_validate" translatable="false">Validate</string>
    <string name="workshop_launch_competition" translatable="false">Launch Competition ⚔️</string>
    <string name="workshop_refinement_title_format" translatable="false">Refining: %1$s</string>
    <string name="property_title_identification" translatable="false">Main Identification</string>
    <string name="property_title_description" translatable="false">Narrative Description</string>
    <string name="property_title_ingredients" translatable="false">Ingredient List</string>
    <string name="property_title_allergens" translatable="false">Allergen Detection</string>
    <string name="property_title_energy" translatable="false">Energy Value</string>
    <string name="property_title_scientific_name" translatable="false">Scientific Name</string>
    <string name="property_title_vernacular_name" translatable="false">Common Name</string>
    <string name="property_title_flowering" translatable="false">Flowering Period</string>
    <string name="property_title_diet" translatable="false">Diet</string>
    <string name="property_title_wingspan" translatable="false">Wingspan</string>
    <string name="workshop_raw_pollen_title" translatable="false">Raw Pollen</string>
    <string name="workshop_deck_unknown" translatable="false">Deck: To be identified</string>
    <string name="workshop_no_grains_in_deck" translatable="false">No grains in this category.</string>
    <string name="workshop_competition_in_progress" translatable="false">Competition in Progress...</string>
    <string name="workshop_relaunch_competition" translatable="false">Relaunch Competition 🔄</string>
    <string name="dialog_relaunch_title" translatable="false">Relaunch Competition?</string>
    <string name="dialog_relaunch_message" translatable="false">This will delete all current analysis results for this property and create a new set of tasks. Are you sure?</string>
    <string name="dialog_relaunch_confirm" translatable="false">Yes, Relaunch</string>
    <string name="workshop_button_launch_judgment" translatable="false">Launch Final Judgment ⚖️</string>

    <!-- RoyalAudience -->
    <string name="audience_title_generic" translatable="false">Open Audience</string>
    <string name="audience_title_loading" translatable="false">Preparing Audience...</string>
    <string name="error_card_not_found" translatable="false">Card not found in database.</string>
    <string name="error_no_queen_installed_or_selected" translatable="false">No AI Queen is installed or selected.</string>
    <string name="error_queen_model_file_not_found" translatable="false">AI Queen model file not found.</string>
    <string name="error_queen_init_failed" translatable="false">Queen initialization failed: %1$s</string>
    <string name="queen_switching_message" translatable="false">Queen %1$s is retiring. Queen %2$s is preparing her arrival...</string>
    <string name="queen_waking_up" translatable="false">The Queen is waking up, please wait...</string>
    <string name="queen_ready_to_chat" translatable="false">There, I am ready. What would you like to discuss?</string>
    <string name="queen_settings_updated" translatable="false">Queen\'s decrees updated.</string>
    <string name="audience_no_voice_model" translatable="false">No voice model is loaded. Please import one via the Tools.</string>
    <string name="audience_default_voice_model_loaded" translatable="false">Default voice model loaded: \'%1$s\'.</string>
    <string name="audience_no_queen_available" translatable="false">No AI Queen is available. Please add one via the Tools.</string>
    <string name="audience_no_queen_available_short" translatable="false">No Queen</string>
    <string name="audience_dialog_select_queen_title" translatable="false">Choose the Queen</string>
    <string name="audience_toolbar_title" translatable="false">AI Chat</string>
    <string name="audience_button_back_description" translatable="false">Back</string>
    <string name="audience_button_settings_description" translatable="false">Configure the Queen</string>
    <string name="chat_input_hint" translatable="false">Chat with the Queen...</string>
    <string name="chat_attach_button_desc" translatable="false">Attach an image</string>
    <string name="chat_mic_button_desc" translatable="false">Dictate question</string>
    <string name="chat_send_button_desc" translatable="false">Send question</string>

    <!-- DeckViewer & CardDetails -->
    <string name="deck_select_food_desc" translatable="false">Select Food Deck</string>
    <string name="deck_emoji_food" translatable="false">🍔</string>
    <string name="deck_name_food" translatable="false">Food</string>
    <string name="deck_select_plant_desc" translatable="false">Select Plant Deck</string>
    <string name="deck_emoji_plant" translatable="false">🌿</string>
    <string name="deck_name_plant" translatable="false">Plant</string>
    <string name="deck_select_insect_desc" translatable="false">Select Insect Deck</string>
    <string name="deck_emoji_insect" translatable="false">🐞</string>
    <string name="deck_name_insect" translatable="false">Insect</string>
    <string name="deck_select_bird_desc" translatable="false">Select Bird Deck</string>
    <string name="deck_emoji_bird" translatable="false">🐦</string>
    <string name="deck_name_bird" translatable="false">Bird</string>
    <string name="card_deleted_toast" translatable="false">\'%1$s\' has been deleted.</string>
    <string name="translation_requested_toast" translatable="false">Translation for \'%1$s\' has been requested and will be processed in the background.</string>
    <string name="card_details_confidence_format" translatable="false">Confidence: %.2f</string>
    <string name="card_details_description_title" translatable="false">Description</string>
    <string name="card_details_reasoning_format" translatable="false">Visual Analysis: %1$s\nEvidence Correlation: %2$s</string>
    <string name="card_details_no_stats_available" translatable="false">No stats available.</string>
    <string name="card_details_button_delete" translatable="false">Delete</string>
    <string name="card_details_button_quiz" translatable="false">Launch Quiz</string>
    <string name="card_details_button_translate" translatable="false">Translate</string>
    <string name="card_details_button_chat" translatable="false">Discuss</string>

    <!-- Quiz -->
    <string name="quiz_no_questions_error" translatable="false">Error: No quiz questions found.</string>
    <string name="quiz_toolbar_title_format" translatable="false">Quiz: %1$s</string>
    <string name="quiz_progress_format" translatable="false">Question %1$d / %2$d</string>
    <string name="quiz_select_answer_prompt" translatable="false">Please select an answer.</string>
    <string name="quiz_feedback_correct" translatable="false">Correct answer!</string>
    <string name="quiz_feedback_incorrect" translatable="false">Incorrect. The correct answer was:\n\"%1$s\"</string>
    <string name="quiz_final_score_title" translatable="false">Quiz Finished!</string>
    <string name="quiz_final_score_message" translatable="false">Your score: %1$d / %2$d</string>
    <string name="quiz_button_finish" translatable="false">Finish</string>
    <string name="quiz_button_submit" translatable="false">Submit</string>
    <string name="quiz_button_next" translatable="false">Next Question</string>

    <!-- BOURDON'S I18N FIX: Worker Notifications -->
    <string name="notification_channel_name" translatable="false">Kikko Forge Background Work</string>
    <string name="notification_title" translatable="false">The Hive is working...</string>
    <string name="notification_forge_preparing" translatable="false">The Hive\'s Forge is preparing...</string>
    <string name="notification_forge_awakens" translatable="false">The Forge awakens...</string>
    <string name="notification_queen_identifying" translatable="false">Queen \'%1$s\' is identifying the pollen...</string>
    <string name="notification_queen_identifying_streaming" translatable="false">The Queen is identifying... (%1$d chars generated)</string>

    <!-- BOURDON'S ADDITION: Prompt Editor -->
    <string name="prompt_editor_title" translatable="false">Queen\'s Prompt Armory</string>
    <string name="menu_import_prompts" translatable="false">Import</string>
    <string name="menu_export_prompts" translatable="false">Export</string>
    <string name="menu_reset_prompts" translatable="false">Reset to Defaults</string>
    <string name="prompt_selector_label" translatable="false">Select Prompt to Edit:</string>
    <string name="prompt_editor_hint" translatable="false">Edit the content of the selected prompt here...</string>
    <string name="button_save_prompts" translatable="false">Save Changes</string>
    <string name="dialog_reset_prompts_title" translatable="false">Reset All Prompts?</string>
    <string name="dialog_reset_prompts_message" translatable="false">This will discard all your custom modifications and restore the original prompts that came with the app. This action is irreversible.</string>
    <string name="dialog_reset_confirm" translatable="false">Yes, Reset</string>
    <string name="toast_prompts_saved" translatable="false">Prompts saved successfully.</string>
    <string name="toast_prompts_restored" translatable="false">Prompts restored to default.</string>
    <string name="toast_import_success" translatable="false">Prompts imported successfully.</string>
    <string name="toast_import_failed" translatable="false">Failed to import prompts. The file might be invalid.</string>
    <string name="toast_export_failed" translatable="false">Failed to export prompts.</string>
    <string name="share_prompts_title" translatable="false">Share Kikko Prompts</string>

    <!-- BOURDON'S ADDITION: Judgment Tribunal -->
    <string name="judgment_dialog_title" translatable="false">Final Judgment</string>
    <string name="judgment_section_title_deliberation" translatable="false">Arbiter\'s Deliberation</string>
    <string name="judgment_section_title_decree" translatable="false">Arbiter\'s Decree (Prompt)</string>
    <string name="judgment_section_title_evidence" translatable="false">Evidence Presented</string>
    <string name="judgment_button_override" translatable="false">Override &amp; Choose Manually</string>
    <string name="judgment_button_confirm" translatable="false">Confirm Arbiter\'s Verdict</string>
    <string name="workshop_launching_judgment" translatable="false">Convening the Arbiter\'s Court for \'%1$s\'...</string>
    <string name="judgment_warning_in_progress" translatable="false">Warning: %1$d of %2$d Queens have finished. Your judgment will be based on partial evidence.</string>

</resources>

--- END OF FILE app/src/main/res/values/strings.xml ---


--- START OF FILE app/src/main/res/values/styles.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="KikkoText" parent="Widget.AppCompat.TextView">
        <item name="android:textColor">@color/kikko_on_surface</item>
    </style>

    <style name="KikkoText.Title">
        <item name="android:textSize">22sp</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="KikkoText.Body">
        <item name="android:textSize">16sp</item>
    </style>

    <style name="KikkoText.Caption">
        <item name="android:textSize">12sp</item>
        <item name="android:textColor">@color/kikko_on_surface_variant</item>
    </style>

    <style name="KikkoButton" parent="Widget.MaterialComponents.Button">
        <item name="android:textAllCaps">false</item>
    </style>

    <style name="KikkoButton.Secondary">
        <item name="android:textColor">@color/kikko_primary</item>
        <item name="strokeColor">@color/kikko_outline</item>
        <item name="strokeWidth">1dp</item>
        <item name="backgroundTint">@color/kikko_surface</item>
    </style>

</resources>

--- END OF FILE app/src/main/res/values/styles.xml ---


--- START OF FILE app/src/main/res/values/themes.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">

    <!-- Thème principal de l'application. Hérite de Material 3, sans ActionBar par défaut. -->
    <style name="Theme.KikkoSagaForge" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Rendre la barre de statut transparente pour une immersion totale -->
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:windowLightStatusBar">false</item>

        <!-- Palette de couleurs de la Ruche -->
        <item name="colorPrimary">@color/kikko_honey_yellow</item>
        <item name="colorPrimaryContainer">@color/kikko_leaf_green</item>
        <item name="colorOnPrimaryContainer">@color/kikko_bark_brown</item>
        <item name="colorSecondary">@color/kikko_magic_cyan</item>
        <item name="colorSecondaryContainer">@color/kikko_sky_blue</item>
        <item name="colorOnSecondaryContainer">@color/kikko_bark_brown</item>
        <item name="android:colorBackground">@color/kikko_light_gray</item>
        <item name="colorSurface">@color/white</item>
        <item name="colorOnBackground">@color/kikko_bark_brown</item>
        <item name="colorOnSurface">@color/kikko_bark_brown</item>
        <item name="colorError">@color/kikko_error_red</item>

        <!-- Thème personnalisé pour les boîtes de dialogue d'alerte -->
        <item name="materialAlertDialogTheme">@style/KikkoAlertDialogTheme</item>
    </style>

    <!-- Style pour les boîtes de dialogue plein écran (utilisé par CardDetails, etc.) -->
    <style name="Theme.Kikko.FullScreenDialog" parent="Theme.Material3.DayNight.Dialog">
        <item name="android:windowIsFloating">false</item>
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:windowTitleStyle">@null</item>
        <item name="android:backgroundDimEnabled">true</item>
    </style>

    <!-- Thème spécifique pour les boîtes de dialogue MaterialAlertDialog -->
    <style name="KikkoAlertDialogTheme" parent="ThemeOverlay.Material3.MaterialAlertDialog">
        <item name="colorPrimary">@color/kikko_honey_yellow</item>
        <item name="colorSecondary">@color/kikko_magic_cyan</item>
        <item name="colorSurface">@color/white</item>
        <item name="colorOnSurface">@color/kikko_bark_brown</item>
        <item name="android:background">@color/white</item>
        <item name="android:textColorPrimary">@color/kikko_bark_brown</item>
        <item name="android:textColorSecondary">@color/kikko_dark_gray</item>
        <item name="shapeAppearance">@style/KikkoDialogShape</item>
    </style>

    <!-- Forme personnalisée pour les coins arrondis des dialogues -->
    <style name="KikkoDialogShape" parent="ShapeAppearance.Material3.MediumComponent">
        <item name="cornerFamily">rounded</item>
        <item name="cornerSize">16dp</item>
    </style>

</resources>

--- END OF FILE app/src/main/res/values/themes.xml ---


--- START OF FILE app/src/main/res/xml/backup_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>

--- END OF FILE app/src/main/res/xml/backup_rules.xml ---


--- START OF FILE app/src/main/res/xml/data_extraction_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>

--- END OF FILE app/src/main/res/xml/data_extraction_rules.xml ---


--- START OF FILE app/src/main/res/xml/file_paths.xml ---

<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<paths>
    <cache-path
        name="cache_pictures"
        path="/" />

    <external-files-path
        name="my_external_files"
        path="." />

</paths>

--- END OF FILE app/src/main/res/xml/file_paths.xml ---


--- START OF FILE app/src/test/java/com/google/ai/edge/gallery/data/ModelAllowlistTest.kt ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.heyman.android.ai.kikko.data

import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.JUnit4

@RunWith(JUnit4::class)
class ModelAllowlistTest {
  @Test
  fun toModel_success() {
    val modelName = "test_model"
    val modelId = "test_model_id"
    val modelFile = "test_model_file"
    val description = "test description"
    val sizeInBytes = 100L
    val version = "20250623"
    val topK = 10
    val topP = 0.5f
    val temperature = 0.1f
    val maxTokens = 1000
    val accelerators = "gpu,cpu"
    val taskTypes = listOf("llm_chat", "ask_image")
    val estimatedPeakMemoryInBytes = 300L

    val allowedModel =
      AllowedModel(
        name = modelName,
        modelId = modelId,
        modelFile = modelFile,
        description = description,
        sizeInBytes = sizeInBytes,
        version = version,
        defaultConfig =
          DefaultConfig(
            topK = topK,
            topP = topP,
            temperature = temperature,
            maxTokens = maxTokens,
            accelerators = accelerators,
          ),
        taskTypes = taskTypes,
        llmSupportImage = true,
        llmSupportAudio = true,
        estimatedPeakMemoryInBytes = estimatedPeakMemoryInBytes,
      )
    val model = allowedModel.toModel()

    // Check that basic fields are set correctly.
    assertEquals(model.name, modelName)
    assertEquals(model.version, version)
    assertEquals(model.info, description)
    assertEquals(
      model.url,
      "https://huggingface.co/test_model_id/resolve/main/test_model_file?download=true",
    )
    assertEquals(model.sizeInBytes, sizeInBytes)
    assertEquals(model.estimatedPeakMemoryInBytes, estimatedPeakMemoryInBytes)
    assertEquals(model.downloadFileName, modelFile)
    assertFalse(model.showBenchmarkButton)
    assertFalse(model.showRunAgainButton)
    assertTrue(model.llmSupportImage)
    assertTrue(model.llmSupportAudio)

    // Check that configs are set correctly.
    assertEquals(model.configs.size, 5)

    // A label for showing max tokens (non-changeable).
    assertTrue(model.configs[0] is LabelConfig)
    assertEquals((model.configs[0] as LabelConfig).defaultValue, "$maxTokens")

    // A slider for topK.
    assertTrue(model.configs[1] is NumberSliderConfig)
    assertEquals((model.configs[1] as NumberSliderConfig).defaultValue, topK.toFloat())

    // A slider for topP.
    assertTrue(model.configs[2] is NumberSliderConfig)
    assertEquals((model.configs[2] as NumberSliderConfig).defaultValue, topP)

    // A slider for temperature.
    assertTrue(model.configs[3] is NumberSliderConfig)
    assertEquals((model.configs[3] as NumberSliderConfig).defaultValue, temperature)

    // A segmented button for accelerators.
    assertTrue(model.configs[4] is SegmentedButtonConfig)
    assertEquals((model.configs[4] as SegmentedButtonConfig).defaultValue, "GPU")
    assertEquals((model.configs[4] as SegmentedButtonConfig).options, listOf("GPU", "CPU"))
  }
}


--- END OF FILE app/src/test/java/com/google/ai/edge/gallery/data/ModelAllowlistTest.kt ---


--- START OF FILE build.gradle.kts ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
  alias(libs.plugins.android.application) apply false
  alias(libs.plugins.google.services) apply false
  alias(libs.plugins.kotlin.android) apply false
  alias(libs.plugins.kotlin.compose) apply false
  alias(libs.plugins.hilt.application) apply false
}


--- END OF FILE build.gradle.kts ---


--- START OF FILE settings.gradle.kts ---

/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pluginManagement {
  repositories {
    google {
      content {
        includeGroupByRegex("com\\.android.*")
        includeGroupByRegex("com\\.google.*")
        includeGroupByRegex("androidx.*")
      }
    }
    mavenCentral()
    gradlePluginPortal()
  }
  resolutionStrategy {
    eachPlugin {
      if (requested.id.id == "com.google.android.gms.oss-licenses-plugin") {
        useModule("com.google.android.gms:oss-licenses-plugin:0.10.6")
      }
    }
  }
}

dependencyResolutionManagement {
  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
  repositories {
    //        mavenLocal()
    google()
    mavenCentral()
  }
}

rootProject.name = "KiKKo Saga Forges"

include(":app")


--- END OF FILE settings.gradle.kts ---
